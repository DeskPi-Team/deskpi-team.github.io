{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"DeskPi Series Product Wiki Here you can provide product descriptions, product features, product documents, product application cases and some common problem solutions of DeskPi series products, and also provide some Demo code file downloads. Product List PicoMate Series: DP-0012: DP-0014: DP-0015: Buy from DeskPi Official Website","title":"Home"},{"location":"#deskpi-series-product-wiki","text":"Here you can provide product descriptions, product features, product documents, product application cases and some common problem solutions of DeskPi series products, and also provide some Demo code file downloads.","title":"DeskPi Series Product Wiki"},{"location":"#product-list","text":"PicoMate Series: DP-0012: DP-0014: DP-0015: Buy from DeskPi Official Website","title":"Product List"},{"location":"audiocheck/","text":"Getting Start . For order please visit: DeskPi.com . How to check audio output The audio output can be two ways: 3.5mm jack , HDMI cable . If you connect HDMI cable to your DeskPi on HDMI0 port which is beside USB-C Port on the back of the panel, it will be recognized by Raspbian OS as HDMI-1 , and the other one is recognized as HDMI-2 How to change audio output. Right Click the sound icon on the task bar. And select which one you want to output: Analog - It will change audio output to 3.5mm jack. HDMI-1 - It will change audio output to HDMI0 . HDMI-2 - It will change audio output to HDMI1 . And then restart your application you will heard the sound.","title":"How to check Audio Output"},{"location":"audiocheck/#getting-start","text":". For order please visit: DeskPi.com .","title":"Getting Start"},{"location":"audiocheck/#how-to-check-audio-output","text":"The audio output can be two ways: 3.5mm jack , HDMI cable . If you connect HDMI cable to your DeskPi on HDMI0 port which is beside USB-C Port on the back of the panel, it will be recognized by Raspbian OS as HDMI-1 , and the other one is recognized as HDMI-2","title":"How to check audio output"},{"location":"audiocheck/#how-to-change-audio-output","text":"Right Click the sound icon on the task bar. And select which one you want to output: Analog - It will change audio output to 3.5mm jack. HDMI-1 - It will change audio output to HDMI0 . HDMI-2 - It will change audio output to HDMI1 . And then restart your application you will heard the sound.","title":"How to change audio output."},{"location":"deskpilite/","text":"DeskPi Lite (deskpi_v1) Description The DeskPi V1 Case is a case made of ABS, and an adapter board is provided inside to transfer the HDMI interface, 3.5mm audio interface, and USB-C power interface of the Raspberry Pi to the back of the panel. and offer microHDMI to Full-sized HDMI interface, makes it convenient for users to use standard HDMI cables to connect external display devices. In addition, it provides an ultra-thin aluminum alloy heat sink and supports an adjustable-speed ultra-thin silent fan, which can be safely cut off Power supply for Raspberry Pi by sending a \"power_off\" signal to the adapter board. Purchase DeskPi Lite Features Convert the microHDMI to a Full-sized HDMI interface and place it on the back of the panel with the power interface Transfer 3.5mm audio interface to the back of the panel Support Raspberry Pi official fan temperature control function via raspi-config tool. Support system shutdown to safe cut off power on Raspberry Pi Support adjustable fan speed via PWM programming. Light weight heat-sink inside. Adjustable speed Fan Gallery Features Easy to install Expansion of 2 USB Ports Fast Cooling GPIO Interface Protect Non-Slip Rubber feet Port definitions Package includes 1 x DeskPi Lite Case (Plastic) 1 x CNC alloy aluminum heat sink with PWM fan and GPIO expansion board 1 x Port adapter board 1 x Instructions 6 x Thermal Pads 2 x LED indicator lampshade 2 x M2.5 Screw Working Principle RPi -> sending poweroff to /dev/ttyUSB0 means sending cut off power -> MCU on board: means MCU will cut of power of Raspberry Pi. RPi <- Reading poweroff from /dev/ttyUSB0 means shutdown system <- MCU on board: system will execute shutdown service or reboot (according to scripts definitions) when power button has been pressed twice. How to enable fan temperature control? NOTE: Raspberry Pi OS (Latest) will support this function. Open a terminal and typing following command: sudo raspi-config Navigate to Performance Options -> P4 Fan -> Yes -> 14 -> 60 -> yes -> finish -> reboot Raspberry Pi. The fan is support PWM signal control via GPIO14 which is physical pin 12 (TXD), it will spinning when the CPU temperature is above 60 degree. and also you can write your code to control the fan via GPIO14 , sending PWM signal will trigger the fan spinning. This case hardware uses direct GPIO header connections for the included PWM capable fan. Like in your bigger DeskPi case software, you could easily change from a /dev/ttyUSB0 to a GPIO PWM fan control service. For anyone else wanting to implement some form of PWM fan control, please see the included python3 script code below. This will enable: < 40'c - Fan 75%, for a minimum of 60sec 40'c to 45'c - Fan 85%, for a minimum of 120sec > 45'c - Fan 100%, for a minimum of 180sec In everyday use, this script offers good temperatrue control, with the CPU temp rarely reaches > 45'c and general fan noise is very low and still keeps good control via the PWM fan vs standard Raspberry Pi OS PWM fan control via /boot/config.txt or raspi-config. #!/usr/bin/python3 import RPi.GPIO as GPIO import time import subprocess GPIO . setmode ( GPIO . BCM ) GPIO . setup ( 14 , GPIO . OUT ) pwm = GPIO . PWM ( 14 , 100 ) print ( \" \\n Press Ctrl+C to quit \\n \" ) dc = 0 pwm . start ( dc ) try : while True : temp = subprocess . getoutput ( \"vcgencmd measure_temp|sed 's/[^0-9.]//g'\" ) if round ( float ( temp )) >= 45 : dc = 100 pwm . ChangeDutyCycle ( dc ) print ( \"CPU Temp:\" , float ( temp ), \" Fan duty cycle:\" , dc ) time . sleep ( 180.0 ) if round ( float ( temp )) >= 40 : dc = 85 pwm . ChangeDutyCycle ( dc ) print ( \"CPU Temp:\" , float ( temp ), \" Fan duty cycle:\" , dc ) time . sleep ( 120.0 ) else : dc = 70 pwm . ChangeDutyCycle ( dc ) print ( \"CPU Temp:\" , float ( temp ), \" Fan duty cycle:\" , dc ) time . sleep ( 60.00 ) except KeyboardInterrupt : pwm . stop () GPIO . cleanup () print ( \"Ctrl + C pressed -- Ending program\" ) Then execute it: python3 fan_control.py How to enable the USB2.0 in front of panel? Install DeskPi v1 driver. Add following parameter to /boot/config.txt file manually. dtoverlay = dwc2,dr_mode = host DO REMEMBER `reboot` Raspberry Pi to take effect. How to send power_off signal to adapter board to cut off power? Make sure you have already add dtoverlay=dwc2,dr_mode=host to /boot/config.txt file and reboot Raspberry Pi. Check if there is a device called /dev/ttyUSB0 Execute the python demo script in deskpi_v1/drivers/python/safecutoffpower.py you may need to install pyserial library. Recommend: adding this function after shutdown service, so that it can safely cut off the power of Raspberry Pi. How to reboot by double click power buttom? Principle when you double click the power button, The MCU on expansion board will send three times poweroffpoweroffpoweroff to serial port on raspberry Pi which generate via dwc2 dtoverlay, called /dev/ttyUSB0 , and you can capture it via python script and customized your own script to control the shutdown behavior. Demo code: Install pyserial library to control serial port. pip3 install pyserial Create a file named safe_shutdown.py and paste following code: import serial import time import os ser = serial.Serial('/dev/ttyUSB0', baudrate=9600, timeout=3) while True: if ser.isOpen(): data = ser.read(16) data = data.decode('utf-8') #print(data) if 'poweroff' in data: print(\"System will turn off in 3 seconds\") time.sleep(3) ser.write(b'power_off') ser.write(b'power_off') os.system('sudo sync && sudo init 0') 3. Execute it: python3 safe_shutdown.py You can also change the os.system(\"sudo reboot\") to reboot your Raspberry Pi. GitHub Repository deskpi_v1","title":"DeskPi Lite"},{"location":"deskpilite/#deskpi-lite-deskpi_v1","text":"","title":"DeskPi Lite (deskpi_v1)"},{"location":"deskpilite/#description","text":"The DeskPi V1 Case is a case made of ABS, and an adapter board is provided inside to transfer the HDMI interface, 3.5mm audio interface, and USB-C power interface of the Raspberry Pi to the back of the panel. and offer microHDMI to Full-sized HDMI interface, makes it convenient for users to use standard HDMI cables to connect external display devices. In addition, it provides an ultra-thin aluminum alloy heat sink and supports an adjustable-speed ultra-thin silent fan, which can be safely cut off Power supply for Raspberry Pi by sending a \"power_off\" signal to the adapter board.","title":"Description"},{"location":"deskpilite/#purchase","text":"DeskPi Lite","title":"Purchase"},{"location":"deskpilite/#features","text":"Convert the microHDMI to a Full-sized HDMI interface and place it on the back of the panel with the power interface Transfer 3.5mm audio interface to the back of the panel Support Raspberry Pi official fan temperature control function via raspi-config tool. Support system shutdown to safe cut off power on Raspberry Pi Support adjustable fan speed via PWM programming. Light weight heat-sink inside. Adjustable speed Fan","title":"Features"},{"location":"deskpilite/#gallery","text":"Features Easy to install Expansion of 2 USB Ports Fast Cooling GPIO Interface Protect Non-Slip Rubber feet","title":"Gallery"},{"location":"deskpilite/#port-definitions","text":"","title":"Port definitions"},{"location":"deskpilite/#package-includes","text":"1 x DeskPi Lite Case (Plastic) 1 x CNC alloy aluminum heat sink with PWM fan and GPIO expansion board 1 x Port adapter board 1 x Instructions 6 x Thermal Pads 2 x LED indicator lampshade 2 x M2.5 Screw","title":"Package includes"},{"location":"deskpilite/#working-principle","text":"RPi -> sending poweroff to /dev/ttyUSB0 means sending cut off power -> MCU on board: means MCU will cut of power of Raspberry Pi. RPi <- Reading poweroff from /dev/ttyUSB0 means shutdown system <- MCU on board: system will execute shutdown service or reboot (according to scripts definitions) when power button has been pressed twice.","title":"Working Principle"},{"location":"deskpilite/#how-to-enable-fan-temperature-control","text":"NOTE: Raspberry Pi OS (Latest) will support this function. Open a terminal and typing following command: sudo raspi-config Navigate to Performance Options -> P4 Fan -> Yes -> 14 -> 60 -> yes -> finish -> reboot Raspberry Pi. The fan is support PWM signal control via GPIO14 which is physical pin 12 (TXD), it will spinning when the CPU temperature is above 60 degree. and also you can write your code to control the fan via GPIO14 , sending PWM signal will trigger the fan spinning. This case hardware uses direct GPIO header connections for the included PWM capable fan. Like in your bigger DeskPi case software, you could easily change from a /dev/ttyUSB0 to a GPIO PWM fan control service. For anyone else wanting to implement some form of PWM fan control, please see the included python3 script code below. This will enable: < 40'c - Fan 75%, for a minimum of 60sec 40'c to 45'c - Fan 85%, for a minimum of 120sec > 45'c - Fan 100%, for a minimum of 180sec In everyday use, this script offers good temperatrue control, with the CPU temp rarely reaches > 45'c and general fan noise is very low and still keeps good control via the PWM fan vs standard Raspberry Pi OS PWM fan control via /boot/config.txt or raspi-config. #!/usr/bin/python3 import RPi.GPIO as GPIO import time import subprocess GPIO . setmode ( GPIO . BCM ) GPIO . setup ( 14 , GPIO . OUT ) pwm = GPIO . PWM ( 14 , 100 ) print ( \" \\n Press Ctrl+C to quit \\n \" ) dc = 0 pwm . start ( dc ) try : while True : temp = subprocess . getoutput ( \"vcgencmd measure_temp|sed 's/[^0-9.]//g'\" ) if round ( float ( temp )) >= 45 : dc = 100 pwm . ChangeDutyCycle ( dc ) print ( \"CPU Temp:\" , float ( temp ), \" Fan duty cycle:\" , dc ) time . sleep ( 180.0 ) if round ( float ( temp )) >= 40 : dc = 85 pwm . ChangeDutyCycle ( dc ) print ( \"CPU Temp:\" , float ( temp ), \" Fan duty cycle:\" , dc ) time . sleep ( 120.0 ) else : dc = 70 pwm . ChangeDutyCycle ( dc ) print ( \"CPU Temp:\" , float ( temp ), \" Fan duty cycle:\" , dc ) time . sleep ( 60.00 ) except KeyboardInterrupt : pwm . stop () GPIO . cleanup () print ( \"Ctrl + C pressed -- Ending program\" ) Then execute it: python3 fan_control.py","title":"How to enable fan temperature control?"},{"location":"deskpilite/#how-to-enable-the-usb20-in-front-of-panel","text":"Install DeskPi v1 driver. Add following parameter to /boot/config.txt file manually. dtoverlay = dwc2,dr_mode = host DO REMEMBER `reboot` Raspberry Pi to take effect.","title":"How to enable the USB2.0 in front of panel?"},{"location":"deskpilite/#how-to-send-power_off-signal-to-adapter-board-to-cut-off-power","text":"Make sure you have already add dtoverlay=dwc2,dr_mode=host to /boot/config.txt file and reboot Raspberry Pi. Check if there is a device called /dev/ttyUSB0 Execute the python demo script in deskpi_v1/drivers/python/safecutoffpower.py you may need to install pyserial library. Recommend: adding this function after shutdown service, so that it can safely cut off the power of Raspberry Pi.","title":"How to send power_off signal to adapter board to cut off power?"},{"location":"deskpilite/#how-to-reboot-by-double-click-power-buttom","text":"","title":"How to reboot by double click power buttom?"},{"location":"deskpilite/#principle","text":"when you double click the power button, The MCU on expansion board will send three times poweroffpoweroffpoweroff to serial port on raspberry Pi which generate via dwc2 dtoverlay, called /dev/ttyUSB0 , and you can capture it via python script and customized your own script to control the shutdown behavior. Demo code: Install pyserial library to control serial port. pip3 install pyserial Create a file named safe_shutdown.py and paste following code: import serial import time import os ser = serial.Serial('/dev/ttyUSB0', baudrate=9600, timeout=3) while True: if ser.isOpen(): data = ser.read(16) data = data.decode('utf-8') #print(data) if 'poweroff' in data: print(\"System will turn off in 3 seconds\") time.sleep(3) ser.write(b'power_off') ser.write(b'power_off') os.system('sudo sync && sudo init 0') 3. Execute it: python3 safe_shutdown.py You can also change the os.system(\"sudo reboot\") to reboot your Raspberry Pi.","title":"Principle"},{"location":"deskpilite/#github-repository","text":"deskpi_v1","title":"GitHub Repository"},{"location":"deskpinano/","text":"DeskPi Nano For Jetson Nano Description DeskPi Nano is a DeskPin style aluminum alloy shell kit. It is a customized shell for Jetson Nano B01 version. It also provides a GPIO expansion board and a TF card expansion board. In addition to protecting the Jetson Nano motherboard, the appearance is also very good. Pretty. NOTE: Jetson Nano dose not include in the package and it only fit for Jetson Nano B01 Version. Purchase DeskPi Nano Features Only for Jetson Nano B01 Version Ultra-thin PWM fan radiator Fixable TF Card Adapter Board GPIO Adapter Board Gallery Product Outlook Frontal face Back face Top side Power button and TF card slot 45 degree angle view Fan Details Dimention Heat Dissipation effect How to enable PWM Fan Turn on DeskPi Nano and open a terminal, typing following command: sudo jetson-clocks It will enable fan control via system detection and sending PWM signal to the fan. you will see the fan is spinning. Package Includes 1 x DeskPi Nano Case (Pack) How to assemble it YouTube Tutorial Video Keywords DeskPi Nano, Jetson Nano case, DeskPi","title":"DeskPi Nano"},{"location":"deskpinano/#deskpi-nano-for-jetson-nano","text":"","title":"DeskPi Nano For Jetson Nano"},{"location":"deskpinano/#description","text":"DeskPi Nano is a DeskPin style aluminum alloy shell kit. It is a customized shell for Jetson Nano B01 version. It also provides a GPIO expansion board and a TF card expansion board. In addition to protecting the Jetson Nano motherboard, the appearance is also very good. Pretty. NOTE: Jetson Nano dose not include in the package and it only fit for Jetson Nano B01 Version.","title":"Description"},{"location":"deskpinano/#purchase","text":"DeskPi Nano","title":"Purchase"},{"location":"deskpinano/#features","text":"Only for Jetson Nano B01 Version Ultra-thin PWM fan radiator Fixable TF Card Adapter Board GPIO Adapter Board","title":"Features"},{"location":"deskpinano/#gallery","text":"Product Outlook Frontal face Back face Top side Power button and TF card slot 45 degree angle view","title":"Gallery"},{"location":"deskpinano/#fan-details","text":"","title":"Fan Details"},{"location":"deskpinano/#dimention","text":"","title":"Dimention"},{"location":"deskpinano/#heat-dissipation-effect","text":"","title":"Heat Dissipation effect"},{"location":"deskpinano/#how-to-enable-pwm-fan","text":"Turn on DeskPi Nano and open a terminal, typing following command: sudo jetson-clocks It will enable fan control via system detection and sending PWM signal to the fan. you will see the fan is spinning.","title":"How to enable PWM Fan"},{"location":"deskpinano/#package-includes","text":"1 x DeskPi Nano Case (Pack)","title":"Package Includes"},{"location":"deskpinano/#how-to-assemble-it","text":"YouTube Tutorial Video","title":"How to assemble it"},{"location":"deskpinano/#keywords","text":"DeskPi Nano, Jetson Nano case, DeskPi","title":"Keywords"},{"location":"deskpipro/","text":"DeskPi Pro Description The DeskPi Pro is a hardware kit for converting a standard Raspberry Pi 4 from a naked SBC, with limited storage, into a mini PC complete with a power button, cooling, better ports and, via SATA then USB3, 2.5\" or M.2 SATA SSD storage. Note: Support M.2 SATA SSD only, Does not support M.2 NVME SSD Currently tested operating systems that can support Deskpi scripts Raspberry Pi OS(32bit) - tested RaspiOS (64bit) - tested Ubuntu-mate OS(32bit) - tested Ubuntu OS (64bit) - tested Manjaro OS (32bit) - tested Manjaro OS (64bit) - To be tested Kali-linux-arm OS (32bit) - tested Kali-linux-arm OS (64-Bit) - To be tested Twister OS v2.0.2 (32bit) - tested DietPi OS (64bit) - tested Volumio OS Version: 2021-04-24-Pi (32bit) - tested RetroPie OS (32bit) - tested Please Read this section carefully if you are using 64bit OS, The script to control the fan is in the drivers/c/ directory. The file suffix with 64 means 64bit , and the other one is a 32bit executable file. Before you install this script, please make sure your Raspberry Pi can access internet and can access github website. How to install it. For Raspbian and RetroPie OS. (32bit) cd ~ git clone https://github.com/DeskPi-Team/deskpi.git cd ~/deskpi/ chmod +x install.sh sudo ./install.sh For Ubuntu 64bit OS cd ~ git clone https://github.com/DeskPi-Team/deskpi.git cd ~/deskpi/ chmod +x install-ubuntu-64.sh sudo ./install-ubuntu-64.sh For Ubuntu-mate OS cd ~ git clone https://github.com/DeskPi-Team/deskpi.git cd ~/deskpi/ chmod +x install-ubuntu-mate.sh sudo ./install-ubuntu-mate.sh For Manjaro OS cd ~ git clone https://github.com/DeskPi-Team/deskpi.git cd ~/deskpi/ chmod +x install-manjaro.sh sudo ./install-manjaro.sh For Kali-linux-arm OS. Image Download URL: https://images.kali.org/arm-images/kali-linux-2020.3a-rpi3-nexmon.img.xz cd ~ git clone https://github.com/DeskPi-Team/deskpi.git cd ~/deskpi/ chmod +x install-kali.sh sudo ./install-kali.sh For Twister OS v2.0.2 OS image: TwisterOSv2-0-2.img * Image Download URL:https://twisteros.com/twisteros.html cd ~ git clone https://github.com/DeskPi-Team/deskpi.git cd ~/deskpi/ chmod +x install.sh sudo ./install.sh For 64 bit Raspberry Pi OS (aarm64) Image Download URL: http://downloads.raspberrypi.org/raspios_arm64/images/raspios_arm64-2021-05-28/ cd ~ git clone https://github.com/DeskPi-Team/deskpi.git cd ~/deskpi/ chmod +x install-raspios-64bit.sh sudo ./install-raspios-64bit.sh * Uninstall: cd ~/deskpi/ chmod +x install-raspios-64bit.sh sudo ./uninstall-raspios-64bit.sh For DietPi OS 64bit Make sure your OS can access internet and please install git first. Execute this command in terminal: apt-get update && apt-get -y install git Image Download URL: https://dietpi.com/downloads/images/DietPi_RPi-ARMv8-Bullseye.7z cd ~ git clone https://github.com/DeskPi-Team/deskpi.git cd ~/deskpi/ ./install.sh For Volumio OS Version: 2021-04-24-Pi Image Download URL: https://updates.volumio.org/pi/volumio/2.882/volumio-2.882-2021-04-24-pi.img.zip Getting Start:\u3000https://volumio.github.io/docs/User_Manual/Quick_Start_Guide.html Make sure your Volumio can access internet. There are some steps need to do. sudo nano /etc/network/interface make sure following parameters in file /etc/network/interface auto wlan0 allow-hotplug wlan0 iface wlan0 inet dhcp wpa-ssid \"YOUR WIFI SSID\" wpa-psk \"YOUR WIFI PASSWORD\" and enable the internet access by typing this command in terminal: volumio internet on and then reboot your DeskPi. sudo reboot Download DeskPi driver from github: git clone https://github.com/DeskPi-Team/deskpi.git cd deskpi/ sudo ./install.sh TEST it after rebooting. deskpi-config Select 4 and press Enter , you would see the fan is spinning and the front USB port are now available. How to Uninstall deskpi DeskPi-uninstall And then select the number against to your OS Type. For Windows IoT OS Unsupported due to lacking of driver. Testing version: Midnight falcon How to control fan speed mannualy. Open a terminal and typing following command: deskpi-config You can follow the instructions to setup fan speed level by typing numbers as following example: Selection explain The number from 1 to 4 is to setting your fan speed to a static level. Number 5 is just turn off the fan. Number 6 is to guide you to create a file located to /etc/deskpi.conf and you can specify the threshold of temperature and fan speed level according to your idea, once the file has been created, the program will according to the configuration file to setup your fan. Number 7 is to enable automatic fan control by default paramaters. ** Default arguments: TEMP : Fan_SPEED_LEVEL <40C : 0 % 40 ~50C : 25 % 50 ~65C : 50 % 65 ~75C : 75 % >75C : 100 % ** If you want to change it, just typing : deskpi-config Select 6 and then input 45 and enter, and then input 50 means setup the fan speed level to 50% when CPU temp is above 45 degree it has 4 level to setup. NOTE: 50% Speed level means you have already send PWM50 to /dev/ttyUSB0 port, and this port will available when you add dtoverlay=dwc2,dr_mode=host to /boot/config.txt file and reboot your DeskPi. How to boot from USB SSD/HDD? After initial Raspberry Pi Configuration and once you have Internet Connectivity established, Install the DeskPi Pro Utilities from https://github.com/DeskPi-Team/deskpi.git Open a Terminal / Console and run the following commands: sudo apt update sudo apt full-upgrade sudo rpi-update When complete, run: sudo reboot Upon reboot, open Terminal again: sudo raspi-config * go to Advanced Options * Select Boot Order, select #1 USB Boot , Return to Advanced Options, * Select Boot Loader Version, choose Latest Version * Save & exit Reboot again (to restart with new settings) sudo reboot After reboot, re-open Terminal again sudo -E rpi-eeprom-config --edit do not change anything, it is unnecessary press Ctrl-X to save, answer Y to overwrite file. sudo reboot Now you are ready to install Raspberry-OS onto your USB Boot Device. You can use the Raspberry Imager from www.raspberrypi.org website. Depending on device the new SD Card Copier can transfer the SD-Card image to the USB Device (ensure you select generate a new UUID). Once your USB drive is imaged & ready to boot, shutdown your Deskpi-Pro, remove the SD-Card and power-up to boot from the USB Boot drive, once running & configured you can install your additional software and proceed as usual. Tutorial Video On YouTube How to Use IR function onboard. You need to enable gpio-ir function by modify /boot/config.txt file. uncomment this line if not exsit please add it. dtoverlay = gpio-ir,gpio_pin = 17 Install lirc package: sudo apt-get install lirc Modify configuration file on location: /etc/lirc/lirc_options.conf and make sure it has following parameters: driver = default device = /dev/lirc0 Reboot your Raspberry Pi and test it with following command: mode2 -d /dev/lirc1 DeskPi Pro","title":"DeskPi Pro"},{"location":"deskpipro/#deskpi-pro","text":"","title":"DeskPi Pro"},{"location":"deskpipro/#description","text":"The DeskPi Pro is a hardware kit for converting a standard Raspberry Pi 4 from a naked SBC, with limited storage, into a mini PC complete with a power button, cooling, better ports and, via SATA then USB3, 2.5\" or M.2 SATA SSD storage. Note: Support M.2 SATA SSD only, Does not support M.2 NVME SSD","title":"Description"},{"location":"deskpipro/#currently-tested-operating-systems-that-can-support-deskpi-scripts","text":"Raspberry Pi OS(32bit) - tested RaspiOS (64bit) - tested Ubuntu-mate OS(32bit) - tested Ubuntu OS (64bit) - tested Manjaro OS (32bit) - tested Manjaro OS (64bit) - To be tested Kali-linux-arm OS (32bit) - tested Kali-linux-arm OS (64-Bit) - To be tested Twister OS v2.0.2 (32bit) - tested DietPi OS (64bit) - tested Volumio OS Version: 2021-04-24-Pi (32bit) - tested RetroPie OS (32bit) - tested","title":"Currently tested operating systems that can support Deskpi scripts"},{"location":"deskpipro/#please-read-this-section-carefully","text":"if you are using 64bit OS, The script to control the fan is in the drivers/c/ directory. The file suffix with 64 means 64bit , and the other one is a 32bit executable file. Before you install this script, please make sure your Raspberry Pi can access internet and can access github website.","title":"Please Read this section carefully"},{"location":"deskpipro/#how-to-install-it","text":"","title":"How to install it."},{"location":"deskpipro/#for-raspbian-and-retropie-os-32bit","text":"cd ~ git clone https://github.com/DeskPi-Team/deskpi.git cd ~/deskpi/ chmod +x install.sh sudo ./install.sh","title":"For Raspbian and RetroPie OS. (32bit)"},{"location":"deskpipro/#for-ubuntu-64bit-os","text":"cd ~ git clone https://github.com/DeskPi-Team/deskpi.git cd ~/deskpi/ chmod +x install-ubuntu-64.sh sudo ./install-ubuntu-64.sh","title":"For Ubuntu 64bit OS"},{"location":"deskpipro/#for-ubuntu-mate-os","text":"cd ~ git clone https://github.com/DeskPi-Team/deskpi.git cd ~/deskpi/ chmod +x install-ubuntu-mate.sh sudo ./install-ubuntu-mate.sh","title":"For Ubuntu-mate OS"},{"location":"deskpipro/#for-manjaro-os","text":"cd ~ git clone https://github.com/DeskPi-Team/deskpi.git cd ~/deskpi/ chmod +x install-manjaro.sh sudo ./install-manjaro.sh","title":"For Manjaro OS"},{"location":"deskpipro/#for-kali-linux-arm-os","text":"Image Download URL: https://images.kali.org/arm-images/kali-linux-2020.3a-rpi3-nexmon.img.xz cd ~ git clone https://github.com/DeskPi-Team/deskpi.git cd ~/deskpi/ chmod +x install-kali.sh sudo ./install-kali.sh","title":"For Kali-linux-arm OS."},{"location":"deskpipro/#for-twister-os-v202","text":"OS image: TwisterOSv2-0-2.img * Image Download URL:https://twisteros.com/twisteros.html cd ~ git clone https://github.com/DeskPi-Team/deskpi.git cd ~/deskpi/ chmod +x install.sh sudo ./install.sh","title":"For Twister OS v2.0.2"},{"location":"deskpipro/#for-64-bit-raspberry-pi-os-aarm64","text":"Image Download URL: http://downloads.raspberrypi.org/raspios_arm64/images/raspios_arm64-2021-05-28/ cd ~ git clone https://github.com/DeskPi-Team/deskpi.git cd ~/deskpi/ chmod +x install-raspios-64bit.sh sudo ./install-raspios-64bit.sh * Uninstall: cd ~/deskpi/ chmod +x install-raspios-64bit.sh sudo ./uninstall-raspios-64bit.sh","title":"For 64 bit Raspberry Pi OS (aarm64)"},{"location":"deskpipro/#for-dietpi-os-64bit","text":"Make sure your OS can access internet and please install git first. Execute this command in terminal: apt-get update && apt-get -y install git Image Download URL: https://dietpi.com/downloads/images/DietPi_RPi-ARMv8-Bullseye.7z cd ~ git clone https://github.com/DeskPi-Team/deskpi.git cd ~/deskpi/ ./install.sh","title":"For DietPi OS 64bit"},{"location":"deskpipro/#for-volumio-os-version-2021-04-24-pi","text":"Image Download URL: https://updates.volumio.org/pi/volumio/2.882/volumio-2.882-2021-04-24-pi.img.zip Getting Start:\u3000https://volumio.github.io/docs/User_Manual/Quick_Start_Guide.html Make sure your Volumio can access internet. There are some steps need to do. sudo nano /etc/network/interface make sure following parameters in file /etc/network/interface auto wlan0 allow-hotplug wlan0 iface wlan0 inet dhcp wpa-ssid \"YOUR WIFI SSID\" wpa-psk \"YOUR WIFI PASSWORD\" and enable the internet access by typing this command in terminal: volumio internet on and then reboot your DeskPi. sudo reboot Download DeskPi driver from github: git clone https://github.com/DeskPi-Team/deskpi.git cd deskpi/ sudo ./install.sh TEST it after rebooting. deskpi-config Select 4 and press Enter , you would see the fan is spinning and the front USB port are now available.","title":"For Volumio OS Version: 2021-04-24-Pi"},{"location":"deskpipro/#how-to-uninstall-deskpi","text":"DeskPi-uninstall And then select the number against to your OS Type.","title":"How to Uninstall deskpi"},{"location":"deskpipro/#for-windows-iot-os","text":"Unsupported due to lacking of driver. Testing version: Midnight falcon","title":"For Windows IoT OS"},{"location":"deskpipro/#how-to-control-fan-speed-mannualy","text":"Open a terminal and typing following command: deskpi-config You can follow the instructions to setup fan speed level by typing numbers as following example:","title":"How to control fan speed mannualy."},{"location":"deskpipro/#selection-explain","text":"The number from 1 to 4 is to setting your fan speed to a static level. Number 5 is just turn off the fan. Number 6 is to guide you to create a file located to /etc/deskpi.conf and you can specify the threshold of temperature and fan speed level according to your idea, once the file has been created, the program will according to the configuration file to setup your fan. Number 7 is to enable automatic fan control by default paramaters. ** Default arguments: TEMP : Fan_SPEED_LEVEL <40C : 0 % 40 ~50C : 25 % 50 ~65C : 50 % 65 ~75C : 75 % >75C : 100 % ** If you want to change it, just typing : deskpi-config Select 6 and then input 45 and enter, and then input 50 means setup the fan speed level to 50% when CPU temp is above 45 degree it has 4 level to setup. NOTE: 50% Speed level means you have already send PWM50 to /dev/ttyUSB0 port, and this port will available when you add dtoverlay=dwc2,dr_mode=host to /boot/config.txt file and reboot your DeskPi.","title":"Selection explain"},{"location":"deskpipro/#how-to-boot-from-usb-ssdhdd","text":"After initial Raspberry Pi Configuration and once you have Internet Connectivity established, Install the DeskPi Pro Utilities from https://github.com/DeskPi-Team/deskpi.git Open a Terminal / Console and run the following commands: sudo apt update sudo apt full-upgrade sudo rpi-update When complete, run: sudo reboot Upon reboot, open Terminal again: sudo raspi-config * go to Advanced Options * Select Boot Order, select #1 USB Boot , Return to Advanced Options, * Select Boot Loader Version, choose Latest Version * Save & exit","title":"How to boot from USB SSD/HDD?"},{"location":"deskpipro/#reboot-again-to-restart-with-new-settings","text":"sudo reboot After reboot, re-open Terminal again sudo -E rpi-eeprom-config --edit do not change anything, it is unnecessary press Ctrl-X to save, answer Y to overwrite file. sudo reboot Now you are ready to install Raspberry-OS onto your USB Boot Device. You can use the Raspberry Imager from www.raspberrypi.org website. Depending on device the new SD Card Copier can transfer the SD-Card image to the USB Device (ensure you select generate a new UUID). Once your USB drive is imaged & ready to boot, shutdown your Deskpi-Pro, remove the SD-Card and power-up to boot from the USB Boot drive, once running & configured you can install your additional software and proceed as usual. Tutorial Video On YouTube","title":"Reboot again (to restart with new settings)"},{"location":"deskpipro/#how-to-use-ir-function-onboard","text":"You need to enable gpio-ir function by modify /boot/config.txt file. uncomment this line if not exsit please add it. dtoverlay = gpio-ir,gpio_pin = 17 Install lirc package: sudo apt-get install lirc Modify configuration file on location: /etc/lirc/lirc_options.conf and make sure it has following parameters: driver = default device = /dev/lirc0 Reboot your Raspberry Pi and test it with following command: mode2 -d /dev/lirc1","title":"How to Use IR function onboard."},{"location":"deskpipro/#deskpi-pro_1","text":"","title":"DeskPi Pro"},{"location":"faq/","text":"FAQ List OS Issues What operating systems are currently tested on DeskPi Pro and works fine? Raspbian OS - 32bit version: 2020-08-12 Raspberry Pi OS . Ubuntu-mate OS - 32bit version:20.04.1-desktop--armhf+raspi Ubuntu mate 20.04 LTS 32Bit . Manjaro OS - 32bit verison: 20.2 Manjaro XFCE 20.2 Kali-linux-arm OS - 32bit version: 2020.4 Kali Linux RaspberryPi 2, 3, 4 and 400 . Dose it support 64bit OS such as Ubuntu 20.10? It depends on Raspberry Pi offical support, we suggest that you can refer to offical source here: Raspberry Pi OS . Front USB Issues Why the USB on the front panel of my DESKPI cannot be used? I have burned the system many times? Please check your /boot/config.txt file and make sure it contains dtoverlay=dwc2,dr_mode=host , and if you add it by yourself, it need to reboot Raspberry Pi to take effect. Disk drive Issues Why does my SSD hard drive not work normally after my Logitech wireless mouse and keyboard dongle is connected to DeskPi? Because the 2.4G frequency used by Logitech's mouse and keyboard interferes with DeskPi's USB transfer interface, it will cause the disk to work in an unstable state. This problem with Logitech's keyboard and mouse also occurs on desktop computers. The current solution is best to replace the wireless keyboard and mouse or use a wired keyboard and mouse. Why is it normal when I start the Raspberry Pi with a TF card, but the SATA SSD hard disk cannot appear on the desktop? The disk cannot be displayed on the desktop may be caused by the following reasons: Hardware connection - The hardware is not connected properly, such as forgetting to install the USB adapter. Not Initialized Before - The SATA SSD hard disk is a RAW Disk, the brand new one has not been partitioned, formatted, or mounted. Unavailable file system format - file sytem format not recognized by the Linux system is used, for example: NTFS Solution and diagnostic Reconnect SATA SSD to DeskPi Disk Adapter board Format partitions and mount disks manually - Following steps: 1. Open a terminal or press \"Ctrl+Alt+T\". 2. Typing: \"sudo fdisk -l\" to check if the disk has been recognized or typing: \"sudo lsusb -t\", typing: \"dmesg |grep -i usb\" to make sure disk has been connected. 3. If the disk can be found by those commands, manually format and mount the partition: for example: 3.1 `sudo fdisk /dev/sda` - sda means my first SCSI type disk which recognized by my system. 3.2 `p` - typing `p` means print current partions that contains on the disk. 3.3 `n` - new partion -> `p` - primary partion -> `1` -> partion number -> `Enter`-> first celinder -> `Enter` last celinder -> make the whole disk as a partion -> `w` - write the partion table to disk and quit. 3.4 `sudo partprobe /dev/sda` - make it recognized by linux kernel. 3.5 `mkdir /home/pi/mydata` - create mounting directory. 3.6 `sudo mkfs.ext4 /dev/sda1` - format partion `/dev/sda1` to `ext4` type which support `journal` on data saving. 3.7 `sudo mount -t ext4 /dev/sda1 /home/pi/mydata` - mount the partion to mount point so that we can access it. 3.8 `sudo chmod -R 777 /home/pi/mydata` - Set premission to the folder so that we can write and read date to disk. 4. How To Automount File Systems on Raspbian(Linux) 4.1 `sudo blkid` - Get the Name, In the output of this command, the first column is the name of your drives. The second column is the label of the drive (if you set a label for it) and the third column is the UUID of your drives. First you need to know the name of the drive that is going to be automatically mounted. 4.2 `sudo nano /etc/fstab` - [Dangerous] If the operation fails, the system will not start, add your partion information and let it auto mount after rebooting, We need to append one line of code at the end of the file. The format of this line of code is as follows: `UUID=<uuid-of-your-drive> <mount-point> <file-system-type> <mount-option> <dump> <pass>` * Note that you need to separate these items with `Tab key`. For example, I added the following line to the end of /etc/fstab. `UUID=eb67c479-962f-4bcc-b3fe-cefaf908f01e /home/pi/mydata ext4 defaults 0 2` Save and close the file. Then run the following command to see if it works. * `sudo mount -a` - Test automount. * `df -Th` - Check if there is a partion has been mounted on /home/pi/mydata. Some Explanations The defaults mount option will give users read and write access to the file system. The value of dump field is usually zero. The pass field is used by the fsck program to determine the order in which filesystem checks are done at reboot time. As you can see in this file, the value of the pass field for the root file system is 1. Swap partitions do not need to be checked and the value for them is zero. All other file systems should have a value of 2. So I set the pass value as 2 for my drive. HDMI issue My screen goes to black when I was booting up my deskpi. Please try to shift HDMI cable from HDMI0 to HDMI1 which is beside 3.5mm audio jack and try again. USB booting Why does it take so much time when I boot it from USB booting? It seems to be some tough question, some issues may caused by the usb controller chip performance issue.","title":"FAQ"},{"location":"faq/#faq-list","text":"","title":"FAQ List"},{"location":"faq/#os-issues","text":"","title":"OS Issues"},{"location":"faq/#what-operating-systems-are-currently-tested-on-deskpi-pro-and-works-fine","text":"Raspbian OS - 32bit version: 2020-08-12 Raspberry Pi OS . Ubuntu-mate OS - 32bit version:20.04.1-desktop--armhf+raspi Ubuntu mate 20.04 LTS 32Bit . Manjaro OS - 32bit verison: 20.2 Manjaro XFCE 20.2 Kali-linux-arm OS - 32bit version: 2020.4 Kali Linux RaspberryPi 2, 3, 4 and 400 .","title":"What operating systems are currently tested on DeskPi Pro and works fine?"},{"location":"faq/#dose-it-support-64bit-os-such-as-ubuntu-2010","text":"It depends on Raspberry Pi offical support, we suggest that you can refer to offical source here: Raspberry Pi OS .","title":"Dose it support 64bit OS such as Ubuntu 20.10?"},{"location":"faq/#front-usb-issues","text":"","title":"Front USB Issues"},{"location":"faq/#why-the-usb-on-the-front-panel-of-my-deskpi-cannot-be-used-i-have-burned-the-system-many-times","text":"Please check your /boot/config.txt file and make sure it contains dtoverlay=dwc2,dr_mode=host , and if you add it by yourself, it need to reboot Raspberry Pi to take effect.","title":"Why the USB on the front panel of my DESKPI cannot be used? I have burned the system many times?"},{"location":"faq/#disk-drive-issues","text":"","title":"Disk drive Issues"},{"location":"faq/#why-does-my-ssd-hard-drive-not-work-normally-after-my-logitech-wireless-mouse-and-keyboard-dongle-is-connected-to-deskpi","text":"Because the 2.4G frequency used by Logitech's mouse and keyboard interferes with DeskPi's USB transfer interface, it will cause the disk to work in an unstable state. This problem with Logitech's keyboard and mouse also occurs on desktop computers. The current solution is best to replace the wireless keyboard and mouse or use a wired keyboard and mouse.","title":"Why does my SSD hard drive not work normally after my Logitech wireless mouse and keyboard dongle is connected to DeskPi?"},{"location":"faq/#why-is-it-normal-when-i-start-the-raspberry-pi-with-a-tf-card-but-the-sata-ssd-hard-disk-cannot-appear-on-the-desktop","text":"The disk cannot be displayed on the desktop may be caused by the following reasons: Hardware connection - The hardware is not connected properly, such as forgetting to install the USB adapter. Not Initialized Before - The SATA SSD hard disk is a RAW Disk, the brand new one has not been partitioned, formatted, or mounted. Unavailable file system format - file sytem format not recognized by the Linux system is used, for example: NTFS","title":"Why is it normal when I start the Raspberry Pi with a TF card, but the SATA SSD hard disk cannot appear on the desktop?"},{"location":"faq/#solution-and-diagnostic","text":"Reconnect SATA SSD to DeskPi Disk Adapter board Format partitions and mount disks manually - Following steps: 1. Open a terminal or press \"Ctrl+Alt+T\". 2. Typing: \"sudo fdisk -l\" to check if the disk has been recognized or typing: \"sudo lsusb -t\", typing: \"dmesg |grep -i usb\" to make sure disk has been connected. 3. If the disk can be found by those commands, manually format and mount the partition: for example: 3.1 `sudo fdisk /dev/sda` - sda means my first SCSI type disk which recognized by my system. 3.2 `p` - typing `p` means print current partions that contains on the disk. 3.3 `n` - new partion -> `p` - primary partion -> `1` -> partion number -> `Enter`-> first celinder -> `Enter` last celinder -> make the whole disk as a partion -> `w` - write the partion table to disk and quit. 3.4 `sudo partprobe /dev/sda` - make it recognized by linux kernel. 3.5 `mkdir /home/pi/mydata` - create mounting directory. 3.6 `sudo mkfs.ext4 /dev/sda1` - format partion `/dev/sda1` to `ext4` type which support `journal` on data saving. 3.7 `sudo mount -t ext4 /dev/sda1 /home/pi/mydata` - mount the partion to mount point so that we can access it. 3.8 `sudo chmod -R 777 /home/pi/mydata` - Set premission to the folder so that we can write and read date to disk. 4. How To Automount File Systems on Raspbian(Linux) 4.1 `sudo blkid` - Get the Name, In the output of this command, the first column is the name of your drives. The second column is the label of the drive (if you set a label for it) and the third column is the UUID of your drives. First you need to know the name of the drive that is going to be automatically mounted. 4.2 `sudo nano /etc/fstab` - [Dangerous] If the operation fails, the system will not start, add your partion information and let it auto mount after rebooting, We need to append one line of code at the end of the file. The format of this line of code is as follows: `UUID=<uuid-of-your-drive> <mount-point> <file-system-type> <mount-option> <dump> <pass>` * Note that you need to separate these items with `Tab key`. For example, I added the following line to the end of /etc/fstab. `UUID=eb67c479-962f-4bcc-b3fe-cefaf908f01e /home/pi/mydata ext4 defaults 0 2` Save and close the file. Then run the following command to see if it works. * `sudo mount -a` - Test automount. * `df -Th` - Check if there is a partion has been mounted on /home/pi/mydata.","title":"Solution and diagnostic"},{"location":"faq/#some-explanations","text":"The defaults mount option will give users read and write access to the file system. The value of dump field is usually zero. The pass field is used by the fsck program to determine the order in which filesystem checks are done at reboot time. As you can see in this file, the value of the pass field for the root file system is 1. Swap partitions do not need to be checked and the value for them is zero. All other file systems should have a value of 2. So I set the pass value as 2 for my drive.","title":"Some Explanations"},{"location":"faq/#hdmi-issue","text":"","title":"HDMI issue"},{"location":"faq/#my-screen-goes-to-black-when-i-was-booting-up-my-deskpi","text":"Please try to shift HDMI cable from HDMI0 to HDMI1 which is beside 3.5mm audio jack and try again.","title":"My screen goes to black when I was booting up my deskpi."},{"location":"faq/#usb-booting","text":"","title":"USB booting"},{"location":"faq/#why-does-it-take-so-much-time-when-i-boot-it-from-usb-booting","text":"It seems to be some tough question, some issues may caused by the usb controller chip performance issue.","title":"Why does it take so much time when I boot it from USB booting?"},{"location":"frontUSB/","text":"Getting Start . For order please visit: DeskPi.com . How to check front USB port First, you need to check if /boot/config.txt file contains this parameter: dtoverlay = dwc2,dr_mode = host The front USB function is coming from dwc2 overlay, it selects the dwc2 USB controller driver, and dr_mode can be host , peripheral or otg . here, dwc2 mode must be host . And if you want to add it without editing /boot/config.txt file manually, just typing this command in a terminal: sudo sed -i '$a\\dtoverlay=dwc2,dr_mode=host' /boot/config.txt","title":"How to check front USB port"},{"location":"frontUSB/#getting-start","text":". For order please visit: DeskPi.com .","title":"Getting Start"},{"location":"frontUSB/#how-to-check-front-usb-port","text":"First, you need to check if /boot/config.txt file contains this parameter: dtoverlay = dwc2,dr_mode = host The front USB function is coming from dwc2 overlay, it selects the dwc2 USB controller driver, and dr_mode can be host , peripheral or otg . here, dwc2 mode must be host . And if you want to add it without editing /boot/config.txt file manually, just typing this command in a terminal: sudo sed -i '$a\\dtoverlay=dwc2,dr_mode=host' /boot/config.txt","title":"How to check front USB port"},{"location":"hdmicheck/","text":"Getting Start . For order please visit: DeskPi.com . How to check HDMI configuration Some people give us a feedback said there is a black screen when booting up Raspberry pi in a deskPi case, it may caused by several reasons. Solution 1 You can solve this problem by according steps: Modify /boot/config.txt file and adding this: hdmi_force_hotplug = 1 hdmi_group = 2 config_hdmi_boost = 4 Save it and reboot Raspberry Pi. sudo sync sudo reboot Solution 2 Unplug HDMI cable and shift it to HDMI1 which is near by 3.5mm audio jack. Solution 3 Change Resolution on desktop by click raspberry icon and select the app according to following picture. Navigate to Screen Configuration Navigate to configure -> Screens -> HDMI-1 or HDMI-2 -> Resolution -> Select whatever your Screens Resolution is. Apply the change.","title":"How to check HDMI configuration"},{"location":"hdmicheck/#getting-start","text":". For order please visit: DeskPi.com .","title":"Getting Start"},{"location":"hdmicheck/#how-to-check-hdmi-configuration","text":"Some people give us a feedback said there is a black screen when booting up Raspberry pi in a deskPi case, it may caused by several reasons.","title":"How to check HDMI configuration"},{"location":"hdmicheck/#solution-1","text":"You can solve this problem by according steps: Modify /boot/config.txt file and adding this: hdmi_force_hotplug = 1 hdmi_group = 2 config_hdmi_boost = 4 Save it and reboot Raspberry Pi. sudo sync sudo reboot","title":"Solution 1"},{"location":"hdmicheck/#solution-2","text":"Unplug HDMI cable and shift it to HDMI1 which is near by 3.5mm audio jack.","title":"Solution 2"},{"location":"hdmicheck/#solution-3","text":"Change Resolution on desktop by click raspberry icon and select the app according to following picture. Navigate to Screen Configuration Navigate to configure -> Screens -> HDMI-1 or HDMI-2 -> Resolution -> Select whatever your Screens Resolution is. Apply the change.","title":"Solution 3"},{"location":"install/","text":"Getting Start . For order please visit: DeskPi.com . How to Install Deskpi driver Flash the latest version of supported OS to your TF(microSD) card with etcher flash imaging tool Insert TF(MicroSD) card to DeskPi card slot and connect the power supply(which come with the package.) Connect DeskPi to internet. (You need to configure WLAN country in order to enable Wi-Fi adapter) Open a terminal by press icon on the task bar or just press \"Ctrl+alt+T. Typing those command to install the driver automatically.(Raspberry Pi will reboot after installing.) For Raspbian and RetroPie OS. cd ~ git clone https://github.com/DeskPi-Team/deskpi.git cd ~/deskpi/ chmod +x install.sh sudo ./install.sh For Ubuntu-mate OS cd ~ git clone https://github.com/DeskPi-Team/deskpi.git cd ~/deskpi/ chmod +x install-ubuntu-mate.sh sudo ./install-ubuntu-mate.sh For Manjaro OS cd ~ git clone https://github.com/DeskPi-Team/deskpi.git cd ~/deskpi/ chmod +x install-manjaro.sh sudo ./install-manjaro.sh For Kali-linux-arm OS. Image Download URL: https://images.kali.org/arm-images/kali-linux-2020.3a-rpi3-nexmon.img.xz cd ~ git clone https://github.com/DeskPi-Team/deskpi.git cd ~/deskpi/ chmod +x install-kali.sh sudo ./install-kali.sh","title":"Install"},{"location":"install/#getting-start","text":". For order please visit: DeskPi.com .","title":"Getting Start"},{"location":"install/#how-to-install-deskpi-driver","text":"Flash the latest version of supported OS to your TF(microSD) card with etcher flash imaging tool Insert TF(MicroSD) card to DeskPi card slot and connect the power supply(which come with the package.) Connect DeskPi to internet. (You need to configure WLAN country in order to enable Wi-Fi adapter) Open a terminal by press icon on the task bar or just press \"Ctrl+alt+T. Typing those command to install the driver automatically.(Raspberry Pi will reboot after installing.)","title":"How to Install Deskpi driver"},{"location":"install/#for-raspbian-and-retropie-os","text":"cd ~ git clone https://github.com/DeskPi-Team/deskpi.git cd ~/deskpi/ chmod +x install.sh sudo ./install.sh","title":"For Raspbian and RetroPie OS."},{"location":"install/#for-ubuntu-mate-os","text":"cd ~ git clone https://github.com/DeskPi-Team/deskpi.git cd ~/deskpi/ chmod +x install-ubuntu-mate.sh sudo ./install-ubuntu-mate.sh","title":"For Ubuntu-mate OS"},{"location":"install/#for-manjaro-os","text":"cd ~ git clone https://github.com/DeskPi-Team/deskpi.git cd ~/deskpi/ chmod +x install-manjaro.sh sudo ./install-manjaro.sh","title":"For Manjaro OS"},{"location":"install/#for-kali-linux-arm-os","text":"Image Download URL: https://images.kali.org/arm-images/kali-linux-2020.3a-rpi3-nexmon.img.xz cd ~ git clone https://github.com/DeskPi-Team/deskpi.git cd ~/deskpi/ chmod +x install-kali.sh sudo ./install-kali.sh","title":"For Kali-linux-arm OS."},{"location":"ipcheck/","text":"Getting Start . For order please visit: DeskPi.com . How to check wifi connection status Open a terminal and typing: ifconfig -a Wi-Fi adapter is called wlan0 How to check wifi signal level? sudo apt update sudo apt -y install wavemon sudo wavemon -i wlan0 Check if Raspberry Pi can connect to Internet ping -c 4 wwww.apache.org Check if DNS configuration is correctly. cat /etc/resolv.conf make sure the nameserver is available, if not, please contact to your ISP (Internet Service Provider).","title":"How to check wifi connection"},{"location":"ipcheck/#getting-start","text":". For order please visit: DeskPi.com .","title":"Getting Start"},{"location":"ipcheck/#how-to-check-wifi-connection-status","text":"Open a terminal and typing: ifconfig -a Wi-Fi adapter is called wlan0","title":"How to check wifi connection status"},{"location":"ipcheck/#how-to-check-wifi-signal-level","text":"sudo apt update sudo apt -y install wavemon sudo wavemon -i wlan0 Check if Raspberry Pi can connect to Internet ping -c 4 wwww.apache.org Check if DNS configuration is correctly. cat /etc/resolv.conf make sure the nameserver is available, if not, please contact to your ISP (Internet Service Provider).","title":"How to check wifi signal level?"},{"location":"ir/","text":"Getting Start . For order please visit: DeskPi.com . How to Use IR function onboard. You need to enable gpio-ir function by modify /boot/config.txt file. uncomment this line if not exsit please add it. dtoverlay = gpio-ir,gpio_pin = 17 Install lirc package: sudo apt-get install lirc Modify configuration file on location: /etc/lirc/lirc_options.conf and make sure it has following parameters: driver = default device = /dev/lirc0 Reboot your Raspberry Pi and test it with following command: mode2 -d /dev/lirc1","title":"Ir"},{"location":"ir/#getting-start","text":". For order please visit: DeskPi.com .","title":"Getting Start"},{"location":"ir/#how-to-use-ir-function-onboard","text":"You need to enable gpio-ir function by modify /boot/config.txt file. uncomment this line if not exsit please add it. dtoverlay = gpio-ir,gpio_pin = 17 Install lirc package: sudo apt-get install lirc Modify configuration file on location: /etc/lirc/lirc_options.conf and make sure it has following parameters: driver = default device = /dev/lirc0 Reboot your Raspberry Pi and test it with following command: mode2 -d /dev/lirc1","title":"How to Use IR function onboard."},{"location":"ircheck/","text":"Getting Start . For order please visit: DeskPi.com . How to check IR remote Enable gpio-ir function by editing /boot/config.txt file. dtoverlay = gpio-ir,gpio_pin = 17 Install lirc software. sudo apt-get -y install lirc Modify configuration file /etc/lirc/lirc_options.conf and make sure it contains those two parameters: driver = default device = /dev/lirc0 Save it and reboot Raspberry Pi. sudo sync sudo reboot Test it by: mode2 -d /dev/lirc1 NOTE Please aim your IR remote controller direct to the power button. and different IR remote controller may have different response time.","title":"How to check IR remote"},{"location":"ircheck/#getting-start","text":". For order please visit: DeskPi.com .","title":"Getting Start"},{"location":"ircheck/#how-to-check-ir-remote","text":"Enable gpio-ir function by editing /boot/config.txt file. dtoverlay = gpio-ir,gpio_pin = 17 Install lirc software. sudo apt-get -y install lirc Modify configuration file /etc/lirc/lirc_options.conf and make sure it contains those two parameters: driver = default device = /dev/lirc0 Save it and reboot Raspberry Pi. sudo sync sudo reboot Test it by: mode2 -d /dev/lirc1 NOTE Please aim your IR remote controller direct to the power button. and different IR remote controller may have different response time.","title":"How to check IR remote"},{"location":"osversion/","text":"Getting Start . For order please visit: DeskPi.com . How to check OS Version Open a terminal and typing: lsb_release -a Check the kernel version: uname -a","title":"How to check OS version"},{"location":"osversion/#getting-start","text":". For order please visit: DeskPi.com .","title":"Getting Start"},{"location":"osversion/#how-to-check-os-version","text":"Open a terminal and typing: lsb_release -a Check the kernel version: uname -a","title":"How to check OS Version"},{"location":"picomate/","text":"DeskPi PicoMate User Manual Description DeskPi PicoMate is an all-in-one and versatile prototyping kit designed for Raspberry Pi Pico and Pico W. It includes one expansion dock for Raspberry Pi Pico and Pico W, 12 detachable modules and all in one- piece of PCB design. All modules are pre-wired to the Pico Dock, no soldering and wiring required and out-of-box. Of course, you can also detach the modules and connect them using the cables included in the box. Buy DeskPi PicoMate Visit DeskPi Official Website Features Designed for Raspberry Pi Pico and Pico W All modules are pre-wired, no soldering and wiring required and out-of-box 12 detachable and easy-to-use modules: Push Button WS2812 RGB LED Rotary Encoder Buzzer Digital Microphone (ZTS6531S) Digital PIR Sensor (AS312) 6-Axis IMU Sensor (LSM6DS3TR-C) Digital Optical Sensor (LTR-381RGB-01) 3-Axis Magnetometer (MMC5603NJ) Temperature & Humidity Sensor (SHT30-DIS) 0.96\u201d 128x64 OLED Display (SSD1315) 204 Pins Breakout Board All Pico GPIOs available via headers and up to 11 Grove connectors available Built-in battery connector for on-the-go projects MicroPython libraries support for all modules 3.3V IO operating voltage Package Includes 1x DeskPi PicoMate 1x Raspberry Pi Pico with pre-soldered pin headers 1x 3*AA Battery Holder with On/Off Switch 6x Grove Cable 1x Micro USB Cable Pinout Diagram Getting Start Getting Started with Python The DeskPi PicoMate can be programmed using the popular Python programming language. Raspberry Pi Pico is supported by CircuitPython, which is based on MicroPython, and features unified Python core APIs and a growing list of device libraries and drivers that work with it. This section describes how to set up CircuitPython on DeskPi PicoMate. Examples are also provided to help you to get started in a very short time Installing CircuitPython Download the official CircuiPython for Raspberry Pi Pico . Choose the latest stable release and then download the .uf2 file. Then go ahead and: Push and hold the BOOTSEL button and plug your Pico into the USB port of your computer. Release the BOOTSEL button after your Pico is connected. It will mount as a Mass Storage Device called RPI-RP2 . Drag and drop the CircuitPython UF2 file onto the RPI-RP2 volume. Your Pico will reboot. A new drive named CIRCUITPY should appear. Installing Mu Editor Mu Editor is a simple Python code editor for beginner programmers. Go to Mu Editor Download page , choose your Operational System and follow the instructions. MU Editor Once the Mu Editor is installed, open it, go to Mode menu, select CircuitPython and press OK . In the text editor, try some Python code: print ( 'Hello, DeskPi PicoMate!' ) Select Save on Top Menu. A window will appear. Give the name code.py for your code and save it on the CIRCUITPY drive. Your code will run as soon as the file is done saving. The Serial button opens a serial data connection to the Pico. This will result in a new panel between the text editor and Mu s footer, which prints the data from the Pico. If you need to drop into the CircuitPython REPL you should make sure the panel has keyboard focus (just click it!) and then type CTRL+ C . Now that you have the Python prerequisites installed, it is time to explore more examples for the DeskPi PicoMate. Python Examples This section consists of several example codes. The examples are organized in different levels of codes to demonstrate the Python API usage. Blink RGB LED DeskPi PicoMate has a WS2812 RGB LED pre-wired to GP22 on the Pico. We can use the NeoPixel library to blink the RGB LED. Download the NeoPixel library and copy neopixel.py into the CIRCUITPY/lib folder.This should give you the following folder structure: Copy and paste the following code to the Mu Editor and press Save : import time import board import neopixel R = ( 50 , 0 , 0 ) G = ( 0 , 50 , 0 ) B = ( 0 , 0 , 50 ) COLORS = ( R , G , B ) pixels = neopixel . NeoPixel ( board . GP22 , 1 ) while True : for color in COLORS : pixels [ 0 ] = COLORS time . sleep ( 1 ) Your code will run as soon as the file is done saving. Observe that the RGB LED starts to blink. For more details about the Neopixel API reference, please check out Read the Docs Button DeskPi PicoMate has a Push Button pre-wired to GP26 on the Pico. The example prints a message to the console each time the state of the button changes. When the button is pressed, the input level of GP26 will be low (False) level. Copy and paste the following code to the Mu Editor and press Save : import board import digitalio # Button button = digitalio . DigitalInOut ( board . GP26 ) button . direction = digitalio . Direction . INPUT button . pull = digitalio . Pull . UP last_value = button . value while True : if last_value != button . value : last_value = button . value print ( 'Button is ' + ( 'released' if button . value else 'pressed' )) Press the button and observe the Serial Console, you will see the message printed each time the state of the button changes: Rotary Encoder DeskPi PicoMate has an incremental rotary encoder pre-wired to the Pico, which converts the motion of the switch (clockwise or counterclockwise) into an output signal that can be used to determine what direction the knob is being rotated. The table below shows the connections of each pin of the rotary encoder: Rotary Encoder Pin On Pico A GP7 B GP6 Swith(Optional, Active High Level) GP26 Copy and paste the following code to the Mu Editor and press Save : import rotaryio import board import digitalio encoder = rotaryio . IncrementalEncoder ( board . GP7 , board . GP6 ) switch = digitalio . DigitalInOut ( board . GP26 ) switch . direction = digitalio . Direction . INPUT switch . pull = digitalio . Pull . DOWN last_position = encoder . position switch_state = switch . value while True : position = encoder . position if last_position is None or position != last_position : print ( f \"Rotary: { position } \" ) last_position = position if switch_state != switch . value : switch_state = switch . value print ( 'Switch is ' + ( 'ON' if switch . value else 'OFF' )) Now, open the Serial Console, then try rotating the knob slowly clockwise or counterclockwise, and try pressing down on the knob. Buzzer DeskPi PicoMate has a buzzer pre-wired to GP27 on the Pico. To control the buzzer from CircuitPython we will use its built in PWM, or pulse-width modulation, signal generation capabilities. Copy and paste the following code to the Mu Editor and press Save: import time import board import pwmio # Define a list of tones/music notes to play. TONE_FREQ = [ 1047 , 1047 , 1568 , 1568 , 1760 , 1760 , 1568 , 0 , 1397 , 1397 , 1319 , 1319 , 1175 , 1175 , 1047 , 0 , 1568 , 1568 , 1397 , 1397 , 1319 , 1319 , 1175 , 0 , 1568 , 1568 , 1397 , 1397 , 1319 , 1319 , 1175 , 0 , 1047 , 1047 , 1568 , 1568 , 1760 , 1760 , 1568 , 0 , 1397 , 1397 , 1319 , 1319 , 1175 , 1175 , 1047 , 0 , ] # Buzzer buzzer = pwmio . PWMOut ( board . GP27 , variable_frequency = True ) buzzer . frequency = TONE_FREQ [ 0 ] buzzer . duty_cycle = 32768 while True : for note in TONE_FREQ : if note : buzzer . frequency = notes time . sleep ( 0.1 ) The music playback will immediately start as soon as the code is done saving. 0.96\u201d 128x64 OLED Display DeskPi PicoMate has a 0.96\" 128x64 OLED Display module, which is pre-wired to the Pico using I2C0 with the device address 0x3C . The table below shows the connections of each pin of the OLED: 0.96\" 128x64 OLED Pin On Pico SCL GP17/I2C0_SCL SDA GP16/I2C0_SDA Before we can use the display module, we need the following modules installed: - adafruit_register - adafruit_framebuf - adafruit_ssd1306 Copy the libraries into the CIRCUITPY/lib folder. This should give you the following folder structure: Then, copy and paste the following code to the Mu Editor and press Save : import time import board import busio from adafruit_ssd1306 import SSD1306_I2C i2c0 = busio . I2C ( scl = board . GP17 , sda = board . GP16 ) # 0.96\" 128x64 OLED Display display = SSD1306_I2C ( 128 , 64 , i2c0 ) def display_text ( str , line ): display . text ( str , 0 , ( line % 8 ) * 8 , 1 , font_name = \"/lib/font5x8.bin\" ) while True : display . fill ( 0 ) display_text ( \"Hello, World!\" , 0 ) display_text ( \"It's DeskPi PicoMate!\" , 2 ) display . show () time . sleep ( 0.5 ) Try to change the display text and observe what is printed on the OLED. PDM Microphone DeskPi PicoMate has a high quality, low power PDM digital output top-ported omni-directional MEMS microphone. The PDM microphone is pre-wired to the Pico. The table below shows the connections of each pin of the PDM microphone: PDM Microphone Pin On Pico CLK GP9 DATA GP8 As PDMIn is built into CircuitPython, no separate libraries are necessary for this example! Copy and paste the following code to the Mu Editor and press Save : import time import array import math import board import audiobusio # Remove DC bias before computing RMS. def mean ( values ): return sum ( values ) / len ( values ) # Calculate the Normalized RMS value of samples def normalized_rms ( values ): minbuf = int ( mean ( values )) samples_sum = sum ( float ( sample - minbuf ) * ( sample - minbuf ) for sample in values ) return math . sqrt ( samples_sum / len ( values )) # PDM Microphone mic = audiobusio . PDMIn ( board . GP9 , board . GP8 , sample_rate = 16000 , bit_depth = 16 ) samples = array . array ( 'H' , [ 0 ] * 160 ) while True : mic . record ( samples , len ( samples )) magnitude = normalized_rms ( samples ) print (( magnitude ,)) time . sleep ( 0.1 ) On Serial Console, you will see the Normalized RMS value of the audio captured by the Microphone. Try to make some sound. You will see the magnitude changes. You can also use the plotter for data inspection. Press the Plotter button on the top menu. Digital PIR Sensor DeskPi PicoMate has a Digital PIR sensor pre-wired to GP28 on the Pico. The Digital PIR sensor allows you to sense motion, almost used to detect whether a human has moved in or out of the sensors range. The Digital PIR sensor acts as a digital output. When the sensor is triggered, the input level of GP28 will be High (True) Level. Copy and paste the following code to the Mu Editor and press Save : import board import digitalio # PIR sensor pir_sensor = digitalio . DigitalInOut ( board . GP28 ) pir_sensor . direction = digitalio . Direction . INPUT pir_sensor . pull = digitalio . Pull . DOWN last_value = pir_sensor . value while True : if last_value != pir_sensor . value : last_value = pir_sensor . value print ( 'Motion ' + ( 'detected!' if pir_sensor . value else 'removed!' )) Try moving your body and see messages printed on the Serial Console. 6-Axis IMU Sensor DeskPi PicoMate has a 6-Axis IMU sensor (LSM6DS3TR-C) featuring a 3D digital accelerometer and a 3D digital gyroscope. The sensor is pre-wired to the Pico using I2C1 with the device address 0x6A . The table below shows the connections of each pin of the sensor: 6-Axis IMU sensor Pin On Pico SCL GP15/I2C1_SCL SDA GP14/I2C1_SDA Before we can use the sensor, we need the following modules installed: - adafruit_register - adafruit_lsm6ds Copy the libraries into the CIRCUITPY/lib folder. This should give you the following folder structure: CIRCUITPY/ \u251c\u2500\u2500 boot_out.txt \u251c\u2500\u2500 code.py \u2514\u2500\u2500 lib \u251c\u2500\u2500 adafruit_lsm6ds \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 ism330dhcx.py \u2502 \u251c\u2500\u2500 lsm6ds3.py \u2502 \u251c\u2500\u2500 lsm6ds33.py \u2502 \u251c\u2500\u2500 lsm6ds3trc.py \u2502 \u251c\u2500\u2500 lsm6dso32.py \u2502 \u2514\u2500\u2500 lsm6dsox.py \u2514\u2500\u2500 adafruit_register \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 i2c_bcd_alarm.py \u251c\u2500\u2500 i2c_bcd_datetime.py \u251c\u2500\u2500 i2c_bit.py \u251c\u2500\u2500 i2c_bits.py \u251c\u2500\u2500 i2c_struct.py \u2514\u2500\u2500 i2c_struct_array.py Then, copy and paste the following code to the Mu Editor and press Save : import time import board import busio from adafruit_lsm6ds.lsm6ds3trc import LSM6DS3TRC i2c1 = busio . I2C ( scl = board . GP15 , sda = board . GP14 ) # 6-Axis IMU Sensor imu_sensor = LSM6DS3TRC ( i2c1 ) # Acceleration plotter while True : print ( imu_sensor . acceleration ) time . sleep ( 0.1 ) # Gyro plotter # while True: # print(imu_sensor.gyro) # time.sleep(0.1) Press the Plotter button on the top menu, and try moving your board and see the changes in plotter. 3-Axis Magnetometer DeskPi PicoMate has a 3-Axis Magnetometer (MMC5603NJ) that can measure magnetic fields surrounding the device. The sensor is pre-wired to the Pico using I2C1 with the device address 0x30 . The table below shows the connections of each pin of the sensor: 3-Axis Magnetometer Pin On Pico SCL GP15/I2C1_SCL SDA GP14/I2C1_SDA Before we can use the sensor, we need the following modules installed: - adafruit_register - adafruit_mmc56x3 Copy the libraries into the CIRCUITPY/lib folder. This should give you the following folder structure: CIRCUITPY/ \u251c\u2500\u2500 boot_out.txt \u251c\u2500\u2500 code.py \u2514\u2500\u2500 lib \u251c\u2500\u2500 adafruit_mmc56x3.py \u2514\u2500\u2500 adafruit_register \u251c\u2500\u2500 init .py \u251c\u2500\u2500 i2c_bcd_alarm.py \u251c\u2500\u2500 i2c_bcd_datetime.py \u251c\u2500\u2500 i2c_bit.py \u251c\u2500\u2500 i2c_bits.py \u251c\u2500\u2500 i2c_struct.py \u2514\u2500\u2500 i2c_struct_array.py Then, copy and paste the following code to the Mu Editor and press Save : import time import board import busio from adafruit_mmc56x3 import MMC5603 i2c1 = busio . I2C ( scl = board . GP15 , sda = board . GP14 ) # MMC5603 magnetometer magnetometer = MMC5603 ( i2c1 ) magnetometer . data_rate = 1000 # in Hz, from 1-255 or 1000 magnetometer . continuous_mode = True # Magnetic plotter while True : print ( magnetometer . magnetic ) time . sleep ( 0.1 ) Press the Plotter button on the top menu, and try moving your board and see the changes in plotter. Digital Optical Sensor DeskPi PicoMate has a Digital Optical Sensor (LTR-381RGB-01) that integrates an ambient light sensor (ALS) and a color sensor (CS). With the advanced RGB color sensor, this sensor converts light (Red, Green, Blue, and IR) intensity to a digital output signal capable of direct I2C interface. The ALS provides a linear response over a wide dynamic range, which is well suited to applications under very low or bright ambient brightness. The sensor is pre-wired to the Pico using I2C1 with the device address 0x53 . The table below shows the connections of each pin of the sensor: Digital Optical Sensor Pin On Pico SCL GP15/I2C1_SCL SDA GP14/I2C1_SDA Before we can use the sensor, we need the following modules installed: - adafruit_register - ltr381rgb Copy the libraries into the CIRCUITPY/lib folder. This should give you the following folder structure: CIRCUITPY/ \u251c\u2500\u2500 boot_out.txt \u251c\u2500\u2500 code.py \u2514\u2500\u2500 lib \u251c\u2500\u2500 adafruit_register \u2502 \u251c\u2500\u2500 init .py \u2502 \u251c\u2500\u2500 i2c_bcd_alarm.py \u2502 \u251c\u2500\u2500 i2c_bcd_datetime.py \u2502 \u251c\u2500\u2500 i2c_bit.py \u2502 \u251c\u2500\u2500 i2c_bits.py \u2502 \u251c\u2500\u2500 i2c_struct.py \u2502 \u2514\u2500\u2500 i2c_struct_array.py \u2514\u2500\u2500 ltr381rgb.py Then, copy and paste the following code to the Mu Editor and press Save : import time import board import busio from ltr381rgb import LTR381RGB i2c1 = busio . I2C ( scl = board . GP15 , sda = board . GP14 ) # Optical Sensor optical = LTR381RGB ( i2c1 ) optical . mode = \"CS\" optical . enable () # ALS and raw data plotter while True : print ( f \"ALS: { optical . lux } lx\" ) print ( optical . raw_data ) time . sleep ( 0.5 ) On Serial Console, you will see the calculated lux of ambient light. Try to lit up or dim the sensor. You will see the value changes. You can also use the plotter for raw data inspection. Press the Plotter button on the top menu. Temperature & Humidity Sensor DeskPi PicoMate has a temperature and humidity sensor (SHT30-DIS), which is pre-wired to the Pico using I2C1 with the device address 0x44 . The table below shows the connections of each pin of the sensor: Temperature & Humidity Sensor Pin On Pico SCL GP15/I2C1_SCL SDA GP14/I2C1_SDA Before we can use the sensor, we need the following modules installed: - adafruit_register - adafruit_sht31d Copy the libraries into the CIRCUITPY/lib folder. This should give you the following folder structure: CIRCUITPY/ \u251c\u2500\u2500 boot_out.txt \u251c\u2500\u2500 code.py \u2514\u2500\u2500 lib \u251c\u2500\u2500 adafruit_register \u2502 \u251c\u2500\u2500 init .py \u2502 \u251c\u2500\u2500 i2c_bcd_alarm.py \u2502 \u251c\u2500\u2500 i2c_bcd_datetime.py \u2502 \u251c\u2500\u2500 i2c_bit.py \u2502 \u251c\u2500\u2500 i2c_bits.py \u2502 \u251c\u2500\u2500 i2c_struct.py \u2502 \u2514\u2500\u2500 i2c_struct_array.py \u2514\u2500\u2500 adafruit_sht31d.py Then, copy and paste the following code to the Mu Editor and press Save : import time import board import busio from adafruit_sht31d import SHT31D i2c1 = busio . I2C ( scl = board . GP15 , sda = board . GP14 ) # Temperature & Humidity Sensor sht_sensor = SHT31D ( i2c1 ) loopcount = 0 while True : print ( \" \\n Temperature: %0.1f C\" % sht_sensor . temperature ) print ( \"Humidity: %0.1f %% \" % sht_sensor . relative_humidity ) loopcount += 1 time . sleep ( 2 ) # every 10 passes turn on the heater for 1 second if loopcount == 10 : loopcount = 0 sht_sensor . heater = True print ( \"Sensor Heater status =\" , sht_sensor . heater ) time . sleep ( 1 ) sht_sensor . heater = False print ( \"Sensor Heater status =\" , sht_sensor . heater ) On Serial Console, you will see the temperature and humidity printed every 2s . FAQ Q: Should I download the libraries from internet? A: Yes, if you want to use the latest version of the libraries. Appendix A: DeskPi PicoMate Pinout Diagram","title":"DeskPi PicoMate"},{"location":"picomate/#deskpi-picomate-user-manual","text":"","title":"DeskPi PicoMate User Manual"},{"location":"picomate/#description","text":"DeskPi PicoMate is an all-in-one and versatile prototyping kit designed for Raspberry Pi Pico and Pico W. It includes one expansion dock for Raspberry Pi Pico and Pico W, 12 detachable modules and all in one- piece of PCB design. All modules are pre-wired to the Pico Dock, no soldering and wiring required and out-of-box. Of course, you can also detach the modules and connect them using the cables included in the box. Buy DeskPi PicoMate Visit DeskPi Official Website","title":"Description"},{"location":"picomate/#features","text":"Designed for Raspberry Pi Pico and Pico W All modules are pre-wired, no soldering and wiring required and out-of-box 12 detachable and easy-to-use modules: Push Button WS2812 RGB LED Rotary Encoder Buzzer Digital Microphone (ZTS6531S) Digital PIR Sensor (AS312) 6-Axis IMU Sensor (LSM6DS3TR-C) Digital Optical Sensor (LTR-381RGB-01) 3-Axis Magnetometer (MMC5603NJ) Temperature & Humidity Sensor (SHT30-DIS) 0.96\u201d 128x64 OLED Display (SSD1315) 204 Pins Breakout Board All Pico GPIOs available via headers and up to 11 Grove connectors available Built-in battery connector for on-the-go projects MicroPython libraries support for all modules 3.3V IO operating voltage","title":"Features"},{"location":"picomate/#package-includes","text":"1x DeskPi PicoMate 1x Raspberry Pi Pico with pre-soldered pin headers 1x 3*AA Battery Holder with On/Off Switch 6x Grove Cable 1x Micro USB Cable","title":"Package Includes"},{"location":"picomate/#pinout-diagram","text":"","title":"Pinout Diagram"},{"location":"picomate/#getting-start","text":"","title":"Getting Start"},{"location":"picomate/#getting-started-with-python","text":"The DeskPi PicoMate can be programmed using the popular Python programming language. Raspberry Pi Pico is supported by CircuitPython, which is based on MicroPython, and features unified Python core APIs and a growing list of device libraries and drivers that work with it. This section describes how to set up CircuitPython on DeskPi PicoMate. Examples are also provided to help you to get started in a very short time","title":"Getting Started with Python"},{"location":"picomate/#installing-circuitpython","text":"Download the official CircuiPython for Raspberry Pi Pico . Choose the latest stable release and then download the .uf2 file. Then go ahead and: Push and hold the BOOTSEL button and plug your Pico into the USB port of your computer. Release the BOOTSEL button after your Pico is connected. It will mount as a Mass Storage Device called RPI-RP2 . Drag and drop the CircuitPython UF2 file onto the RPI-RP2 volume. Your Pico will reboot. A new drive named CIRCUITPY should appear.","title":"Installing CircuitPython"},{"location":"picomate/#installing-mu-editor","text":"Mu Editor is a simple Python code editor for beginner programmers. Go to Mu Editor Download page , choose your Operational System and follow the instructions. MU Editor Once the Mu Editor is installed, open it, go to Mode menu, select CircuitPython and press OK . In the text editor, try some Python code: print ( 'Hello, DeskPi PicoMate!' ) Select Save on Top Menu. A window will appear. Give the name code.py for your code and save it on the CIRCUITPY drive. Your code will run as soon as the file is done saving. The Serial button opens a serial data connection to the Pico. This will result in a new panel between the text editor and Mu s footer, which prints the data from the Pico. If you need to drop into the CircuitPython REPL you should make sure the panel has keyboard focus (just click it!) and then type CTRL+ C . Now that you have the Python prerequisites installed, it is time to explore more examples for the DeskPi PicoMate.","title":"Installing Mu Editor"},{"location":"picomate/#python-examples","text":"This section consists of several example codes. The examples are organized in different levels of codes to demonstrate the Python API usage.","title":"Python Examples"},{"location":"picomate/#blink-rgb-led","text":"DeskPi PicoMate has a WS2812 RGB LED pre-wired to GP22 on the Pico. We can use the NeoPixel library to blink the RGB LED. Download the NeoPixel library and copy neopixel.py into the CIRCUITPY/lib folder.This should give you the following folder structure: Copy and paste the following code to the Mu Editor and press Save : import time import board import neopixel R = ( 50 , 0 , 0 ) G = ( 0 , 50 , 0 ) B = ( 0 , 0 , 50 ) COLORS = ( R , G , B ) pixels = neopixel . NeoPixel ( board . GP22 , 1 ) while True : for color in COLORS : pixels [ 0 ] = COLORS time . sleep ( 1 ) Your code will run as soon as the file is done saving. Observe that the RGB LED starts to blink. For more details about the Neopixel API reference, please check out Read the Docs","title":"Blink RGB LED"},{"location":"picomate/#button","text":"DeskPi PicoMate has a Push Button pre-wired to GP26 on the Pico. The example prints a message to the console each time the state of the button changes. When the button is pressed, the input level of GP26 will be low (False) level. Copy and paste the following code to the Mu Editor and press Save : import board import digitalio # Button button = digitalio . DigitalInOut ( board . GP26 ) button . direction = digitalio . Direction . INPUT button . pull = digitalio . Pull . UP last_value = button . value while True : if last_value != button . value : last_value = button . value print ( 'Button is ' + ( 'released' if button . value else 'pressed' )) Press the button and observe the Serial Console, you will see the message printed each time the state of the button changes:","title":"Button"},{"location":"picomate/#rotary-encoder","text":"DeskPi PicoMate has an incremental rotary encoder pre-wired to the Pico, which converts the motion of the switch (clockwise or counterclockwise) into an output signal that can be used to determine what direction the knob is being rotated. The table below shows the connections of each pin of the rotary encoder: Rotary Encoder Pin On Pico A GP7 B GP6 Swith(Optional, Active High Level) GP26 Copy and paste the following code to the Mu Editor and press Save : import rotaryio import board import digitalio encoder = rotaryio . IncrementalEncoder ( board . GP7 , board . GP6 ) switch = digitalio . DigitalInOut ( board . GP26 ) switch . direction = digitalio . Direction . INPUT switch . pull = digitalio . Pull . DOWN last_position = encoder . position switch_state = switch . value while True : position = encoder . position if last_position is None or position != last_position : print ( f \"Rotary: { position } \" ) last_position = position if switch_state != switch . value : switch_state = switch . value print ( 'Switch is ' + ( 'ON' if switch . value else 'OFF' )) Now, open the Serial Console, then try rotating the knob slowly clockwise or counterclockwise, and try pressing down on the knob.","title":"Rotary Encoder"},{"location":"picomate/#buzzer","text":"DeskPi PicoMate has a buzzer pre-wired to GP27 on the Pico. To control the buzzer from CircuitPython we will use its built in PWM, or pulse-width modulation, signal generation capabilities. Copy and paste the following code to the Mu Editor and press Save: import time import board import pwmio # Define a list of tones/music notes to play. TONE_FREQ = [ 1047 , 1047 , 1568 , 1568 , 1760 , 1760 , 1568 , 0 , 1397 , 1397 , 1319 , 1319 , 1175 , 1175 , 1047 , 0 , 1568 , 1568 , 1397 , 1397 , 1319 , 1319 , 1175 , 0 , 1568 , 1568 , 1397 , 1397 , 1319 , 1319 , 1175 , 0 , 1047 , 1047 , 1568 , 1568 , 1760 , 1760 , 1568 , 0 , 1397 , 1397 , 1319 , 1319 , 1175 , 1175 , 1047 , 0 , ] # Buzzer buzzer = pwmio . PWMOut ( board . GP27 , variable_frequency = True ) buzzer . frequency = TONE_FREQ [ 0 ] buzzer . duty_cycle = 32768 while True : for note in TONE_FREQ : if note : buzzer . frequency = notes time . sleep ( 0.1 ) The music playback will immediately start as soon as the code is done saving.","title":"Buzzer"},{"location":"picomate/#096-128x64-oled-display","text":"DeskPi PicoMate has a 0.96\" 128x64 OLED Display module, which is pre-wired to the Pico using I2C0 with the device address 0x3C . The table below shows the connections of each pin of the OLED: 0.96\" 128x64 OLED Pin On Pico SCL GP17/I2C0_SCL SDA GP16/I2C0_SDA Before we can use the display module, we need the following modules installed: - adafruit_register - adafruit_framebuf - adafruit_ssd1306 Copy the libraries into the CIRCUITPY/lib folder. This should give you the following folder structure: Then, copy and paste the following code to the Mu Editor and press Save : import time import board import busio from adafruit_ssd1306 import SSD1306_I2C i2c0 = busio . I2C ( scl = board . GP17 , sda = board . GP16 ) # 0.96\" 128x64 OLED Display display = SSD1306_I2C ( 128 , 64 , i2c0 ) def display_text ( str , line ): display . text ( str , 0 , ( line % 8 ) * 8 , 1 , font_name = \"/lib/font5x8.bin\" ) while True : display . fill ( 0 ) display_text ( \"Hello, World!\" , 0 ) display_text ( \"It's DeskPi PicoMate!\" , 2 ) display . show () time . sleep ( 0.5 ) Try to change the display text and observe what is printed on the OLED.","title":"0.96\u201d 128x64 OLED Display"},{"location":"picomate/#pdm-microphone","text":"DeskPi PicoMate has a high quality, low power PDM digital output top-ported omni-directional MEMS microphone. The PDM microphone is pre-wired to the Pico. The table below shows the connections of each pin of the PDM microphone: PDM Microphone Pin On Pico CLK GP9 DATA GP8 As PDMIn is built into CircuitPython, no separate libraries are necessary for this example! Copy and paste the following code to the Mu Editor and press Save : import time import array import math import board import audiobusio # Remove DC bias before computing RMS. def mean ( values ): return sum ( values ) / len ( values ) # Calculate the Normalized RMS value of samples def normalized_rms ( values ): minbuf = int ( mean ( values )) samples_sum = sum ( float ( sample - minbuf ) * ( sample - minbuf ) for sample in values ) return math . sqrt ( samples_sum / len ( values )) # PDM Microphone mic = audiobusio . PDMIn ( board . GP9 , board . GP8 , sample_rate = 16000 , bit_depth = 16 ) samples = array . array ( 'H' , [ 0 ] * 160 ) while True : mic . record ( samples , len ( samples )) magnitude = normalized_rms ( samples ) print (( magnitude ,)) time . sleep ( 0.1 ) On Serial Console, you will see the Normalized RMS value of the audio captured by the Microphone. Try to make some sound. You will see the magnitude changes. You can also use the plotter for data inspection. Press the Plotter button on the top menu.","title":"PDM Microphone"},{"location":"picomate/#digital-pir-sensor","text":"DeskPi PicoMate has a Digital PIR sensor pre-wired to GP28 on the Pico. The Digital PIR sensor allows you to sense motion, almost used to detect whether a human has moved in or out of the sensors range. The Digital PIR sensor acts as a digital output. When the sensor is triggered, the input level of GP28 will be High (True) Level. Copy and paste the following code to the Mu Editor and press Save : import board import digitalio # PIR sensor pir_sensor = digitalio . DigitalInOut ( board . GP28 ) pir_sensor . direction = digitalio . Direction . INPUT pir_sensor . pull = digitalio . Pull . DOWN last_value = pir_sensor . value while True : if last_value != pir_sensor . value : last_value = pir_sensor . value print ( 'Motion ' + ( 'detected!' if pir_sensor . value else 'removed!' )) Try moving your body and see messages printed on the Serial Console.","title":"Digital PIR Sensor"},{"location":"picomate/#6-axis-imu-sensor","text":"DeskPi PicoMate has a 6-Axis IMU sensor (LSM6DS3TR-C) featuring a 3D digital accelerometer and a 3D digital gyroscope. The sensor is pre-wired to the Pico using I2C1 with the device address 0x6A . The table below shows the connections of each pin of the sensor: 6-Axis IMU sensor Pin On Pico SCL GP15/I2C1_SCL SDA GP14/I2C1_SDA Before we can use the sensor, we need the following modules installed: - adafruit_register - adafruit_lsm6ds Copy the libraries into the CIRCUITPY/lib folder. This should give you the following folder structure: CIRCUITPY/ \u251c\u2500\u2500 boot_out.txt \u251c\u2500\u2500 code.py \u2514\u2500\u2500 lib \u251c\u2500\u2500 adafruit_lsm6ds \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 ism330dhcx.py \u2502 \u251c\u2500\u2500 lsm6ds3.py \u2502 \u251c\u2500\u2500 lsm6ds33.py \u2502 \u251c\u2500\u2500 lsm6ds3trc.py \u2502 \u251c\u2500\u2500 lsm6dso32.py \u2502 \u2514\u2500\u2500 lsm6dsox.py \u2514\u2500\u2500 adafruit_register \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 i2c_bcd_alarm.py \u251c\u2500\u2500 i2c_bcd_datetime.py \u251c\u2500\u2500 i2c_bit.py \u251c\u2500\u2500 i2c_bits.py \u251c\u2500\u2500 i2c_struct.py \u2514\u2500\u2500 i2c_struct_array.py Then, copy and paste the following code to the Mu Editor and press Save : import time import board import busio from adafruit_lsm6ds.lsm6ds3trc import LSM6DS3TRC i2c1 = busio . I2C ( scl = board . GP15 , sda = board . GP14 ) # 6-Axis IMU Sensor imu_sensor = LSM6DS3TRC ( i2c1 ) # Acceleration plotter while True : print ( imu_sensor . acceleration ) time . sleep ( 0.1 ) # Gyro plotter # while True: # print(imu_sensor.gyro) # time.sleep(0.1) Press the Plotter button on the top menu, and try moving your board and see the changes in plotter.","title":"6-Axis IMU Sensor"},{"location":"picomate/#3-axis-magnetometer","text":"DeskPi PicoMate has a 3-Axis Magnetometer (MMC5603NJ) that can measure magnetic fields surrounding the device. The sensor is pre-wired to the Pico using I2C1 with the device address 0x30 . The table below shows the connections of each pin of the sensor: 3-Axis Magnetometer Pin On Pico SCL GP15/I2C1_SCL SDA GP14/I2C1_SDA Before we can use the sensor, we need the following modules installed: - adafruit_register - adafruit_mmc56x3 Copy the libraries into the CIRCUITPY/lib folder. This should give you the following folder structure: CIRCUITPY/ \u251c\u2500\u2500 boot_out.txt \u251c\u2500\u2500 code.py \u2514\u2500\u2500 lib \u251c\u2500\u2500 adafruit_mmc56x3.py \u2514\u2500\u2500 adafruit_register \u251c\u2500\u2500 init .py \u251c\u2500\u2500 i2c_bcd_alarm.py \u251c\u2500\u2500 i2c_bcd_datetime.py \u251c\u2500\u2500 i2c_bit.py \u251c\u2500\u2500 i2c_bits.py \u251c\u2500\u2500 i2c_struct.py \u2514\u2500\u2500 i2c_struct_array.py Then, copy and paste the following code to the Mu Editor and press Save : import time import board import busio from adafruit_mmc56x3 import MMC5603 i2c1 = busio . I2C ( scl = board . GP15 , sda = board . GP14 ) # MMC5603 magnetometer magnetometer = MMC5603 ( i2c1 ) magnetometer . data_rate = 1000 # in Hz, from 1-255 or 1000 magnetometer . continuous_mode = True # Magnetic plotter while True : print ( magnetometer . magnetic ) time . sleep ( 0.1 ) Press the Plotter button on the top menu, and try moving your board and see the changes in plotter.","title":"3-Axis Magnetometer"},{"location":"picomate/#digital-optical-sensor","text":"DeskPi PicoMate has a Digital Optical Sensor (LTR-381RGB-01) that integrates an ambient light sensor (ALS) and a color sensor (CS). With the advanced RGB color sensor, this sensor converts light (Red, Green, Blue, and IR) intensity to a digital output signal capable of direct I2C interface. The ALS provides a linear response over a wide dynamic range, which is well suited to applications under very low or bright ambient brightness. The sensor is pre-wired to the Pico using I2C1 with the device address 0x53 . The table below shows the connections of each pin of the sensor: Digital Optical Sensor Pin On Pico SCL GP15/I2C1_SCL SDA GP14/I2C1_SDA Before we can use the sensor, we need the following modules installed: - adafruit_register - ltr381rgb Copy the libraries into the CIRCUITPY/lib folder. This should give you the following folder structure: CIRCUITPY/ \u251c\u2500\u2500 boot_out.txt \u251c\u2500\u2500 code.py \u2514\u2500\u2500 lib \u251c\u2500\u2500 adafruit_register \u2502 \u251c\u2500\u2500 init .py \u2502 \u251c\u2500\u2500 i2c_bcd_alarm.py \u2502 \u251c\u2500\u2500 i2c_bcd_datetime.py \u2502 \u251c\u2500\u2500 i2c_bit.py \u2502 \u251c\u2500\u2500 i2c_bits.py \u2502 \u251c\u2500\u2500 i2c_struct.py \u2502 \u2514\u2500\u2500 i2c_struct_array.py \u2514\u2500\u2500 ltr381rgb.py Then, copy and paste the following code to the Mu Editor and press Save : import time import board import busio from ltr381rgb import LTR381RGB i2c1 = busio . I2C ( scl = board . GP15 , sda = board . GP14 ) # Optical Sensor optical = LTR381RGB ( i2c1 ) optical . mode = \"CS\" optical . enable () # ALS and raw data plotter while True : print ( f \"ALS: { optical . lux } lx\" ) print ( optical . raw_data ) time . sleep ( 0.5 ) On Serial Console, you will see the calculated lux of ambient light. Try to lit up or dim the sensor. You will see the value changes. You can also use the plotter for raw data inspection. Press the Plotter button on the top menu.","title":"Digital Optical Sensor"},{"location":"picomate/#temperature-humidity-sensor","text":"DeskPi PicoMate has a temperature and humidity sensor (SHT30-DIS), which is pre-wired to the Pico using I2C1 with the device address 0x44 . The table below shows the connections of each pin of the sensor: Temperature & Humidity Sensor Pin On Pico SCL GP15/I2C1_SCL SDA GP14/I2C1_SDA Before we can use the sensor, we need the following modules installed: - adafruit_register - adafruit_sht31d Copy the libraries into the CIRCUITPY/lib folder. This should give you the following folder structure: CIRCUITPY/ \u251c\u2500\u2500 boot_out.txt \u251c\u2500\u2500 code.py \u2514\u2500\u2500 lib \u251c\u2500\u2500 adafruit_register \u2502 \u251c\u2500\u2500 init .py \u2502 \u251c\u2500\u2500 i2c_bcd_alarm.py \u2502 \u251c\u2500\u2500 i2c_bcd_datetime.py \u2502 \u251c\u2500\u2500 i2c_bit.py \u2502 \u251c\u2500\u2500 i2c_bits.py \u2502 \u251c\u2500\u2500 i2c_struct.py \u2502 \u2514\u2500\u2500 i2c_struct_array.py \u2514\u2500\u2500 adafruit_sht31d.py Then, copy and paste the following code to the Mu Editor and press Save : import time import board import busio from adafruit_sht31d import SHT31D i2c1 = busio . I2C ( scl = board . GP15 , sda = board . GP14 ) # Temperature & Humidity Sensor sht_sensor = SHT31D ( i2c1 ) loopcount = 0 while True : print ( \" \\n Temperature: %0.1f C\" % sht_sensor . temperature ) print ( \"Humidity: %0.1f %% \" % sht_sensor . relative_humidity ) loopcount += 1 time . sleep ( 2 ) # every 10 passes turn on the heater for 1 second if loopcount == 10 : loopcount = 0 sht_sensor . heater = True print ( \"Sensor Heater status =\" , sht_sensor . heater ) time . sleep ( 1 ) sht_sensor . heater = False print ( \"Sensor Heater status =\" , sht_sensor . heater ) On Serial Console, you will see the temperature and humidity printed every 2s .","title":"Temperature &amp; Humidity Sensor"},{"location":"picomate/#faq","text":"Q: Should I download the libraries from internet? A: Yes, if you want to use the latest version of the libraries.","title":"FAQ"},{"location":"picomate/#appendix-a-deskpi-picomate-pinout-diagram","text":"","title":"Appendix A: DeskPi PicoMate Pinout Diagram"},{"location":"ssdcheck/","text":"Getting Start . For order please visit: DeskPi.com . How to check SSD/HDD status Check if the SSD/HDD has been recognized by OS, just check USB controller's status will be ok due to it is connected via an USB adapter . dmesg | grep -i usb Check if the it supports UASP , USB Attached SCSI (UAS) or USB Attached SCSI Protocol (UASP) is a computer protocol used to move data to and from USB storage devices such as hard drives (HDDs), solid-state drives (SSDs), and thumb drives. UAS depends on the USB protocol, and uses the standard SCSI command set. Use of UAS generally provides faster transfers compared to the older USB Mass Storage Bulk-Only Transport (BOT) drivers. UAS was introduced as part of the USB 3.0 standard, but can also be used with devices complying with the slower USB 2.0 standard, assuming use of compatible hardware, firmware and drivers. * Command: lsusb -t If you can not find uas in the output message, it means it does not support uasp . if not, and the disk still not show up on your Raspberry Pi desktop, please check your hardware and repeat following steps: Hareware checking steps: Please make sure the USB adapter is connect well. Please check the harddisk adapter board's 4Pin pinheader is connect properly. Please tell me what kind of OS did you use? Raspbian OS ? Please use the wall charger that we provide in the package. Please send us the result of those commands in terminal so that we can help you to diagnose the problem. Reboot your Raspberry Pi by typing: sudo sync sudo reboot Software checking steps: Make sure the drive can be recognized. sudo fdisk -l | grep -i 'dev' or lsusb -t or lsblk Make sure the drive is not raw disk or has NTFS filesystem on it. here /dev/sda is my test result, you shall change this as your result from sudo fdisk -l |grep -i 'dev' command. sudo fdisk -l /dev/sda If it is a raw disk , means it has never been partied before, you need to make partition and format it, and mount it to a directory so that you can access it. Make Partitions sudo fdisk /dev/sda p n p 1 Enter Enter w Explanation: ** p means: print partition table. ** ** n means: new - create new partition. ** ** p means: primary partition. ** 1 means: the first partition number. ** ** Enter means: select default cylinder as start cylinder. ** Enter means: select the whole disk as end cylinder. ** ** w means: save the change to partition table and quit. ** Format partition sudo mkfs.ext4 /dev/sda1 It will format /dev/sda1 partition to an ext4 type filesystem which can be supported by most Linux distributions. Mount partition You need to mount the partition to a folder(directory) before you can use it. cd mkdir mydata sudo mount -t ext4 /dev/sda1 mydata -v sudo chmod 777 /home/pi/mydata Explanation: cd means go back to your home directory. mkdir means create a directory for your partition. sudo mount -t ext4 /dev/sda1 mydata -v means mount /dev/sda1 partition to directory mydata with ext4 type filesystem format and -v will show the details when you mount this partition. sudo chmod 777 /home/pi/mydata means everyone can have full privilledges on this mounting point. you have read , write , execute permission on this directory. How to check if it has been mounted on df -Th or sudo mount","title":"How to check SSD/HDD status"},{"location":"ssdcheck/#getting-start","text":". For order please visit: DeskPi.com .","title":"Getting Start"},{"location":"ssdcheck/#how-to-check-ssdhdd-status","text":"Check if the SSD/HDD has been recognized by OS, just check USB controller's status will be ok due to it is connected via an USB adapter . dmesg | grep -i usb Check if the it supports UASP , USB Attached SCSI (UAS) or USB Attached SCSI Protocol (UASP) is a computer protocol used to move data to and from USB storage devices such as hard drives (HDDs), solid-state drives (SSDs), and thumb drives. UAS depends on the USB protocol, and uses the standard SCSI command set. Use of UAS generally provides faster transfers compared to the older USB Mass Storage Bulk-Only Transport (BOT) drivers. UAS was introduced as part of the USB 3.0 standard, but can also be used with devices complying with the slower USB 2.0 standard, assuming use of compatible hardware, firmware and drivers. * Command: lsusb -t If you can not find uas in the output message, it means it does not support uasp . if not, and the disk still not show up on your Raspberry Pi desktop, please check your hardware and repeat following steps:","title":"How to check SSD/HDD status"},{"location":"ssdcheck/#hareware-checking-steps","text":"Please make sure the USB adapter is connect well. Please check the harddisk adapter board's 4Pin pinheader is connect properly. Please tell me what kind of OS did you use? Raspbian OS ? Please use the wall charger that we provide in the package. Please send us the result of those commands in terminal so that we can help you to diagnose the problem. Reboot your Raspberry Pi by typing: sudo sync sudo reboot","title":"Hareware checking steps:"},{"location":"ssdcheck/#software-checking-steps","text":"Make sure the drive can be recognized. sudo fdisk -l | grep -i 'dev' or lsusb -t or lsblk Make sure the drive is not raw disk or has NTFS filesystem on it. here /dev/sda is my test result, you shall change this as your result from sudo fdisk -l |grep -i 'dev' command. sudo fdisk -l /dev/sda If it is a raw disk , means it has never been partied before, you need to make partition and format it, and mount it to a directory so that you can access it. Make Partitions sudo fdisk /dev/sda p n p 1 Enter Enter w","title":"Software checking steps:"},{"location":"ssdcheck/#explanation","text":"** p means: print partition table. ** ** n means: new - create new partition. ** ** p means: primary partition. ** 1 means: the first partition number. ** ** Enter means: select default cylinder as start cylinder. ** Enter means: select the whole disk as end cylinder. ** ** w means: save the change to partition table and quit. ** Format partition sudo mkfs.ext4 /dev/sda1 It will format /dev/sda1 partition to an ext4 type filesystem which can be supported by most Linux distributions. Mount partition You need to mount the partition to a folder(directory) before you can use it. cd mkdir mydata sudo mount -t ext4 /dev/sda1 mydata -v sudo chmod 777 /home/pi/mydata","title":"Explanation:"},{"location":"ssdcheck/#explanation_1","text":"cd means go back to your home directory. mkdir means create a directory for your partition. sudo mount -t ext4 /dev/sda1 mydata -v means mount /dev/sda1 partition to directory mydata with ext4 type filesystem format and -v will show the details when you mount this partition. sudo chmod 777 /home/pi/mydata means everyone can have full privilledges on this mounting point. you have read , write , execute permission on this directory.","title":"Explanation:"},{"location":"ssdcheck/#how-to-check-if-it-has-been-mounted-on","text":"df -Th or sudo mount","title":"How to check if it has been mounted on"},{"location":"super6c/","text":"DeskPi Super6C Purchase DeskPi Super6C Description DeskPi Super6C is the Raspberry Pi cluster board a standard size mini-ITX board to be put in a case with up to 6 RPI CM4 Compute Modules. - For every CM4: * M.2 2280 slot (PCIe Gen 2 x1) * TF Card slot * 5V FAN Header * Micro USB 2.0 Only for 1st CM4: USB Host A 2.0 x2 USB Host 2.54 4-pins x2 HDMI 2.0 x1 HDMI 1.4a x1 Featrues Package Includes: 1pcs Raspberry Pi CM4 Cluster Mini-ITX board. 1pcs 100W Power supply. Note: Raspberry Pi CM4 board are not included Dimension 170mm x 170mm x 21mm (Mini-ITX) Applications Self-hosted: Host cloud applications locally or at the edge Learning Learning: Kubernetes, Docker, Serverless Development: Build cloud-native and CI/CD for ARM edge infrastructure Network-Attached Storage or Distributed Storage System :6 x ARM NAS node or CEPH node Software Port definitions 1 x DC IN +12~24V 2 x RJ45 Gigabit Ethernet Port 1Gbps 2 x Full-Sized HDMI Ports 1 x Micro USB Port from CM4 1# (Flashing EEPROM) 2 x CM4 1# USB Host 2.0 6 x CM4 Activity LED 3 x Fan Pin Header 1 x Always ON switch Power Supply Specifications Recommended: SWITCHING ADAPTER Model: FJ-SW2025G1904730 INPUT: 100-240V~50/60Hz 2.0A Max OUTPUT\uff1a19.0V \u2248 4.73A\uff0c 89.87W Mechanical Drawing Block Scheme Pin Headers definitions CM4 Jumpers Functions LED definitions 4-Pin ATX Power Pins definitions 12V Pin and GND: Power button and Reset Button Distribution of Pins Note\uff1a J6: If you are using 9pin USB pins, it is more common for motherboards that support Pentium4 or athlon XP chipsets (such as i845D, i845E, SiS 650, etc.) to need to drop the pins. If a 10-pin type USB pin is used, such as i815, i815E, i815EP, KT133 and other chipset motherboards, this pin can be reserved, please refer to the motherboard manual for wiring. J27 : J27 Pin is the control programming interface for power management, which is directly used for internal production, DO NOT CONNECT!!! J11/J13 : PoE1/PoE2 Not available, DO NOT CONNECT!!! How to install CM4 module Please press the CM4 module onto Super6c mainboard as following picture. Attach the CM4 to the board by simply aligning it with the two connectors on the IO board, then give it a good squeeze. It\u2019ll crunch into place and you should be set. and if you have SSD drive, install it as following picture. How to Flash image to eMMC on CM4 module. Flashing the Compute Module eMMC The Compute Module has an on-board eMMC device connected to the primary SD card interface. This guide explains how to write data to the eMMC storage using a Compute Module IO board. Please also read the section in the Compute Module Datasheets Compute Module 4 Ensure the Compute Module is fitted correctly installed on the IO board. It should lie flat on the IO board. Make sure that nRPBOOT which is on J2 (disable eMMC Boot) on the board jumper is fitted Use a micro USB cable to connect the micro USB slave port MCRO_USB on board to the host device. Do not power up yet. For Windows Users Under Windows, an installer is available to install the required drivers and boot tool automatically. Alternatively, a user can compile and run it using Cygwin and/or install the drivers manually. Windows Installer For those who just want to enable the Compute Module eMMC as a mass storage device under Windows, the stand-alone installer is the recommended option. This installer has been tested on Windows 10 32-bit and 64-bit, and Windows XP 32-bit. Please ensure you are not writing to any USB devices whilst the installer is running. Download and run the Windows installer to install the drivers and boot tool. windows installer download URL Plug your host PC USB into the USB SLAVE port, making sure you have setup the board as described above. Apply power to the board; Windows should now find the hardware and install the driver. Once the driver installation is complete, run the RPiBoot.exe tool that was previously installed. After a few seconds, the Compute Module eMMC will pop up under Windows as a disk (USB mass storage device). Building rpiboot on your host system (Cygwin/Linux) We will be using Git to get the rpiboot source code, so ensure Git is installed. In Cygwin, use the Cygwin installer. On a Raspberry Pi or other Debian-based Linux machine, use the following command: sudo apt install git Git may produce an error if the date is not set correctly. On a Raspberry Pi, enter the following to correct this: sudo data MMDDhhmm where MM is the month, DD is the date, and hh and mm are hours and minutes respectively. Clone the usbboot tool repository: git clone --depth = 1 https://github.com/raspberrypi/usbboot cd usbboot libusb must be installed. If you are using Cygwin, please make sure libusb is installed as previously described. On Raspberry Pi OS or other Debian-based Linux, enter the following command: sudo apt install libusb-1.0-0-dev Now build and install the usbboot tool: make Run the usbboot tool and it will wait for a connection: sudo ./rpiboot Now plug the host machine into the Super6C USB slave port and power on. The rpiboot tool will discover the Compute Module and send boot code to allow access to the eMMC. For more information run Writing to the eMMC (Windows) After rpiboot completes, a new USB mass storage drive will appear in Windows. We recommend using Raspberry Pi Imager to write images to the drive. Make sure J2 (nRPBOOT) is set to the disabled position and/or nothing is plugged into the USB slave port. Power cycling the IO board should now result in the Compute Module booting from eMMC. Writing to the eMMC (Linux) After rpiboot completes, you will see a new device appear; this is commonly /dev/sda on a Raspberry Pi but it could be another location such as /dev/sdb, so check in /dev/ or run lsblk before running rpiboot so you can see what changes. You now need to write a raw OS image (such as Raspberry Pi OS) to the device. Note the following command may take some time to complete, depending on the size of the image: (Change /dev/sdX to the appropriate device.) sudo dd if = raw_os_image_of_your_choice.img of = /dev/sdX bs = 4MiB Once the image has been written, unplug and re-plug the USB; you should see two partitions appear (for Raspberry Pi OS) in /dev. In total, you should see something similar to this: /dev/sdX <- device /dev/sdX1 <- First partition ( FAT ) /dev/sdX2 <- Second partition ( Linux Filesystem ) The /dev/sdX1 and /dev/sdX2 partitions can now be mounted normally. Make sure J2 (nRPBOOT) is set to the disabled position and/or nothing is plugged into the USB slave port. Power cycling the board should now result in the Compute Module booting from eMMC. Compute Module 4 Bootloader The default bootloader configuration on CM4 is designed to support bring up and development on a Compute Module 4 IO board and the software version flashed at manufacture may be older than the latest release. For final products please consider: Selecting and verifying a specific bootloader release. The version in the usbboot repo is always a recent stable release. Configuring the boot device (e.g. network boot). See BOOT_ORDER section in the bootloader configuration guide. Enabling hardware write protection on the bootloader EEPROM to ensure that the bootloader can\u2019t be modified on remote/inaccessible products. N.B. The Compute Module 4 ROM never runs recovery.bin from SD/EMMC and the rpi-eeprom-update service is not enabled by default. This is necessary because the EMMC is not removable and an invalid recovery.bin file would prevent the system from booting. This can be overridden and used with self-update mode where the bootloader can be updated from USB MSD or Network boot. However, self-update mode is not an atomic update and therefore not safe in the event of a power failure whilst the EEPROM was being updated. Modifying the bootloader configuration To modify the CM4 bootloader configuration: cd usbboot/recovery Replace pieeprom.original.bin if a specific bootloader release is required. Edit the default boot.conf bootloader configuration file. Typically, at least the BOOT_ORDER must be updated: For network boot BOOT_ORDER=0xf2 For SD/EMMC boot BOOT_ORDER=0xf1 For USB boot failing over to EMMC BOOT_ORDER=0xf15 Run ./update-pieeprom.sh to update the EEPROM image pieeprom.bin image file. If EEPROM write protection is required then edit config.txt and add eeprom_write_protect=1 . Hardware write-protection must be enabled via software and then locked by pulling the EEPROM_nWP pin low. Run ../rpiboot -d . to update the bootloader using the updated EEPROM image pieeprom.bin The pieeprom.bin file is now ready to be flashed to the Compute Module 4. Flashing the bootloader EEPROM - Compute Module 4 To flash the bootloader EEPROM follow the same hardware setup as for flashing the EMMC but also ensure EEPROM_nWP is NOT pulled low. Once complete EEPROM_nWP may be pulled low again. # Writes recovery/pieeprom bin to the bootloader EEPROM. ./rpiboot -d recovery Troubleshooting For a small percentage of Raspberry Pi Compute Module 3s, booting problems have been reported. We have traced these back to the method used to create the FAT32 partition; we believe the problem is due to a difference in timing between the BCM2835/6/7 and the newer eMMC devices. The following method of creating the partition is a reliable solution in our hands. sudo parted /dev/<device> ( parted ) mkpart primary fat32 4MiB 64MiB ( parted ) q sudo mkfs.vfat -F32 /dev/<device> sudo cp -r <files>/* <mountpoint> After Flash Raspberry Pi OS to eMMC on CM4 module, just power off the system, and one complete, 5 to go, just repeat those step five times. If your CM4 Module does not have eMMC on board, that will be easy, just flash Raspberry Pi OS to TF card or SSD drive, and insert them to card slot, fix it with screws. and connect the power supply, and press PWR_BTN button to power them on. If your CM4 module has eMMC on board, the SSD drive and TF card can be external mass storage. How to build your own cluster and manage the cluster via Ansible Fit for CM4 Lite version Note: The latest Raspberry Pi OS does not contain pi user and it may not need to add dtoverlay=dwc2,dr_mode=host to config.txt file on location /boot . Assume you are using the old version (Raspberry Pi OS 2021-11-08) CM4 Lite means Raspberry Pi Computer module come without a EMMC storage onboard.\u3000That means additional MicroSD card(TF card) is required. Steps: Download the latest Raspberry Pi OS 64bit image from: Download Image Unzip it and flash the .img file to TF card by using Etcher tool, which can be downloaded via Download flash tool Modify config.txt file in TF card and adding dtoverlay=dwc2,dr_mode=host to it and save it. (Do not need to execute this step if your using the latest version image) Before we unplug, now that your CM4 is fully flashed and ready to go, you\u2019ll be surprised to learn that the USB Ports are disabled by default. Yes, really. Remember, this is a board designed to be embedded elsewhere and not for consumer-level off-the-shelf use. In the \u201cboot\u201d folder, find the config.txt and add the following: dtoverlay = dwc2,dr_mode = host This will turn on the USB ports when you boot up, but if you accidentally keep the micro USB in, you will run into issues. Before you begin your first boot, make sure everything is unplugged. Boot and then plug in your mouse or keyboard. If you\u2019re like me and couldn\u2019t get a wi-fi version, this is where you\u2019ll plug in your dongle or ethernet cable. Create a new file named ssh on TF card /boot folder Insert TF card into card slot on Super6C board. Connect the power supply to DC Socket or Using ATX Power supply. (Max. 24V/6.15A) Connect Full-sized HDMI cable to super6C, Other head connect to your TV or Monitor. Connect Keyboard and mouse to USB2.0 port on board. Connect Ethernet cable to ETH1 to your Router. Press PWR_BTN button to booting up all of CM4 modules. Press Reset button will reset all of CM4 modules, unsaved file will be lost!!! Login to Raspberry pi username: pi default password: raspberry * Make sure your OS can access internet. Deploy ansible environments as following steps If you want to use Ansible to manage Raspberry Pi cluster, you need to upgrade python version from 3.7 to 3.8 as following steps: Remove old version python sudo apt remove ansible sudo apt purge \u2013y python2.7-minimal Update and upgrade system. sudo apt update sudo apt upgrade \u2013y Install dependencies. sudo apt-get install -y build-essential tk-dev libncurses5-dev \\ libncursesw5-dev libreadline6-dev libdb5.3-dev libgdbm-dev libsqlite3-dev \\ libssl-dev libbz2-dev libexpat1-dev liblzma-dev zlib1g-dev libffi-dev Download source code and compile it. version = 3 .8.5 wget https://www.python.org/ftp/python/ $version /Python- $version .tgz tar zxf Python- $version .tgz cd Python- $version ./configure --enable-optimizations make -j4 sudo make altinstall Do remember:\u3000Installs Python into /usr/local/bin Install ansible We can use apt or your particular distro package manager, but doing that, we risk no getting the latest version available. In some cases, I have to agree that is good idea, we make sure system is kept stable and the packages has been tested enough, but in technologies like Ansible, which is still changing so rapidly, I recommend you to go ahead in your tests and get the latest version, that way you will also learn to use those latest versions, which have some modules usage differences. Lets see the version installed using apt in Raspbian. sudo apt list ansible pip3 install ansible --user Installing Ansible using the --user option, will make that the binary will be available directly under your user home, and not in your root bin directory (/bin,/usr/bin..) For that, I recommend you to add your $user_home/.local/bin to your PATH environment: Ansible Project Configuration Now that we have Ansible installed, let\u2019s set some basic configuration. Create a directory for our first project where we are going to set the different configuration files and Ansible playbooks mkdir Ansible First file we are going to create, is an Ansible configuration file. This will make sure we are using correct inventory file and some specific options for this project. In this case, we will use the inventory file in the local directory and will be connecting to the remote server as root. Additionally, will disable ssh-key check so we can connect to the servers without doing first ssh-key handshake (is a security risk, but will help us to destroy and deploy containers and VMs more rapidly in the future) Using --version attribute, will allow us to make sure we are suing correct configuration file: Create the inventory file with the list of hosts We can list all the hosts from our inventory\uff1a If we try the command ansible ping we will have errors, since we can not actually connect to our servers using SSH public keys. ansible all \u2013m ping and before that, we need to create a file called ping.yml. FAQ Q: What can I do with Super6C ? A: Home server (homelab) and cloud apps hosting. Learn Kubernetes, Docker Swarm, Serverless, Microservices on bare metal Cloud-native apps testing environment Learn concepts of distributed Machine Learning apps Prototype and learn cluster applications, parallel computing, and distributed computing concepts Host K8S, K3S, Minecraft, Plex, Owncloud, Nextcloud, Seafile, Minio, Tensorflow Q: Which Raspberry Pi models are compatible ? A: Super6C supports all Raspberry Pi CM4 with and without eMMC. Q: Does Raspberry Pi include compute modules ? A: No, the product only have cluster motherboard and power adapter. Q: From where Super6C boots OS ? A: You can boot the OS either from eMMC, SD Card or netboot. Q: Does each node get its own IP address? A: Yes Q: How the compute modelues communicate with each other ? A: The nodes interconnected with the onboard 1 Gbps switch. And, each node has 1Gbps speed. Q: Do all the slots need to be filled in ? A: The cluster works with any amount of nodes. You can start with a couple of nodes and scale when needed. Q: Can I flash compute modules through the board ? A:Yes, you can flash a compute module using a Micro USB cable. Q: How do the NIC, Ethernet, USB, HDMI, and audio ports work ? A: There are 2 USB-A an 2 USB 2.54 Pins on the board.They only connect to CM4 1$. The two HDMI ports are also the same. NIC \u2013 There is an 8-port gigabit switch on the board. Each port goes to each node plus one uplink. Two RJ45 out are from the switch. You can use them connect to other network device without extern switch. Q: Can Super6C function from either an ATX power supply 12V ? A: Yes. Q: Can I use this cluster io expansion board to just running my MySQL server? A: Yes, you can running not only MySQL server but also PostgreSQL, SQLite, Mongo DB and so on.","title":"DeskPi Super6C"},{"location":"super6c/#deskpi-super6c","text":"","title":"DeskPi Super6C"},{"location":"super6c/#purchase","text":"DeskPi Super6C","title":"Purchase"},{"location":"super6c/#description","text":"DeskPi Super6C is the Raspberry Pi cluster board a standard size mini-ITX board to be put in a case with up to 6 RPI CM4 Compute Modules. - For every CM4: * M.2 2280 slot (PCIe Gen 2 x1) * TF Card slot * 5V FAN Header * Micro USB 2.0 Only for 1st CM4: USB Host A 2.0 x2 USB Host 2.54 4-pins x2 HDMI 2.0 x1 HDMI 1.4a x1","title":"Description"},{"location":"super6c/#featrues","text":"","title":"Featrues"},{"location":"super6c/#package-includes","text":"1pcs Raspberry Pi CM4 Cluster Mini-ITX board. 1pcs 100W Power supply. Note: Raspberry Pi CM4 board are not included","title":"Package Includes:"},{"location":"super6c/#dimension","text":"170mm x 170mm x 21mm (Mini-ITX)","title":"Dimension"},{"location":"super6c/#applications","text":"Self-hosted: Host cloud applications locally or at the edge Learning Learning: Kubernetes, Docker, Serverless Development: Build cloud-native and CI/CD for ARM edge infrastructure Network-Attached Storage or Distributed Storage System :6 x ARM NAS node or CEPH node","title":"Applications"},{"location":"super6c/#software","text":"","title":"Software"},{"location":"super6c/#port-definitions","text":"1 x DC IN +12~24V 2 x RJ45 Gigabit Ethernet Port 1Gbps 2 x Full-Sized HDMI Ports 1 x Micro USB Port from CM4 1# (Flashing EEPROM) 2 x CM4 1# USB Host 2.0 6 x CM4 Activity LED 3 x Fan Pin Header 1 x Always ON switch","title":"Port definitions"},{"location":"super6c/#power-supply-specifications","text":"Recommended: SWITCHING ADAPTER Model: FJ-SW2025G1904730 INPUT: 100-240V~50/60Hz 2.0A Max OUTPUT\uff1a19.0V \u2248 4.73A\uff0c 89.87W","title":"Power Supply Specifications"},{"location":"super6c/#mechanical-drawing","text":"","title":"Mechanical Drawing"},{"location":"super6c/#block-scheme","text":"","title":"Block Scheme"},{"location":"super6c/#pin-headers-definitions","text":"CM4 Jumpers Functions LED definitions 4-Pin ATX Power Pins definitions 12V Pin and GND: Power button and Reset Button Distribution of Pins Note\uff1a J6: If you are using 9pin USB pins, it is more common for motherboards that support Pentium4 or athlon XP chipsets (such as i845D, i845E, SiS 650, etc.) to need to drop the pins. If a 10-pin type USB pin is used, such as i815, i815E, i815EP, KT133 and other chipset motherboards, this pin can be reserved, please refer to the motherboard manual for wiring. J27 : J27 Pin is the control programming interface for power management, which is directly used for internal production, DO NOT CONNECT!!! J11/J13 : PoE1/PoE2 Not available, DO NOT CONNECT!!!","title":"Pin Headers definitions"},{"location":"super6c/#how-to-install-cm4-module","text":"Please press the CM4 module onto Super6c mainboard as following picture. Attach the CM4 to the board by simply aligning it with the two connectors on the IO board, then give it a good squeeze. It\u2019ll crunch into place and you should be set. and if you have SSD drive, install it as following picture.","title":"How to install CM4 module"},{"location":"super6c/#how-to-flash-image-to-emmc-on-cm4-module","text":"Flashing the Compute Module eMMC The Compute Module has an on-board eMMC device connected to the primary SD card interface. This guide explains how to write data to the eMMC storage using a Compute Module IO board. Please also read the section in the Compute Module Datasheets Compute Module 4 Ensure the Compute Module is fitted correctly installed on the IO board. It should lie flat on the IO board. Make sure that nRPBOOT which is on J2 (disable eMMC Boot) on the board jumper is fitted Use a micro USB cable to connect the micro USB slave port MCRO_USB on board to the host device. Do not power up yet. For Windows Users Under Windows, an installer is available to install the required drivers and boot tool automatically. Alternatively, a user can compile and run it using Cygwin and/or install the drivers manually. Windows Installer For those who just want to enable the Compute Module eMMC as a mass storage device under Windows, the stand-alone installer is the recommended option. This installer has been tested on Windows 10 32-bit and 64-bit, and Windows XP 32-bit. Please ensure you are not writing to any USB devices whilst the installer is running. Download and run the Windows installer to install the drivers and boot tool. windows installer download URL Plug your host PC USB into the USB SLAVE port, making sure you have setup the board as described above. Apply power to the board; Windows should now find the hardware and install the driver. Once the driver installation is complete, run the RPiBoot.exe tool that was previously installed. After a few seconds, the Compute Module eMMC will pop up under Windows as a disk (USB mass storage device). Building rpiboot on your host system (Cygwin/Linux) We will be using Git to get the rpiboot source code, so ensure Git is installed. In Cygwin, use the Cygwin installer. On a Raspberry Pi or other Debian-based Linux machine, use the following command: sudo apt install git Git may produce an error if the date is not set correctly. On a Raspberry Pi, enter the following to correct this: sudo data MMDDhhmm where MM is the month, DD is the date, and hh and mm are hours and minutes respectively. Clone the usbboot tool repository: git clone --depth = 1 https://github.com/raspberrypi/usbboot cd usbboot libusb must be installed. If you are using Cygwin, please make sure libusb is installed as previously described. On Raspberry Pi OS or other Debian-based Linux, enter the following command: sudo apt install libusb-1.0-0-dev Now build and install the usbboot tool: make Run the usbboot tool and it will wait for a connection: sudo ./rpiboot Now plug the host machine into the Super6C USB slave port and power on. The rpiboot tool will discover the Compute Module and send boot code to allow access to the eMMC.","title":"How to Flash image to eMMC on CM4 module."},{"location":"super6c/#for-more-information-run","text":"Writing to the eMMC (Windows) After rpiboot completes, a new USB mass storage drive will appear in Windows. We recommend using Raspberry Pi Imager to write images to the drive. Make sure J2 (nRPBOOT) is set to the disabled position and/or nothing is plugged into the USB slave port. Power cycling the IO board should now result in the Compute Module booting from eMMC. Writing to the eMMC (Linux) After rpiboot completes, you will see a new device appear; this is commonly /dev/sda on a Raspberry Pi but it could be another location such as /dev/sdb, so check in /dev/ or run lsblk before running rpiboot so you can see what changes. You now need to write a raw OS image (such as Raspberry Pi OS) to the device. Note the following command may take some time to complete, depending on the size of the image: (Change /dev/sdX to the appropriate device.) sudo dd if = raw_os_image_of_your_choice.img of = /dev/sdX bs = 4MiB Once the image has been written, unplug and re-plug the USB; you should see two partitions appear (for Raspberry Pi OS) in /dev. In total, you should see something similar to this: /dev/sdX <- device /dev/sdX1 <- First partition ( FAT ) /dev/sdX2 <- Second partition ( Linux Filesystem ) The /dev/sdX1 and /dev/sdX2 partitions can now be mounted normally. Make sure J2 (nRPBOOT) is set to the disabled position and/or nothing is plugged into the USB slave port. Power cycling the board should now result in the Compute Module booting from eMMC.","title":"For more information run"},{"location":"super6c/#compute-module-4-bootloader","text":"The default bootloader configuration on CM4 is designed to support bring up and development on a Compute Module 4 IO board and the software version flashed at manufacture may be older than the latest release. For final products please consider: Selecting and verifying a specific bootloader release. The version in the usbboot repo is always a recent stable release. Configuring the boot device (e.g. network boot). See BOOT_ORDER section in the bootloader configuration guide. Enabling hardware write protection on the bootloader EEPROM to ensure that the bootloader can\u2019t be modified on remote/inaccessible products. N.B. The Compute Module 4 ROM never runs recovery.bin from SD/EMMC and the rpi-eeprom-update service is not enabled by default. This is necessary because the EMMC is not removable and an invalid recovery.bin file would prevent the system from booting. This can be overridden and used with self-update mode where the bootloader can be updated from USB MSD or Network boot. However, self-update mode is not an atomic update and therefore not safe in the event of a power failure whilst the EEPROM was being updated.","title":"Compute Module 4 Bootloader"},{"location":"super6c/#modifying-the-bootloader-configuration","text":"To modify the CM4 bootloader configuration: cd usbboot/recovery Replace pieeprom.original.bin if a specific bootloader release is required. Edit the default boot.conf bootloader configuration file. Typically, at least the BOOT_ORDER must be updated: For network boot BOOT_ORDER=0xf2 For SD/EMMC boot BOOT_ORDER=0xf1 For USB boot failing over to EMMC BOOT_ORDER=0xf15 Run ./update-pieeprom.sh to update the EEPROM image pieeprom.bin image file. If EEPROM write protection is required then edit config.txt and add eeprom_write_protect=1 . Hardware write-protection must be enabled via software and then locked by pulling the EEPROM_nWP pin low. Run ../rpiboot -d . to update the bootloader using the updated EEPROM image pieeprom.bin The pieeprom.bin file is now ready to be flashed to the Compute Module 4.","title":"Modifying the bootloader configuration"},{"location":"super6c/#flashing-the-bootloader-eeprom-compute-module-4","text":"To flash the bootloader EEPROM follow the same hardware setup as for flashing the EMMC but also ensure EEPROM_nWP is NOT pulled low. Once complete EEPROM_nWP may be pulled low again. # Writes recovery/pieeprom bin to the bootloader EEPROM. ./rpiboot -d recovery","title":"Flashing the bootloader EEPROM - Compute Module 4"},{"location":"super6c/#troubleshooting","text":"For a small percentage of Raspberry Pi Compute Module 3s, booting problems have been reported. We have traced these back to the method used to create the FAT32 partition; we believe the problem is due to a difference in timing between the BCM2835/6/7 and the newer eMMC devices. The following method of creating the partition is a reliable solution in our hands. sudo parted /dev/<device> ( parted ) mkpart primary fat32 4MiB 64MiB ( parted ) q sudo mkfs.vfat -F32 /dev/<device> sudo cp -r <files>/* <mountpoint> After Flash Raspberry Pi OS to eMMC on CM4 module, just power off the system, and one complete, 5 to go, just repeat those step five times. If your CM4 Module does not have eMMC on board, that will be easy, just flash Raspberry Pi OS to TF card or SSD drive, and insert them to card slot, fix it with screws. and connect the power supply, and press PWR_BTN button to power them on. If your CM4 module has eMMC on board, the SSD drive and TF card can be external mass storage.","title":"Troubleshooting"},{"location":"super6c/#how-to-build-your-own-cluster-and-manage-the-cluster-via-ansible","text":"","title":"How to build your own cluster and manage the cluster via Ansible"},{"location":"super6c/#fit-for-cm4-lite-version","text":"Note: The latest Raspberry Pi OS does not contain pi user and it may not need to add dtoverlay=dwc2,dr_mode=host to config.txt file on location /boot . Assume you are using the old version (Raspberry Pi OS 2021-11-08) CM4 Lite means Raspberry Pi Computer module come without a EMMC storage onboard.\u3000That means additional MicroSD card(TF card) is required.","title":"Fit for CM4 Lite version"},{"location":"super6c/#steps","text":"Download the latest Raspberry Pi OS 64bit image from: Download Image Unzip it and flash the .img file to TF card by using Etcher tool, which can be downloaded via Download flash tool Modify config.txt file in TF card and adding dtoverlay=dwc2,dr_mode=host to it and save it. (Do not need to execute this step if your using the latest version image) Before we unplug, now that your CM4 is fully flashed and ready to go, you\u2019ll be surprised to learn that the USB Ports are disabled by default. Yes, really. Remember, this is a board designed to be embedded elsewhere and not for consumer-level off-the-shelf use. In the \u201cboot\u201d folder, find the config.txt and add the following: dtoverlay = dwc2,dr_mode = host This will turn on the USB ports when you boot up, but if you accidentally keep the micro USB in, you will run into issues. Before you begin your first boot, make sure everything is unplugged. Boot and then plug in your mouse or keyboard. If you\u2019re like me and couldn\u2019t get a wi-fi version, this is where you\u2019ll plug in your dongle or ethernet cable. Create a new file named ssh on TF card /boot folder Insert TF card into card slot on Super6C board. Connect the power supply to DC Socket or Using ATX Power supply. (Max. 24V/6.15A) Connect Full-sized HDMI cable to super6C, Other head connect to your TV or Monitor. Connect Keyboard and mouse to USB2.0 port on board. Connect Ethernet cable to ETH1 to your Router. Press PWR_BTN button to booting up all of CM4 modules. Press Reset button will reset all of CM4 modules, unsaved file will be lost!!! Login to Raspberry pi username: pi default password: raspberry * Make sure your OS can access internet. Deploy ansible environments as following steps If you want to use Ansible to manage Raspberry Pi cluster, you need to upgrade python version from 3.7 to 3.8 as following steps: Remove old version python sudo apt remove ansible sudo apt purge \u2013y python2.7-minimal Update and upgrade system. sudo apt update sudo apt upgrade \u2013y Install dependencies. sudo apt-get install -y build-essential tk-dev libncurses5-dev \\ libncursesw5-dev libreadline6-dev libdb5.3-dev libgdbm-dev libsqlite3-dev \\ libssl-dev libbz2-dev libexpat1-dev liblzma-dev zlib1g-dev libffi-dev Download source code and compile it. version = 3 .8.5 wget https://www.python.org/ftp/python/ $version /Python- $version .tgz tar zxf Python- $version .tgz cd Python- $version ./configure --enable-optimizations make -j4 sudo make altinstall Do remember:\u3000Installs Python into /usr/local/bin Install ansible We can use apt or your particular distro package manager, but doing that, we risk no getting the latest version available. In some cases, I have to agree that is good idea, we make sure system is kept stable and the packages has been tested enough, but in technologies like Ansible, which is still changing so rapidly, I recommend you to go ahead in your tests and get the latest version, that way you will also learn to use those latest versions, which have some modules usage differences. Lets see the version installed using apt in Raspbian. sudo apt list ansible pip3 install ansible --user Installing Ansible using the --user option, will make that the binary will be available directly under your user home, and not in your root bin directory (/bin,/usr/bin..) For that, I recommend you to add your $user_home/.local/bin to your PATH environment:","title":"Steps:"},{"location":"super6c/#ansible-project-configuration","text":"Now that we have Ansible installed, let\u2019s set some basic configuration. Create a directory for our first project where we are going to set the different configuration files and Ansible playbooks mkdir Ansible First file we are going to create, is an Ansible configuration file. This will make sure we are using correct inventory file and some specific options for this project. In this case, we will use the inventory file in the local directory and will be connecting to the remote server as root. Additionally, will disable ssh-key check so we can connect to the servers without doing first ssh-key handshake (is a security risk, but will help us to destroy and deploy containers and VMs more rapidly in the future) Using --version attribute, will allow us to make sure we are suing correct configuration file: Create the inventory file with the list of hosts We can list all the hosts from our inventory\uff1a If we try the command ansible ping we will have errors, since we can not actually connect to our servers using SSH public keys. ansible all \u2013m ping and before that, we need to create a file called ping.yml.","title":"Ansible Project Configuration"},{"location":"super6c/#faq","text":"Q: What can I do with Super6C ? A: Home server (homelab) and cloud apps hosting. Learn Kubernetes, Docker Swarm, Serverless, Microservices on bare metal Cloud-native apps testing environment Learn concepts of distributed Machine Learning apps Prototype and learn cluster applications, parallel computing, and distributed computing concepts Host K8S, K3S, Minecraft, Plex, Owncloud, Nextcloud, Seafile, Minio, Tensorflow Q: Which Raspberry Pi models are compatible ? A: Super6C supports all Raspberry Pi CM4 with and without eMMC. Q: Does Raspberry Pi include compute modules ? A: No, the product only have cluster motherboard and power adapter. Q: From where Super6C boots OS ? A: You can boot the OS either from eMMC, SD Card or netboot. Q: Does each node get its own IP address? A: Yes Q: How the compute modelues communicate with each other ? A: The nodes interconnected with the onboard 1 Gbps switch. And, each node has 1Gbps speed. Q: Do all the slots need to be filled in ? A: The cluster works with any amount of nodes. You can start with a couple of nodes and scale when needed. Q: Can I flash compute modules through the board ? A:Yes, you can flash a compute module using a Micro USB cable. Q: How do the NIC, Ethernet, USB, HDMI, and audio ports work ? A: There are 2 USB-A an 2 USB 2.54 Pins on the board.They only connect to CM4 1$. The two HDMI ports are also the same. NIC \u2013 There is an 8-port gigabit switch on the board. Each port goes to each node plus one uplink. Two RJ45 out are from the switch. You can use them connect to other network device without extern switch. Q: Can Super6C function from either an ATX power supply 12V ? A: Yes. Q: Can I use this cluster io expansion board to just running my MySQL server? A: Yes, you can running not only MySQL server but also PostgreSQL, SQLite, Mongo DB and so on.","title":"FAQ"},{"location":"supportos/","text":"Getting Start . For order please visit: DeskPi.com . Supported OS Raspbian OS - 32bit version: 2020-08-12 Raspberry Pi OS . Ubuntu-mate OS - 32bit version:20.04.1-desktop--armhf+raspi Ubuntu mate 20.04 LTS 32Bit . Manjaro OS - 32bit verison: 20.2 Manjaro XFCE 20.2 Kali-linux-arm OS - 32bit version: 2020.4 Kali Linux RaspberryPi 2, 3, 4 and 400 . Unsupport OS For Windows IoT OS Unsupported due to lacking of driver. Testing version: Midnight falcon","title":"Supportos"},{"location":"supportos/#getting-start","text":". For order please visit: DeskPi.com .","title":"Getting Start"},{"location":"supportos/#supported-os","text":"Raspbian OS - 32bit version: 2020-08-12 Raspberry Pi OS . Ubuntu-mate OS - 32bit version:20.04.1-desktop--armhf+raspi Ubuntu mate 20.04 LTS 32Bit . Manjaro OS - 32bit verison: 20.2 Manjaro XFCE 20.2 Kali-linux-arm OS - 32bit version: 2020.4 Kali Linux RaspberryPi 2, 3, 4 and 400 .","title":"Supported OS"},{"location":"supportos/#unsupport-os","text":"","title":"Unsupport OS"},{"location":"supportos/#for-windows-iot-os","text":"Unsupported due to lacking of driver. Testing version: Midnight falcon","title":"For Windows IoT OS"},{"location":"uninstall/","text":"Getting Start . For order please visit: DeskPi.com . How to Uninstall deskpi DeskPi-uninstall And then select the number against to your OS Type.","title":"Uninstall"},{"location":"uninstall/#getting-start","text":". For order please visit: DeskPi.com .","title":"Getting Start"},{"location":"uninstall/#how-to-uninstall-deskpi","text":"DeskPi-uninstall And then select the number against to your OS Type.","title":"How to Uninstall deskpi"},{"location":"usbboot/","text":"Getting Start . For order please visit: DeskPi.com . How to boot from USB SSD/HDD? After initial Raspberry Pi Configuration and once you have Internet Connectivity established, Install the DeskPi Pro Utilities from https://github.com/DeskPi-Team/deskpi.git Open a Terminal / Console and run the following commands: sudo apt update sudo apt full-upgrade sudo rpi-update When complete, run: sudo reboot Upon reboot, open Terminal again: sudo raspi-config * go to Advanced Options * Select Boot Order, select #1 USB Boot , Return to Advanced Options, * Select Boot Loader Version, choose Latest Version * Save & exit Reboot again (to restart with new settings) sudo reboot After reboot, re-open Terminal again sudo -E rpi-eeprom-config --edit \u2022 do not change anything, it is unnecessary \u2022 press Ctrl-X to save, answer Y to overwrite file. sudo reboot Now you are ready to install Raspberry-OS onto your USB Boot Device. You can use the Raspberry Imager from www.raspberrypi.org website. Depending on device the new SD Card Copier can transfer the SD-Card image to the USB Device (ensure you select generate a new UUID). Once your USB drive is imaged & ready to boot, shutdown your Deskpi-Pro, remove the SD-Card and power-up to boot from the USB Boot drive, once running & configured you can install your additional software and proceed as usual.","title":"Usbboot"},{"location":"usbboot/#getting-start","text":". For order please visit: DeskPi.com .","title":"Getting Start"},{"location":"usbboot/#how-to-boot-from-usb-ssdhdd","text":"After initial Raspberry Pi Configuration and once you have Internet Connectivity established, Install the DeskPi Pro Utilities from https://github.com/DeskPi-Team/deskpi.git Open a Terminal / Console and run the following commands: sudo apt update sudo apt full-upgrade sudo rpi-update When complete, run: sudo reboot Upon reboot, open Terminal again: sudo raspi-config * go to Advanced Options * Select Boot Order, select #1 USB Boot , Return to Advanced Options, * Select Boot Loader Version, choose Latest Version * Save & exit","title":"How to boot from USB SSD/HDD?"},{"location":"usbboot/#reboot-again-to-restart-with-new-settings","text":"sudo reboot After reboot, re-open Terminal again sudo -E rpi-eeprom-config --edit \u2022 do not change anything, it is unnecessary \u2022 press Ctrl-X to save, answer Y to overwrite file. sudo reboot Now you are ready to install Raspberry-OS onto your USB Boot Device. You can use the Raspberry Imager from www.raspberrypi.org website. Depending on device the new SD Card Copier can transfer the SD-Card image to the USB Device (ensure you select generate a new UUID). Once your USB drive is imaged & ready to boot, shutdown your Deskpi-Pro, remove the SD-Card and power-up to boot from the USB Boot drive, once running & configured you can install your additional software and proceed as usual.","title":"Reboot again (to restart with new settings)"}]}