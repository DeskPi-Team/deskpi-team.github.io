{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"DeskPi Series Product Wiki Here you can provide product descriptions, product features, product documents, product application cases and some common problem solutions of DeskPi series products, and also provide some Demo code file downloads. Product List DeskPi Series DeskPi Lite Nas Case DP-0020 DeskPi Mini PC DP-0019 DeskPi Lite Expansion Kit DP-0018 DeskPi Pro DP-0001 DeskPi Nano DP-0002 DeskPi Lite DP-0009 DeskPi Super6C DP-0008 DeskPi ITX Case kit for Super6C DP-0010 PicoMate Series PicoMate DP-0012 : PicoMate with Pico W DP-0014 : PicoMate with Pico DP-0015 Buy from DeskPi Official Website","title":"Home"},{"location":"#deskpi-series-product-wiki","text":"Here you can provide product descriptions, product features, product documents, product application cases and some common problem solutions of DeskPi series products, and also provide some Demo code file downloads.","title":"DeskPi Series Product Wiki"},{"location":"#product-list","text":"","title":"Product List"},{"location":"#deskpi-series","text":"DeskPi Lite Nas Case DP-0020 DeskPi Mini PC DP-0019 DeskPi Lite Expansion Kit DP-0018 DeskPi Pro DP-0001 DeskPi Nano DP-0002 DeskPi Lite DP-0009 DeskPi Super6C DP-0008 DeskPi ITX Case kit for Super6C DP-0010","title":"DeskPi Series"},{"location":"#picomate-series","text":"PicoMate DP-0012 : PicoMate with Pico W DP-0014 : PicoMate with Pico DP-0015 Buy from DeskPi Official Website","title":"PicoMate Series"},{"location":"deskpi_lite_for_3b/","text":"DeskPi Lite for Raspberry Pi 3B/3B+ Description Introducing the DeskPi Lite for Raspberry Pi 3B/3B+ - a sleek and efficient ABS case designed specifically for Raspberry Pi 3B/3B+ users. With a built-in mainboard, this case helps consolidate the MicroUSB, HDMI port, and 3.5mm audio jack to the back, making cable management a breeze. The package includes a PWM adjustable speed fan and an aluminum heatsink for optimal thermal performance. The DeskPi Lite combines effective heat dissipation with a stylish design, making it the perfect addition to your Raspberry Pi setup. Purchase DeskPi Lite Features Easy-to-assemble ABS enclosure PWM signal adjustable speed fan for optimal Cooling Convenient cable management with rear-facing MicroUSB, HDMI port, and 3.5mm audio jack LED indicator shield for enhanced visual appeal Mounting hole support for versatile installation options Elegant desktop-set style design Gallery Fast Cooling Port Definitions Anti-slipper rubber feet How to assemble Step 1 Step 2 Package includes 1 x DeskPi Lite for Raspberry Pi 3B/3B+ 1 x PWM adjustable speed fan with aluminum heatsink 4 x Thermal pad for improved heat transfer 2 x M.2 screws for securing the aluminum heatsink 1 x Transparent plastic shield for the LED indicator How to cut off the power safely? After safe shutdown your Linux system by typing this command: sudo init 0 and Long press the power button until the LED color on power button from Blue turn to Red . How to enable fan temperature control? NOTE: Raspberry Pi OS (Latest) will support this function. Open a terminal and typing following command: sudo raspi-config Navigate to Performance Options -> P4 Fan -> Yes -> 14 -> 60 -> yes -> finish -> reboot Raspberry Pi. The fan is support PWM signal control via GPIO14 which is physical pin 12 (TXD), it will spinning when the CPU temperature is above 60 degree. and also you can write your code to control the fan via GPIO14 , sending PWM signal will trigger the fan spinning. How to control fan speed by sending PWM signal? Create a python file and paste following demo code into it. #!/usr/bin/python3 import RPi.GPIO as GPIO import time import subprocess GPIO . setmode ( GPIO . BCM ) GPIO . setup ( 14 , GPIO . OUT ) pwm = GPIO . PWM ( 14 , 100 ) print ( \" \\n Press Ctrl+C to quit \\n \" ) dc = 0 pwm . start ( dc ) try : while True : temp = subprocess . getoutput ( \"vcgencmd measure_temp|sed 's/[^0-9.]//g'\" ) if round ( float ( temp )) >= 45 : dc = 100 pwm . ChangeDutyCycle ( dc ) print ( \"CPU Temp:\" , float ( temp ), \" Fan duty cycle:\" , dc ) time . sleep ( 180.0 ) if round ( float ( temp )) >= 40 : dc = 85 pwm . ChangeDutyCycle ( dc ) print ( \"CPU Temp:\" , float ( temp ), \" Fan duty cycle:\" , dc ) time . sleep ( 120.0 ) else : dc = 70 pwm . ChangeDutyCycle ( dc ) print ( \"CPU Temp:\" , float ( temp ), \" Fan duty cycle:\" , dc ) time . sleep ( 60.00 ) except KeyboardInterrupt : pwm . stop () GPIO . cleanup () print ( \"Ctrl + C pressed -- Ending program\" ) Then execute it: python3 fan_control.py FAQ Q: Can I power off it by double clicking the power button? A: No, It can not send power off signal by adding dtoverlay=dwc2,dr_mode=host to enable otg mode on microUSB port on Raspberry Pi 3B/3B+, it can only cut off power by pressing the power button until the LED indicator turns from blue to red , it just cut off the power supply from power source to Raspberry Pi.","title":"DeskPi Lite For Raspberry Pi 3B/3B+"},{"location":"deskpi_lite_for_3b/#deskpi-lite-for-raspberry-pi-3b3b","text":"","title":"DeskPi Lite for Raspberry Pi 3B/3B+"},{"location":"deskpi_lite_for_3b/#description","text":"Introducing the DeskPi Lite for Raspberry Pi 3B/3B+ - a sleek and efficient ABS case designed specifically for Raspberry Pi 3B/3B+ users. With a built-in mainboard, this case helps consolidate the MicroUSB, HDMI port, and 3.5mm audio jack to the back, making cable management a breeze. The package includes a PWM adjustable speed fan and an aluminum heatsink for optimal thermal performance. The DeskPi Lite combines effective heat dissipation with a stylish design, making it the perfect addition to your Raspberry Pi setup.","title":"Description"},{"location":"deskpi_lite_for_3b/#purchase","text":"DeskPi Lite","title":"Purchase"},{"location":"deskpi_lite_for_3b/#features","text":"Easy-to-assemble ABS enclosure PWM signal adjustable speed fan for optimal Cooling Convenient cable management with rear-facing MicroUSB, HDMI port, and 3.5mm audio jack LED indicator shield for enhanced visual appeal Mounting hole support for versatile installation options Elegant desktop-set style design","title":"Features"},{"location":"deskpi_lite_for_3b/#gallery","text":"Fast Cooling Port Definitions Anti-slipper rubber feet","title":"Gallery"},{"location":"deskpi_lite_for_3b/#how-to-assemble","text":"Step 1 Step 2","title":"How to assemble"},{"location":"deskpi_lite_for_3b/#package-includes","text":"1 x DeskPi Lite for Raspberry Pi 3B/3B+ 1 x PWM adjustable speed fan with aluminum heatsink 4 x Thermal pad for improved heat transfer 2 x M.2 screws for securing the aluminum heatsink 1 x Transparent plastic shield for the LED indicator","title":"Package includes"},{"location":"deskpi_lite_for_3b/#how-to-cut-off-the-power-safely","text":"After safe shutdown your Linux system by typing this command: sudo init 0 and Long press the power button until the LED color on power button from Blue turn to Red .","title":"How to cut off the power safely?"},{"location":"deskpi_lite_for_3b/#how-to-enable-fan-temperature-control","text":"NOTE: Raspberry Pi OS (Latest) will support this function. Open a terminal and typing following command: sudo raspi-config Navigate to Performance Options -> P4 Fan -> Yes -> 14 -> 60 -> yes -> finish -> reboot Raspberry Pi. The fan is support PWM signal control via GPIO14 which is physical pin 12 (TXD), it will spinning when the CPU temperature is above 60 degree. and also you can write your code to control the fan via GPIO14 , sending PWM signal will trigger the fan spinning.","title":"How to enable fan temperature control?"},{"location":"deskpi_lite_for_3b/#how-to-control-fan-speed-by-sending-pwm-signal","text":"Create a python file and paste following demo code into it. #!/usr/bin/python3 import RPi.GPIO as GPIO import time import subprocess GPIO . setmode ( GPIO . BCM ) GPIO . setup ( 14 , GPIO . OUT ) pwm = GPIO . PWM ( 14 , 100 ) print ( \" \\n Press Ctrl+C to quit \\n \" ) dc = 0 pwm . start ( dc ) try : while True : temp = subprocess . getoutput ( \"vcgencmd measure_temp|sed 's/[^0-9.]//g'\" ) if round ( float ( temp )) >= 45 : dc = 100 pwm . ChangeDutyCycle ( dc ) print ( \"CPU Temp:\" , float ( temp ), \" Fan duty cycle:\" , dc ) time . sleep ( 180.0 ) if round ( float ( temp )) >= 40 : dc = 85 pwm . ChangeDutyCycle ( dc ) print ( \"CPU Temp:\" , float ( temp ), \" Fan duty cycle:\" , dc ) time . sleep ( 120.0 ) else : dc = 70 pwm . ChangeDutyCycle ( dc ) print ( \"CPU Temp:\" , float ( temp ), \" Fan duty cycle:\" , dc ) time . sleep ( 60.00 ) except KeyboardInterrupt : pwm . stop () GPIO . cleanup () print ( \"Ctrl + C pressed -- Ending program\" ) Then execute it: python3 fan_control.py","title":"How to control fan speed by sending PWM signal?"},{"location":"deskpi_lite_for_3b/#faq","text":"Q: Can I power off it by double clicking the power button? A: No, It can not send power off signal by adding dtoverlay=dwc2,dr_mode=host to enable otg mode on microUSB port on Raspberry Pi 3B/3B+, it can only cut off power by pressing the power button until the LED indicator turns from blue to red , it just cut off the power supply from power source to Raspberry Pi.","title":"FAQ"},{"location":"deskpi_lite_nas_case/","text":"DeskPi Lite NAS Case Description The DeskPi Lite NAS is an ABS case with an integrated M.2 SATA SSD expansion board, a cooling heatsink, and a PWM signal controlled fan. This case provides reliable protection for your NAS components, efficient heat dissipation, and the flexibility to adjust fan speed according to your requirements. It is a practical and functional solution for expanding storage capacity while maintaining optimal performance in your NAS system. Purchase DeskPi Lite NAS Case Product Features ABS Case: The DeskPi Lite NAS features a sturdy ABS (Acrylonitrile Butadiene Styrene) case that provides durability and protection for your M.2 SATA SSD expansion board and other internal components. ABS is known for its strength and impact resistance, making it an ideal material for this type of case. M.2 SATA SSD Expansion Board: The case is designed with an integrated M.2 SATA SSD expansion board, allowing you to easily install and securely mount an M.2 SATA SSD. This expansion board provides additional storage capacity for your NAS setup, enhancing its versatility and performance. Cooling Heatsink: To maintain optimal operating temperatures for the M.2 SATA SSD and other components, the DeskPi Lite NAS incorporates a cooling heatsink. The heatsink efficiently dissipates heat generated during extended operation, preventing overheating and ensuring the reliable performance of your NAS system. PWM Signal Controlled Fan: The cooling heatsink is accompanied by a PWM (Pulse Width Modulation) signal controlled fan. This fan is capable of dynamically adjusting its rotational speed based on temperature requirements. By monitoring the system temperature, the fan can automatically increase or decrease its speed to provide effective cooling while minimizing noise levels. Adjustable Fan Speed: The PWM signal controlled fan allows you to adjust the fan speed manually, providing flexibility in balancing cooling performance and noise levels according to your preferences. This feature enables you to optimize the cooling efficiency of your DeskPi Lite NAS while maintaining a quieter environment. Efficient Airflow: The combination of the cooling heatsinks and the PWM signal controlled fan ensures efficient airflow within the case. This airflow helps to dissipate heat effectively, keeping the M.2 SATA SSD and other components within the optimal temperature range, even during demanding usage scenarios. Easy Installation: The DeskPi Lite NAS is designed for straightforward installation. It typically includes all the necessary mounting hardware and connectors, making it easy to assemble and integrate with your existing NAS setup. M.2 SATA SSD Adapter board ( Support M.2 SATA SSD B-KEY Only ) Note: M.2 SATA SSD drive and Raspberry Pi 4B does not included in the package, additional purchase required. Compatibility Raspberry Pi 4 model B Only Box Content 1 x DeskPi Lite NAS Case 1 x M.2 to SATA SSD adapter board 1 x USB3.1 Connector 1 x Instruction Manual 2 x M2x7+6mm Copper pillar (For fixing Heatsink) 6 x M2x7+4mm Copper pillar (For fixing M.2 SATA SSD Adapter board) 6 x M2x10+4mm Copper pillar (For fixing DeskPi Lite daughter board 6 x M2x12 Black Long screw(For fixing whole case) 4 x Thermal pad Gallery Package Includes Dimension Port definitions Inside Outside M.2 SATA SSD only Please NOTE following figure, it's very important! LED indicator Meaning Red : Power on Green : Disk activity status About PWM adjustable Fan NOTE: Please read following note carefully!!! How to Assemble it Open your DeskPi Lite, remove ABS bottom case. Fix M2x7+6mm copper pillar to those two positon to keep heatsink steady Fix another two hole with M2x7+4mm copper pillar. Fix M.2 SATA SSD drive to M.2 SATA SSD adapter board with flat head screw. Fix the M.2 SATA SSD adapter board to Raspberry Pi with M2x7+4mm copper pillar.\uff08Make sure the copper pogo-pin contact well with GPIO soldering point.\uff09 Fix DeskPi Lite daughter board and upper case with M2x10+4 copper pillar Fix bottom case with screws. Connect the USB3.0 connector on the back of DeskPi Lite on USB3.0 Port. Assemble Figure Step 1 Step 2 Breakout view * Please note that copper pillars type and make sure using the right one. How to configure M.2 SATA SSD Connect HDMI cable to HDMI port, Power supply to USB-C port and then connect the mouse and USB keyboard to DeskPi lite, Press power button and waiting for system booting up, log into system and open a terminal. Check if the M.2 SATA SSD has been recognized. Typing: lsblk You should see there is one disk called \u201csda\u201d, that\u2019s your M.2 SATA SSD drive. Parted and format partition sudo fdisk /dev/sda press n for new partition, and then press p for primary partition, press 1 means first partition, and then press twice enter , make the whole disk as one partition, press w to write the partition table to disk and press q to quit. sudo partprobe /dev/sda sudo mkfs.ext4 /dev/sda1 # format the disk to ext4 filesystem. Mount Disk drive and upload file mkdir /home/pi/mydisk # make a mounting point sudo mount -t ext4 /dev/sda1 /home/pi/mydisk #Mount disk to mounting point sudo chmod 777 /home/pi/mydisk # grant user to access and write permisions. sudo chown -R pi:pi /home/pi/mydisk # grant user pi to take ownership of the folder. That\u2019s it. You can also build your own samba server to hold the disk to share with your family or your friends in your local area network (LAN). How to enable adjustable speed fan Press Ctrl+T or click terminal Icon to open a terminal and typing: sudo raspi-config Navigate to 4 Performance Options : and navigate to P4 Fan and select YES. Keep 14 as default. select yes , input a temperature in degrees should the fan turn on, Recommend setting to 60 degree. select yes and reboot your Raspberry Pi. If you are using other OS on Raspberry Pi, please refer to how to generate PWM signal in your OS. Here is a demo code, it will help you to control the fan speed according to the temperature of CPU. Demo code of fan control #File Name: fan_control.py #!/usr/bin/python3 import RPi.GPIO as GPIO import time import subprocess GPIO . setmode ( GPIO . BCM ) GPIO . setwarnings ( False ) GPIO . setup ( 14 , GPIO . OUT ) pwm = GPIO . PWM ( 14 , 100 ) print ( \" \\n Press Ctrl+C to quit \\n \" ) dc = 0 pwm . start ( dc ) try : while True : temp = subprocess . getoutput ( \"vcgencmd measure_temp|sed 's/[^0-9.]//g'\" ) if round ( float ( temp )) >= 45 : dc = 100 pwm . ChangeDutyCycle ( dc ) print ( \"CPU Temp:\" , float ( temp ), \" Fan duty cycle:\" , dc ) time . sleep ( 180.0 ) if round ( float ( temp )) >= 40 : dc = 85 pwm . ChangeDutyCycle ( dc ) print ( \"CPU Temp:\" , float ( temp ), \" Fan duty cycle:\" , dc ) time . sleep ( 120.0 ) else : dc = 70 pwm . ChangeDutyCycle ( dc ) print ( \"CPU Temp:\" , float ( temp ), \" Fan duty cycle:\" , dc ) time . sleep ( 60.00 ) except KeyboardInterrupt : pwm . stop () GPIO . cleanup () print ( \"Ctrl + C pressed -- Ending program\" ) Save it and execute it in a terminal: python3 fan_control.py Keywords DeskPi Lite M.2 SATA SSD Expansion kit, DeskPi Lite expansion board, M.2 SATA SSD driver board for DeskPi Lite.","title":"DeskPi Lite NAS Case"},{"location":"deskpi_lite_nas_case/#deskpi-lite-nas-case","text":"","title":"DeskPi Lite NAS Case"},{"location":"deskpi_lite_nas_case/#description","text":"The DeskPi Lite NAS is an ABS case with an integrated M.2 SATA SSD expansion board, a cooling heatsink, and a PWM signal controlled fan. This case provides reliable protection for your NAS components, efficient heat dissipation, and the flexibility to adjust fan speed according to your requirements. It is a practical and functional solution for expanding storage capacity while maintaining optimal performance in your NAS system.","title":"Description"},{"location":"deskpi_lite_nas_case/#purchase","text":"DeskPi Lite NAS Case","title":"Purchase"},{"location":"deskpi_lite_nas_case/#product-features","text":"ABS Case: The DeskPi Lite NAS features a sturdy ABS (Acrylonitrile Butadiene Styrene) case that provides durability and protection for your M.2 SATA SSD expansion board and other internal components. ABS is known for its strength and impact resistance, making it an ideal material for this type of case. M.2 SATA SSD Expansion Board: The case is designed with an integrated M.2 SATA SSD expansion board, allowing you to easily install and securely mount an M.2 SATA SSD. This expansion board provides additional storage capacity for your NAS setup, enhancing its versatility and performance. Cooling Heatsink: To maintain optimal operating temperatures for the M.2 SATA SSD and other components, the DeskPi Lite NAS incorporates a cooling heatsink. The heatsink efficiently dissipates heat generated during extended operation, preventing overheating and ensuring the reliable performance of your NAS system. PWM Signal Controlled Fan: The cooling heatsink is accompanied by a PWM (Pulse Width Modulation) signal controlled fan. This fan is capable of dynamically adjusting its rotational speed based on temperature requirements. By monitoring the system temperature, the fan can automatically increase or decrease its speed to provide effective cooling while minimizing noise levels. Adjustable Fan Speed: The PWM signal controlled fan allows you to adjust the fan speed manually, providing flexibility in balancing cooling performance and noise levels according to your preferences. This feature enables you to optimize the cooling efficiency of your DeskPi Lite NAS while maintaining a quieter environment. Efficient Airflow: The combination of the cooling heatsinks and the PWM signal controlled fan ensures efficient airflow within the case. This airflow helps to dissipate heat effectively, keeping the M.2 SATA SSD and other components within the optimal temperature range, even during demanding usage scenarios. Easy Installation: The DeskPi Lite NAS is designed for straightforward installation. It typically includes all the necessary mounting hardware and connectors, making it easy to assemble and integrate with your existing NAS setup. M.2 SATA SSD Adapter board ( Support M.2 SATA SSD B-KEY Only ) Note: M.2 SATA SSD drive and Raspberry Pi 4B does not included in the package, additional purchase required.","title":"Product Features"},{"location":"deskpi_lite_nas_case/#compatibility","text":"Raspberry Pi 4 model B Only","title":"Compatibility"},{"location":"deskpi_lite_nas_case/#box-content","text":"1 x DeskPi Lite NAS Case 1 x M.2 to SATA SSD adapter board 1 x USB3.1 Connector 1 x Instruction Manual 2 x M2x7+6mm Copper pillar (For fixing Heatsink) 6 x M2x7+4mm Copper pillar (For fixing M.2 SATA SSD Adapter board) 6 x M2x10+4mm Copper pillar (For fixing DeskPi Lite daughter board 6 x M2x12 Black Long screw(For fixing whole case) 4 x Thermal pad","title":"Box Content"},{"location":"deskpi_lite_nas_case/#gallery","text":"Package Includes Dimension Port definitions Inside Outside M.2 SATA SSD only Please NOTE following figure, it's very important!","title":"Gallery"},{"location":"deskpi_lite_nas_case/#led-indicator-meaning","text":"Red : Power on Green : Disk activity status","title":"LED indicator Meaning"},{"location":"deskpi_lite_nas_case/#about-pwm-adjustable-fan","text":"NOTE: Please read following note carefully!!!","title":"About PWM adjustable Fan"},{"location":"deskpi_lite_nas_case/#how-to-assemble-it","text":"Open your DeskPi Lite, remove ABS bottom case. Fix M2x7+6mm copper pillar to those two positon to keep heatsink steady Fix another two hole with M2x7+4mm copper pillar. Fix M.2 SATA SSD drive to M.2 SATA SSD adapter board with flat head screw. Fix the M.2 SATA SSD adapter board to Raspberry Pi with M2x7+4mm copper pillar.\uff08Make sure the copper pogo-pin contact well with GPIO soldering point.\uff09 Fix DeskPi Lite daughter board and upper case with M2x10+4 copper pillar Fix bottom case with screws. Connect the USB3.0 connector on the back of DeskPi Lite on USB3.0 Port.","title":"How to Assemble it"},{"location":"deskpi_lite_nas_case/#assemble-figure","text":"Step 1 Step 2","title":"Assemble Figure"},{"location":"deskpi_lite_nas_case/#breakout-view","text":"* Please note that copper pillars type and make sure using the right one.","title":"Breakout view"},{"location":"deskpi_lite_nas_case/#how-to-configure-m2-sata-ssd","text":"Connect HDMI cable to HDMI port, Power supply to USB-C port and then connect the mouse and USB keyboard to DeskPi lite, Press power button and waiting for system booting up, log into system and open a terminal. Check if the M.2 SATA SSD has been recognized. Typing: lsblk You should see there is one disk called \u201csda\u201d, that\u2019s your M.2 SATA SSD drive. Parted and format partition sudo fdisk /dev/sda press n for new partition, and then press p for primary partition, press 1 means first partition, and then press twice enter , make the whole disk as one partition, press w to write the partition table to disk and press q to quit. sudo partprobe /dev/sda sudo mkfs.ext4 /dev/sda1 # format the disk to ext4 filesystem. Mount Disk drive and upload file mkdir /home/pi/mydisk # make a mounting point sudo mount -t ext4 /dev/sda1 /home/pi/mydisk #Mount disk to mounting point sudo chmod 777 /home/pi/mydisk # grant user to access and write permisions. sudo chown -R pi:pi /home/pi/mydisk # grant user pi to take ownership of the folder. That\u2019s it. You can also build your own samba server to hold the disk to share with your family or your friends in your local area network (LAN).","title":"How to configure M.2 SATA SSD"},{"location":"deskpi_lite_nas_case/#how-to-enable-adjustable-speed-fan","text":"Press Ctrl+T or click terminal Icon to open a terminal and typing: sudo raspi-config Navigate to 4 Performance Options : and navigate to P4 Fan and select YES. Keep 14 as default. select yes , input a temperature in degrees should the fan turn on, Recommend setting to 60 degree. select yes and reboot your Raspberry Pi. If you are using other OS on Raspberry Pi, please refer to how to generate PWM signal in your OS. Here is a demo code, it will help you to control the fan speed according to the temperature of CPU.","title":"How to enable adjustable speed fan"},{"location":"deskpi_lite_nas_case/#demo-code-of-fan-control","text":"#File Name: fan_control.py #!/usr/bin/python3 import RPi.GPIO as GPIO import time import subprocess GPIO . setmode ( GPIO . BCM ) GPIO . setwarnings ( False ) GPIO . setup ( 14 , GPIO . OUT ) pwm = GPIO . PWM ( 14 , 100 ) print ( \" \\n Press Ctrl+C to quit \\n \" ) dc = 0 pwm . start ( dc ) try : while True : temp = subprocess . getoutput ( \"vcgencmd measure_temp|sed 's/[^0-9.]//g'\" ) if round ( float ( temp )) >= 45 : dc = 100 pwm . ChangeDutyCycle ( dc ) print ( \"CPU Temp:\" , float ( temp ), \" Fan duty cycle:\" , dc ) time . sleep ( 180.0 ) if round ( float ( temp )) >= 40 : dc = 85 pwm . ChangeDutyCycle ( dc ) print ( \"CPU Temp:\" , float ( temp ), \" Fan duty cycle:\" , dc ) time . sleep ( 120.0 ) else : dc = 70 pwm . ChangeDutyCycle ( dc ) print ( \"CPU Temp:\" , float ( temp ), \" Fan duty cycle:\" , dc ) time . sleep ( 60.00 ) except KeyboardInterrupt : pwm . stop () GPIO . cleanup () print ( \"Ctrl + C pressed -- Ending program\" ) Save it and execute it in a terminal: python3 fan_control.py","title":"Demo code of fan control"},{"location":"deskpi_lite_nas_case/#keywords","text":"DeskPi Lite M.2 SATA SSD Expansion kit, DeskPi Lite expansion board, M.2 SATA SSD driver board for DeskPi Lite.","title":"Keywords"},{"location":"deskpilite/","text":"DeskPi Lite (deskpi_v1) Description The DeskPi V1 Case is a case made of ABS, and an adapter board is provided inside to transfer the HDMI interface, 3.5mm audio interface, and USB-C power interface of the Raspberry Pi to the back of the panel. and offer microHDMI to Full-sized HDMI interface, makes it convenient for users to use standard HDMI cables to connect external display devices. In addition, it provides an ultra-thin aluminum alloy heat sink and supports an adjustable-speed ultra-thin silent fan, which can be safely cut off Power supply for Raspberry Pi by sending a \"power_off\" signal to the adapter board. Purchase DeskPi Lite Features Convert the microHDMI to a Full-sized HDMI interface and place it on the back of the panel with the power interface Transfer 3.5mm audio interface to the back of the panel Support Raspberry Pi official fan temperature control function via raspi-config tool. Support system shutdown to safe cut off power on Raspberry Pi Support adjustable fan speed via PWM programming. Light weight heat-sink inside. Adjustable speed Fan Gallery Features Easy to install Expansion of 2 USB Ports Fast Cooling GPIO Interface Protect Non-Slip Rubber feet Port definitions Package includes 1 x DeskPi Lite Case (Plastic) 1 x CNC alloy aluminum heat sink with PWM fan and GPIO expansion board 1 x Port adapter board 1 x Instructions 6 x Thermal Pads 2 x LED indicator lampshade 2 x M2.5 Screw Working Principle RPi -> sending poweroff to /dev/ttyUSB0 means sending cut off power -> MCU on board: means MCU will cut of power of Raspberry Pi. RPi <- Reading poweroff from /dev/ttyUSB0 means shutdown system <- MCU on board: system will execute shutdown service or reboot (according to scripts definitions) when power button has been pressed twice. How to enable fan temperature control? NOTE: Raspberry Pi OS (Latest) will support this function. Open a terminal and typing following command: sudo raspi-config Navigate to Performance Options -> P4 Fan -> Yes -> 14 -> 60 -> yes -> finish -> reboot Raspberry Pi. The fan is support PWM signal control via GPIO14 which is physical pin 12 (TXD), it will spinning when the CPU temperature is above 60 degree. and also you can write your code to control the fan via GPIO14 , sending PWM signal will trigger the fan spinning. This case hardware uses direct GPIO header connections for the included PWM capable fan. Like in your bigger DeskPi case software, you could easily change from a /dev/ttyUSB0 to a GPIO PWM fan control service. For anyone else wanting to implement some form of PWM fan control, please see the included python3 script code below. This will enable: < 40'c - Fan 75%, for a minimum of 60sec 40'c to 45'c - Fan 85%, for a minimum of 120sec > 45'c - Fan 100%, for a minimum of 180sec In everyday use, this script offers good temperatrue control, with the CPU temp rarely reaches > 45'c and general fan noise is very low and still keeps good control via the PWM fan vs standard Raspberry Pi OS PWM fan control via /boot/config.txt or raspi-config. #!/usr/bin/python3 import RPi.GPIO as GPIO import time import subprocess GPIO . setmode ( GPIO . BCM ) GPIO . setup ( 14 , GPIO . OUT ) pwm = GPIO . PWM ( 14 , 100 ) print ( \" \\n Press Ctrl+C to quit \\n \" ) dc = 0 pwm . start ( dc ) try : while True : temp = subprocess . getoutput ( \"vcgencmd measure_temp|sed 's/[^0-9.]//g'\" ) if round ( float ( temp )) >= 45 : dc = 100 pwm . ChangeDutyCycle ( dc ) print ( \"CPU Temp:\" , float ( temp ), \" Fan duty cycle:\" , dc ) time . sleep ( 180.0 ) if round ( float ( temp )) >= 40 : dc = 85 pwm . ChangeDutyCycle ( dc ) print ( \"CPU Temp:\" , float ( temp ), \" Fan duty cycle:\" , dc ) time . sleep ( 120.0 ) else : dc = 70 pwm . ChangeDutyCycle ( dc ) print ( \"CPU Temp:\" , float ( temp ), \" Fan duty cycle:\" , dc ) time . sleep ( 60.00 ) except KeyboardInterrupt : pwm . stop () GPIO . cleanup () print ( \"Ctrl + C pressed -- Ending program\" ) Then execute it: python3 fan_control.py How to enable the USB2.0 in front of panel? Install DeskPi v1 driver. Add following parameter to /boot/config.txt file manually. dtoverlay = dwc2,dr_mode = host DO REMEMBER `reboot` Raspberry Pi to take effect. How to send power_off signal to adapter board to cut off power? Make sure you have already add dtoverlay=dwc2,dr_mode=host to /boot/config.txt file and reboot Raspberry Pi. Check if there is a device called /dev/ttyUSB0 Execute the python demo script in deskpi_v1/drivers/python/safecutoffpower.py you may need to install pyserial library. Recommend: adding this function after shutdown service, so that it can safely cut off the power of Raspberry Pi. How to reboot by double click power buttom? Principle when you double click the power button, The MCU on expansion board will send three times poweroffpoweroffpoweroff to serial port on raspberry Pi which generate via dwc2 dtoverlay, called /dev/ttyUSB0 , and you can capture it via python script and customized your own script to control the shutdown behavior. Demo code: Install pyserial library to control serial port. pip3 install pyserial Create a file named safe_shutdown.py and paste following code: import serial import time import os ser = serial.Serial('/dev/ttyUSB0', baudrate=9600, timeout=3) while True: if ser.isOpen(): data = ser.read(16) data = data.decode('utf-8') #print(data) if 'poweroff' in data: print(\"System will turn off in 3 seconds\") time.sleep(3) ser.write(b'power_off') ser.write(b'power_off') os.system('sudo sync && sudo init 0') 3. Execute it: python3 safe_shutdown.py You can also change the os.system(\"sudo reboot\") to reboot your Raspberry Pi. GitHub Repository deskpi_v1","title":"DeskPi Lite"},{"location":"deskpilite/#deskpi-lite-deskpi_v1","text":"","title":"DeskPi Lite (deskpi_v1)"},{"location":"deskpilite/#description","text":"The DeskPi V1 Case is a case made of ABS, and an adapter board is provided inside to transfer the HDMI interface, 3.5mm audio interface, and USB-C power interface of the Raspberry Pi to the back of the panel. and offer microHDMI to Full-sized HDMI interface, makes it convenient for users to use standard HDMI cables to connect external display devices. In addition, it provides an ultra-thin aluminum alloy heat sink and supports an adjustable-speed ultra-thin silent fan, which can be safely cut off Power supply for Raspberry Pi by sending a \"power_off\" signal to the adapter board.","title":"Description"},{"location":"deskpilite/#purchase","text":"DeskPi Lite","title":"Purchase"},{"location":"deskpilite/#features","text":"Convert the microHDMI to a Full-sized HDMI interface and place it on the back of the panel with the power interface Transfer 3.5mm audio interface to the back of the panel Support Raspberry Pi official fan temperature control function via raspi-config tool. Support system shutdown to safe cut off power on Raspberry Pi Support adjustable fan speed via PWM programming. Light weight heat-sink inside. Adjustable speed Fan","title":"Features"},{"location":"deskpilite/#gallery","text":"Features Easy to install Expansion of 2 USB Ports Fast Cooling GPIO Interface Protect Non-Slip Rubber feet","title":"Gallery"},{"location":"deskpilite/#port-definitions","text":"","title":"Port definitions"},{"location":"deskpilite/#package-includes","text":"1 x DeskPi Lite Case (Plastic) 1 x CNC alloy aluminum heat sink with PWM fan and GPIO expansion board 1 x Port adapter board 1 x Instructions 6 x Thermal Pads 2 x LED indicator lampshade 2 x M2.5 Screw","title":"Package includes"},{"location":"deskpilite/#working-principle","text":"RPi -> sending poweroff to /dev/ttyUSB0 means sending cut off power -> MCU on board: means MCU will cut of power of Raspberry Pi. RPi <- Reading poweroff from /dev/ttyUSB0 means shutdown system <- MCU on board: system will execute shutdown service or reboot (according to scripts definitions) when power button has been pressed twice.","title":"Working Principle"},{"location":"deskpilite/#how-to-enable-fan-temperature-control","text":"NOTE: Raspberry Pi OS (Latest) will support this function. Open a terminal and typing following command: sudo raspi-config Navigate to Performance Options -> P4 Fan -> Yes -> 14 -> 60 -> yes -> finish -> reboot Raspberry Pi. The fan is support PWM signal control via GPIO14 which is physical pin 12 (TXD), it will spinning when the CPU temperature is above 60 degree. and also you can write your code to control the fan via GPIO14 , sending PWM signal will trigger the fan spinning. This case hardware uses direct GPIO header connections for the included PWM capable fan. Like in your bigger DeskPi case software, you could easily change from a /dev/ttyUSB0 to a GPIO PWM fan control service. For anyone else wanting to implement some form of PWM fan control, please see the included python3 script code below. This will enable: < 40'c - Fan 75%, for a minimum of 60sec 40'c to 45'c - Fan 85%, for a minimum of 120sec > 45'c - Fan 100%, for a minimum of 180sec In everyday use, this script offers good temperatrue control, with the CPU temp rarely reaches > 45'c and general fan noise is very low and still keeps good control via the PWM fan vs standard Raspberry Pi OS PWM fan control via /boot/config.txt or raspi-config. #!/usr/bin/python3 import RPi.GPIO as GPIO import time import subprocess GPIO . setmode ( GPIO . BCM ) GPIO . setup ( 14 , GPIO . OUT ) pwm = GPIO . PWM ( 14 , 100 ) print ( \" \\n Press Ctrl+C to quit \\n \" ) dc = 0 pwm . start ( dc ) try : while True : temp = subprocess . getoutput ( \"vcgencmd measure_temp|sed 's/[^0-9.]//g'\" ) if round ( float ( temp )) >= 45 : dc = 100 pwm . ChangeDutyCycle ( dc ) print ( \"CPU Temp:\" , float ( temp ), \" Fan duty cycle:\" , dc ) time . sleep ( 180.0 ) if round ( float ( temp )) >= 40 : dc = 85 pwm . ChangeDutyCycle ( dc ) print ( \"CPU Temp:\" , float ( temp ), \" Fan duty cycle:\" , dc ) time . sleep ( 120.0 ) else : dc = 70 pwm . ChangeDutyCycle ( dc ) print ( \"CPU Temp:\" , float ( temp ), \" Fan duty cycle:\" , dc ) time . sleep ( 60.00 ) except KeyboardInterrupt : pwm . stop () GPIO . cleanup () print ( \"Ctrl + C pressed -- Ending program\" ) Then execute it: python3 fan_control.py","title":"How to enable fan temperature control?"},{"location":"deskpilite/#how-to-enable-the-usb20-in-front-of-panel","text":"Install DeskPi v1 driver. Add following parameter to /boot/config.txt file manually. dtoverlay = dwc2,dr_mode = host DO REMEMBER `reboot` Raspberry Pi to take effect.","title":"How to enable the USB2.0 in front of panel?"},{"location":"deskpilite/#how-to-send-power_off-signal-to-adapter-board-to-cut-off-power","text":"Make sure you have already add dtoverlay=dwc2,dr_mode=host to /boot/config.txt file and reboot Raspberry Pi. Check if there is a device called /dev/ttyUSB0 Execute the python demo script in deskpi_v1/drivers/python/safecutoffpower.py you may need to install pyserial library. Recommend: adding this function after shutdown service, so that it can safely cut off the power of Raspberry Pi.","title":"How to send power_off signal to adapter board to cut off power?"},{"location":"deskpilite/#how-to-reboot-by-double-click-power-buttom","text":"","title":"How to reboot by double click power buttom?"},{"location":"deskpilite/#principle","text":"when you double click the power button, The MCU on expansion board will send three times poweroffpoweroffpoweroff to serial port on raspberry Pi which generate via dwc2 dtoverlay, called /dev/ttyUSB0 , and you can capture it via python script and customized your own script to control the shutdown behavior. Demo code: Install pyserial library to control serial port. pip3 install pyserial Create a file named safe_shutdown.py and paste following code: import serial import time import os ser = serial.Serial('/dev/ttyUSB0', baudrate=9600, timeout=3) while True: if ser.isOpen(): data = ser.read(16) data = data.decode('utf-8') #print(data) if 'poweroff' in data: print(\"System will turn off in 3 seconds\") time.sleep(3) ser.write(b'power_off') ser.write(b'power_off') os.system('sudo sync && sudo init 0') 3. Execute it: python3 safe_shutdown.py You can also change the os.system(\"sudo reboot\") to reboot your Raspberry Pi.","title":"Principle"},{"location":"deskpilite/#github-repository","text":"deskpi_v1","title":"GitHub Repository"},{"location":"deskpinano/","text":"DeskPi Nano For Jetson Nano Description DeskPi Nano is a DeskPin style aluminum alloy shell kit. It is a customized shell for Jetson Nano B01 version. It also provides a GPIO expansion board and a TF card expansion board. In addition to protecting the Jetson Nano motherboard, the appearance is also very good. Pretty. NOTE: Jetson Nano dose not include in the package and it only fit for Jetson Nano B01 Version. Purchase DeskPi Nano Features Only for Jetson Nano B01 Version Ultra-thin PWM fan radiator Fixable TF Card Adapter Board GPIO Adapter Board Gallery Product Outlook Frontal face Back face Top side Power button and TF card slot 45 degree angle view Fan Details Dimention Heat Dissipation effect How to enable PWM Fan Turn on DeskPi Nano and open a terminal, typing following command: sudo jetson-clocks It will enable fan control via system detection and sending PWM signal to the fan. you will see the fan is spinning. Package Includes 1 x DeskPi Nano Case (Pack) How to assemble it YouTube Tutorial Video Keywords DeskPi Nano, Jetson Nano case, DeskPi","title":"DeskPi Nano"},{"location":"deskpinano/#deskpi-nano-for-jetson-nano","text":"","title":"DeskPi Nano For Jetson Nano"},{"location":"deskpinano/#description","text":"DeskPi Nano is a DeskPin style aluminum alloy shell kit. It is a customized shell for Jetson Nano B01 version. It also provides a GPIO expansion board and a TF card expansion board. In addition to protecting the Jetson Nano motherboard, the appearance is also very good. Pretty. NOTE: Jetson Nano dose not include in the package and it only fit for Jetson Nano B01 Version.","title":"Description"},{"location":"deskpinano/#purchase","text":"DeskPi Nano","title":"Purchase"},{"location":"deskpinano/#features","text":"Only for Jetson Nano B01 Version Ultra-thin PWM fan radiator Fixable TF Card Adapter Board GPIO Adapter Board","title":"Features"},{"location":"deskpinano/#gallery","text":"Product Outlook Frontal face Back face Top side Power button and TF card slot 45 degree angle view","title":"Gallery"},{"location":"deskpinano/#fan-details","text":"","title":"Fan Details"},{"location":"deskpinano/#dimention","text":"","title":"Dimention"},{"location":"deskpinano/#heat-dissipation-effect","text":"","title":"Heat Dissipation effect"},{"location":"deskpinano/#how-to-enable-pwm-fan","text":"Turn on DeskPi Nano and open a terminal, typing following command: sudo jetson-clocks It will enable fan control via system detection and sending PWM signal to the fan. you will see the fan is spinning.","title":"How to enable PWM Fan"},{"location":"deskpinano/#package-includes","text":"1 x DeskPi Nano Case (Pack)","title":"Package Includes"},{"location":"deskpinano/#how-to-assemble-it","text":"YouTube Tutorial Video","title":"How to assemble it"},{"location":"deskpinano/#keywords","text":"DeskPi Nano, Jetson Nano case, DeskPi","title":"Keywords"},{"location":"deskpipro/","text":"DeskPi Pro Description The DeskPi Pro is a hardware kit for converting a standard Raspberry Pi 4 from a naked SBC, with limited storage, into a mini PC complete with a power button, cooling, better ports and, via SATA then USB3, 2.5\" or M.2 SATA SSD storage. Note: Support M.2 SATA SSD only, Does not support M.2 NVME SSD Purchase DeskPi Pro Currently tested operating systems that can support Deskpi scripts Raspberry Pi OS(32bit) - tested RaspiOS (64bit) - tested Ubuntu-mate OS(32bit) - tested Ubuntu OS (64bit) - tested Manjaro OS (32bit) - tested Manjaro OS (64bit) - To be tested Kali-linux-arm OS (32bit) - tested Kali-linux-arm OS (64-Bit) - To be tested Twister OS v2.0.2 (32bit) - tested DietPi OS (64bit) - tested Volumio OS Version: 2021-04-24-Pi (32bit) - tested RetroPie OS (32bit) - tested Please Read this section carefully if you are using 64bit OS, The script to control the fan is in the drivers/c/ directory. The file suffix with 64 means 64bit , and the other one is a 32bit executable file. Before you install this script, please make sure your Raspberry Pi can access internet and can access github website. How to install it. For Raspbian and RetroPie OS. (32bit) cd ~ git clone https://github.com/DeskPi-Team/deskpi.git cd ~/deskpi/ chmod +x install.sh sudo ./install.sh For Ubuntu 64bit OS cd ~ git clone https://github.com/DeskPi-Team/deskpi.git cd ~/deskpi/ chmod +x install-ubuntu-64.sh sudo ./install-ubuntu-64.sh For Ubuntu-mate OS cd ~ git clone https://github.com/DeskPi-Team/deskpi.git cd ~/deskpi/ chmod +x install-ubuntu-mate.sh sudo ./install-ubuntu-mate.sh For Manjaro OS cd ~ git clone https://github.com/DeskPi-Team/deskpi.git cd ~/deskpi/ chmod +x install-manjaro.sh sudo ./install-manjaro.sh For Kali-linux-arm OS. Image Download URL: https://images.kali.org/arm-images/kali-linux-2020.3a-rpi3-nexmon.img.xz cd ~ git clone https://github.com/DeskPi-Team/deskpi.git cd ~/deskpi/ chmod +x install-kali.sh sudo ./install-kali.sh For Twister OS v2.0.2 OS image: TwisterOSv2-0-2.img * Image Download URL:https://twisteros.com/twisteros.html cd ~ git clone https://github.com/DeskPi-Team/deskpi.git cd ~/deskpi/ chmod +x install.sh sudo ./install.sh For 64 bit Raspberry Pi OS (aarm64) Image Download URL: http://downloads.raspberrypi.org/raspios_arm64/images/raspios_arm64-2021-05-28/ cd ~ git clone https://github.com/DeskPi-Team/deskpi.git cd ~/deskpi/ chmod +x install-raspios-64bit.sh sudo ./install-raspios-64bit.sh * Uninstall: cd ~/deskpi/ chmod +x install-raspios-64bit.sh sudo ./uninstall-raspios-64bit.sh For DietPi OS 64bit Make sure your OS can access internet and please install git first. Execute this command in terminal: apt-get update && apt-get -y install git Image Download URL: https://dietpi.com/downloads/images/DietPi_RPi-ARMv8-Bullseye.7z cd ~ git clone https://github.com/DeskPi-Team/deskpi.git cd ~/deskpi/ ./install.sh For Volumio OS Version: 2021-04-24-Pi Image Download URL: https://updates.volumio.org/pi/volumio/2.882/volumio-2.882-2021-04-24-pi.img.zip Getting Start:\u3000https://volumio.github.io/docs/User_Manual/Quick_Start_Guide.html Make sure your Volumio can access internet. There are some steps need to do. sudo nano /etc/network/interface make sure following parameters in file /etc/network/interface auto wlan0 allow-hotplug wlan0 iface wlan0 inet dhcp wpa-ssid \"YOUR WIFI SSID\" wpa-psk \"YOUR WIFI PASSWORD\" and enable the internet access by typing this command in terminal: volumio internet on and then reboot your DeskPi. sudo reboot Download DeskPi driver from github: git clone https://github.com/DeskPi-Team/deskpi.git cd deskpi/ sudo ./install.sh TEST it after rebooting. deskpi-config Select 4 and press Enter , you would see the fan is spinning and the front USB port are now available. How to Uninstall deskpi DeskPi-uninstall And then select the number against to your OS Type. For Windows IoT OS Unsupported due to lacking of driver. Testing version: Midnight falcon How to control fan speed mannualy. Open a terminal and typing following command: deskpi-config You can follow the instructions to setup fan speed level by typing numbers as following example: Selection explain The number from 1 to 4 is to setting your fan speed to a static level. Number 5 is just turn off the fan. Number 6 is to guide you to create a file located to /etc/deskpi.conf and you can specify the threshold of temperature and fan speed level according to your idea, once the file has been created, the program will according to the configuration file to setup your fan. Number 7 is to enable automatic fan control by default paramaters. ** Default arguments: TEMP : Fan_SPEED_LEVEL <40C : 0 % 40 ~50C : 25 % 50 ~65C : 50 % 65 ~75C : 75 % >75C : 100 % ** If you want to change it, just typing : deskpi-config Select 6 and then input 45 and enter, and then input 50 means setup the fan speed level to 50% when CPU temp is above 45 degree it has 4 level to setup. NOTE: 50% Speed level means you have already send PWM50 to /dev/ttyUSB0 port, and this port will available when you add dtoverlay=dwc2,dr_mode=host to /boot/config.txt file and reboot your DeskPi. How to boot from USB SSD/HDD? After initial Raspberry Pi Configuration and once you have Internet Connectivity established, Install the DeskPi Pro Utilities from https://github.com/DeskPi-Team/deskpi.git Open a Terminal / Console and run the following commands: sudo apt update sudo apt full-upgrade sudo rpi-update When complete, run: sudo reboot Upon reboot, open Terminal again: sudo raspi-config * go to Advanced Options * Select Boot Order, select #1 USB Boot , Return to Advanced Options, * Select Boot Loader Version, choose Latest Version * Save & exit Reboot again (to restart with new settings) sudo reboot After reboot, re-open Terminal again sudo -E rpi-eeprom-config --edit do not change anything, it is unnecessary press Ctrl-X to save, answer Y to overwrite file. sudo reboot Now you are ready to install Raspberry-OS onto your USB Boot Device. You can use the Raspberry Imager from www.raspberrypi.org website. Depending on device the new SD Card Copier can transfer the SD-Card image to the USB Device (ensure you select generate a new UUID). Once your USB drive is imaged & ready to boot, shutdown your Deskpi-Pro, remove the SD-Card and power-up to boot from the USB Boot drive, once running & configured you can install your additional software and proceed as usual. Tutorial Video On YouTube How to Use IR function onboard. You need to enable gpio-ir function by modify /boot/config.txt file. uncomment this line if not exsit please add it. dtoverlay = gpio-ir,gpio_pin = 17 Install lirc package: sudo apt-get install lirc Modify configuration file on location: /etc/lirc/lirc_options.conf and make sure it has following parameters: driver = default device = /dev/lirc0 Reboot your Raspberry Pi and test it with following command: mode2 -d /dev/lirc1 FAQs OS Issues What operating systems are currently tested on DeskPi Pro and works fine? Raspbian OS - 32bit version: 2020-08-12 Raspberry Pi OS . Ubuntu-mate OS - 32bit version:20.04.1-desktop--armhf+raspi Ubuntu mate 20.04 LTS 32Bit . Manjaro OS - 32bit verison: 20.2 Manjaro XFCE 20.2 Kali-linux-arm OS - 32bit version: 2020.4 Kali Linux RaspberryPi 2, 3, 4 and 400 . Dose it support 64bit OS such as Ubuntu 20.10? It depends on Raspberry Pi offical support, we suggest that you can refer to offical source here: Raspberry Pi OS . Front USB Issues Why the USB on the front panel of my DESKPI cannot be used? I have burned the system many times? Please check your /boot/config.txt file and make sure it contains dtoverlay=dwc2,dr_mode=host , and if you add it by yourself, it need to reboot Raspberry Pi to take effect. Disk drive Issues Why does my SSD hard drive not work normally after my Logitech wireless mouse and keyboard dongle is connected to DeskPi? Because the 2.4G frequency used by Logitech's mouse and keyboard interferes with DeskPi's USB transfer interface, it will cause the disk to work in an unstable state. This problem with Logitech's keyboard and mouse also occurs on desktop computers. The current solution is best to replace the wireless keyboard and mouse or use a wired keyboard and mouse. Why is it normal when I start the Raspberry Pi with a TF card, but the SATA SSD hard disk cannot appear on the desktop? The disk cannot be displayed on the desktop may be caused by the following reasons: Hardware connection - The hardware is not connected properly, such as forgetting to install the USB adapter. Not Initialized Before - The SATA SSD hard disk is a RAW Disk, the brand new one has not been partitioned, formatted, or mounted. Unavailable file system format - file sytem format not recognized by the Linux system is used, for example: NTFS Solution and diagnostic Reconnect SATA SSD to DeskPi Disk Adapter board Format partitions and mount disks manually - Following steps: 1. Open a terminal or press \"Ctrl+Alt+T\". 2. Typing: \"sudo fdisk -l\" to check if the disk has been recognized or typing: \"sudo lsusb -t\", typing: \"dmesg |grep -i usb\" to make sure disk has been connected. 3. If the disk can be found by those commands, manually format and mount the partition: for example: 3.1 `sudo fdisk /dev/sda` - sda means my first SCSI type disk which recognized by my system. 3.2 `p` - typing `p` means print current partions that contains on the disk. 3.3 `n` - new partion -> `p` - primary partion -> `1` -> partion number -> `Enter`-> first celinder -> `Enter` last celinder -> make the whole disk as a partion -> `w` - write the partion table to disk and quit. 3.4 `sudo partprobe /dev/sda` - make it recognized by linux kernel. 3.5 `mkdir /home/pi/mydata` - create mounting directory. 3.6 `sudo mkfs.ext4 /dev/sda1` - format partion `/dev/sda1` to `ext4` type which support `journal` on data saving. 3.7 `sudo mount -t ext4 /dev/sda1 /home/pi/mydata` - mount the partion to mount point so that we can access it. 3.8 `sudo chmod -R 777 /home/pi/mydata` - Set premission to the folder so that we can write and read date to disk. 4. How To Automount File Systems on Raspbian(Linux) 4.1 `sudo blkid` - Get the Name, In the output of this command, the first column is the name of your drives. The second column is the label of the drive (if you set a label for it) and the third column is the UUID of your drives. First you need to know the name of the drive that is going to be automatically mounted. 4.2 `sudo nano /etc/fstab` - [Dangerous] If the operation fails, the system will not start, add your partion information and let it auto mount after rebooting, We need to append one line of code at the end of the file. The format of this line of code is as follows: `UUID=<uuid-of-your-drive> <mount-point> <file-system-type> <mount-option> <dump> <pass>` * Note that you need to separate these items with `Tab key`. For example, I added the following line to the end of /etc/fstab. `UUID=eb67c479-962f-4bcc-b3fe-cefaf908f01e /home/pi/mydata ext4 defaults 0 2` Save and close the file. Then run the following command to see if it works. * `sudo mount -a` - Test automount. * `df -Th` - Check if there is a partion has been mounted on /home/pi/mydata. Some Explanations The defaults mount option will give users read and write access to the file system. The value of dump field is usually zero. The pass field is used by the fsck program to determine the order in which filesystem checks are done at reboot time. As you can see in this file, the value of the pass field for the root file system is 1. Swap partitions do not need to be checked and the value for them is zero. All other file systems should have a value of 2. So I set the pass value as 2 for my drive. HDMI issue My screen goes to black when I was booting up my deskpi. Please try to shift HDMI cable from HDMI0 to HDMI1 which is beside 3.5mm audio jack and try again. USB booting issue Why does it take so much time when I boot it from USB booting? It seems to be some tough question, some issues may caused by the usb controller chip performance issue. HOWTOs How to check OS Version Open a terminal and typing: lsb_release -a Check the kernel version: uname -a How to check wifi connection status Open a terminal and typing: ifconfig -a Wi-Fi adapter is called wlan0 How to check wifi signal level? sudo apt update sudo apt -y install wavemon sudo wavemon -i wlan0 Check if Raspberry Pi can connect to Internet ping -c 4 wwww.apache.org Check if DNS configuration is correctly. cat /etc/resolv.conf make sure the nameserver is available, if not, please contact to your ISP (Internet Service Provider). How to check SSD/HDD status Check if the SSD/HDD has been recognized by OS, just check USB controller's status will be ok due to it is connected via an USB adapter . dmesg | grep -i usb Check if the it supports UASP , USB Attached SCSI (UAS) or USB Attached SCSI Protocol (UASP) is a computer protocol used to move data to and from USB storage devices such as hard drives (HDDs), solid-state drives (SSDs), and thumb drives. UAS depends on the USB protocol, and uses the standard SCSI command set. Use of UAS generally provides faster transfers compared to the older USB Mass Storage Bulk-Only Transport (BOT) drivers. UAS was introduced as part of the USB 3.0 standard, but can also be used with devices complying with the slower USB 2.0 standard, assuming use of compatible hardware, firmware and drivers. * Command: lsusb -t If you can not find uas in the output message, it means it does not support uasp . if not, and the disk still not show up on your Raspberry Pi desktop, please check your hardware and repeat following steps: Hareware checking steps: Please make sure the USB adapter is connect well. Please check the harddisk adapter board's 4Pin pinheader is connect properly. Please tell me what kind of OS did you use? Raspbian OS ? Please use the wall charger that we provide in the package. Please send us the result of those commands in terminal so that we can help you to diagnose the problem. Reboot your Raspberry Pi by typing: sudo sync sudo reboot Software checking steps: Make sure the drive can be recognized. sudo fdisk -l | grep -i 'dev' or lsusb -t or lsblk Make sure the drive is not raw disk or has NTFS filesystem on it. here /dev/sda is my test result, you shall change this as your result from sudo fdisk -l |grep -i 'dev' command. sudo fdisk -l /dev/sda If it is a raw disk , means it has never been partied before, you need to make partition and format it, and mount it to a directory so that you can access it. Make Partitions sudo fdisk /dev/sda p n p 1 Enter Enter w Explanation: p means: print partition table. n means: new - create new partition. p means: primary partition. 1 means: the first partition number. Enter means: select default cylinder as start cylinder. Enter means: select the whole disk as end cylinder. w means: save the change to partition table and quit. Format partition sudo mkfs.ext4 /dev/sda1 It will format /dev/sda1 partition to an ext4 type filesystem which can be supported by most Linux distributions. Mount partition You need to mount the partition to a folder(directory) before you can use it. cd mkdir mydata sudo mount -t ext4 /dev/sda1 mydata -v sudo chmod 777 /home/pi/mydata Explanation: cd means go back to your home directory. mkdir means create a directory for your partition. sudo mount -t ext4 /dev/sda1 mydata -v means mount /dev/sda1 partition to directory mydata with ext4 type filesystem format and -v will show the details when you mount this partition. sudo chmod 777 /home/pi/mydata means everyone can have full privilledges on this mounting point. you have read , write , execute permission on this directory. How to check if it has been mounted on df -Th or sudo mount How to check front USB port First, you need to check if /boot/config.txt file contains this parameter: dtoverlay = dwc2,dr_mode = host The front USB function is coming from dwc2 overlay, it selects the dwc2 USB controller driver, and dr_mode can be host , peripheral or otg . here, dwc2 mode must be host . And if you want to add it without editing /boot/config.txt file manually, just typing this command in a terminal: sudo sed -i '$a\\dtoverlay=dwc2,dr_mode=host' /boot/config.txt How to check HDMI configuration Some people give us a feedback said there is a black screen when booting up Raspberry pi in a deskPi case, it may caused by several reasons. Solution 1 You can solve this problem by according steps: Modify /boot/config.txt file and adding this: hdmi_force_hotplug = 1 hdmi_group = 2 config_hdmi_boost = 4 Save it and reboot Raspberry Pi. sudo sync sudo reboot Solution 2 Unplug HDMI cable and shift it to HDMI1 which is near by 3.5mm audio jack. Solution 3 Change Resolution on desktop by click raspberry icon and select the app according to following picture. Navigate to Screen Configuration Navigate to configure -> Screens -> HDMI-1 or HDMI-2 -> Resolution -> Select whatever your Screens Resolution is. Apply the change. How to check IR remote Enable gpio-ir function by editing /boot/config.txt file. dtoverlay = gpio-ir,gpio_pin = 17 Install lirc software. sudo apt-get -y install lirc Modify configuration file /etc/lirc/lirc_options.conf and make sure it contains those two parameters: driver = default device = /dev/lirc0 Save it and reboot Raspberry Pi. sudo sync sudo reboot Test it by: mode2 -d /dev/lirc1 NOTE Please aim your IR remote controller direct to the power button. and different IR remote controller may have different response time. How to check audio output The audio output can be two ways: 3.5mm jack , HDMI cable . If you connect HDMI cable to your DeskPi on HDMI0 port which is beside USB-C Port on the back of the panel, it will be recognized by Raspbian OS as HDMI-1 , and the other one is recognized as HDMI-2 How to change audio output. Right Click the sound icon on the task bar. And select which one you want to output: Analog - It will change audio output to 3.5mm jack. HDMI-1 - It will change audio output to HDMI0 . HDMI-2 - It will change audio output to HDMI1 . And then restart your application you will heard the sound. DeskPi home More Product and information please visit: DeskPi Home","title":"DeskPi Pro"},{"location":"deskpipro/#deskpi-pro","text":"","title":"DeskPi Pro"},{"location":"deskpipro/#description","text":"The DeskPi Pro is a hardware kit for converting a standard Raspberry Pi 4 from a naked SBC, with limited storage, into a mini PC complete with a power button, cooling, better ports and, via SATA then USB3, 2.5\" or M.2 SATA SSD storage. Note: Support M.2 SATA SSD only, Does not support M.2 NVME SSD","title":"Description"},{"location":"deskpipro/#purchase","text":"DeskPi Pro","title":"Purchase"},{"location":"deskpipro/#currently-tested-operating-systems-that-can-support-deskpi-scripts","text":"Raspberry Pi OS(32bit) - tested RaspiOS (64bit) - tested Ubuntu-mate OS(32bit) - tested Ubuntu OS (64bit) - tested Manjaro OS (32bit) - tested Manjaro OS (64bit) - To be tested Kali-linux-arm OS (32bit) - tested Kali-linux-arm OS (64-Bit) - To be tested Twister OS v2.0.2 (32bit) - tested DietPi OS (64bit) - tested Volumio OS Version: 2021-04-24-Pi (32bit) - tested RetroPie OS (32bit) - tested","title":"Currently tested operating systems that can support Deskpi scripts"},{"location":"deskpipro/#please-read-this-section-carefully","text":"if you are using 64bit OS, The script to control the fan is in the drivers/c/ directory. The file suffix with 64 means 64bit , and the other one is a 32bit executable file. Before you install this script, please make sure your Raspberry Pi can access internet and can access github website.","title":"Please Read this section carefully"},{"location":"deskpipro/#how-to-install-it","text":"","title":"How to install it."},{"location":"deskpipro/#for-raspbian-and-retropie-os-32bit","text":"cd ~ git clone https://github.com/DeskPi-Team/deskpi.git cd ~/deskpi/ chmod +x install.sh sudo ./install.sh","title":"For Raspbian and RetroPie OS. (32bit)"},{"location":"deskpipro/#for-ubuntu-64bit-os","text":"cd ~ git clone https://github.com/DeskPi-Team/deskpi.git cd ~/deskpi/ chmod +x install-ubuntu-64.sh sudo ./install-ubuntu-64.sh","title":"For Ubuntu 64bit OS"},{"location":"deskpipro/#for-ubuntu-mate-os","text":"cd ~ git clone https://github.com/DeskPi-Team/deskpi.git cd ~/deskpi/ chmod +x install-ubuntu-mate.sh sudo ./install-ubuntu-mate.sh","title":"For Ubuntu-mate OS"},{"location":"deskpipro/#for-manjaro-os","text":"cd ~ git clone https://github.com/DeskPi-Team/deskpi.git cd ~/deskpi/ chmod +x install-manjaro.sh sudo ./install-manjaro.sh","title":"For Manjaro OS"},{"location":"deskpipro/#for-kali-linux-arm-os","text":"Image Download URL: https://images.kali.org/arm-images/kali-linux-2020.3a-rpi3-nexmon.img.xz cd ~ git clone https://github.com/DeskPi-Team/deskpi.git cd ~/deskpi/ chmod +x install-kali.sh sudo ./install-kali.sh","title":"For Kali-linux-arm OS."},{"location":"deskpipro/#for-twister-os-v202","text":"OS image: TwisterOSv2-0-2.img * Image Download URL:https://twisteros.com/twisteros.html cd ~ git clone https://github.com/DeskPi-Team/deskpi.git cd ~/deskpi/ chmod +x install.sh sudo ./install.sh","title":"For Twister OS v2.0.2"},{"location":"deskpipro/#for-64-bit-raspberry-pi-os-aarm64","text":"Image Download URL: http://downloads.raspberrypi.org/raspios_arm64/images/raspios_arm64-2021-05-28/ cd ~ git clone https://github.com/DeskPi-Team/deskpi.git cd ~/deskpi/ chmod +x install-raspios-64bit.sh sudo ./install-raspios-64bit.sh * Uninstall: cd ~/deskpi/ chmod +x install-raspios-64bit.sh sudo ./uninstall-raspios-64bit.sh","title":"For 64 bit Raspberry Pi OS (aarm64)"},{"location":"deskpipro/#for-dietpi-os-64bit","text":"Make sure your OS can access internet and please install git first. Execute this command in terminal: apt-get update && apt-get -y install git Image Download URL: https://dietpi.com/downloads/images/DietPi_RPi-ARMv8-Bullseye.7z cd ~ git clone https://github.com/DeskPi-Team/deskpi.git cd ~/deskpi/ ./install.sh","title":"For DietPi OS 64bit"},{"location":"deskpipro/#for-volumio-os-version-2021-04-24-pi","text":"Image Download URL: https://updates.volumio.org/pi/volumio/2.882/volumio-2.882-2021-04-24-pi.img.zip Getting Start:\u3000https://volumio.github.io/docs/User_Manual/Quick_Start_Guide.html Make sure your Volumio can access internet. There are some steps need to do. sudo nano /etc/network/interface make sure following parameters in file /etc/network/interface auto wlan0 allow-hotplug wlan0 iface wlan0 inet dhcp wpa-ssid \"YOUR WIFI SSID\" wpa-psk \"YOUR WIFI PASSWORD\" and enable the internet access by typing this command in terminal: volumio internet on and then reboot your DeskPi. sudo reboot Download DeskPi driver from github: git clone https://github.com/DeskPi-Team/deskpi.git cd deskpi/ sudo ./install.sh TEST it after rebooting. deskpi-config Select 4 and press Enter , you would see the fan is spinning and the front USB port are now available.","title":"For Volumio OS Version: 2021-04-24-Pi"},{"location":"deskpipro/#how-to-uninstall-deskpi","text":"DeskPi-uninstall And then select the number against to your OS Type.","title":"How to Uninstall deskpi"},{"location":"deskpipro/#for-windows-iot-os","text":"Unsupported due to lacking of driver. Testing version: Midnight falcon","title":"For Windows IoT OS"},{"location":"deskpipro/#how-to-control-fan-speed-mannualy","text":"Open a terminal and typing following command: deskpi-config You can follow the instructions to setup fan speed level by typing numbers as following example:","title":"How to control fan speed mannualy."},{"location":"deskpipro/#selection-explain","text":"The number from 1 to 4 is to setting your fan speed to a static level. Number 5 is just turn off the fan. Number 6 is to guide you to create a file located to /etc/deskpi.conf and you can specify the threshold of temperature and fan speed level according to your idea, once the file has been created, the program will according to the configuration file to setup your fan. Number 7 is to enable automatic fan control by default paramaters. ** Default arguments: TEMP : Fan_SPEED_LEVEL <40C : 0 % 40 ~50C : 25 % 50 ~65C : 50 % 65 ~75C : 75 % >75C : 100 % ** If you want to change it, just typing : deskpi-config Select 6 and then input 45 and enter, and then input 50 means setup the fan speed level to 50% when CPU temp is above 45 degree it has 4 level to setup. NOTE: 50% Speed level means you have already send PWM50 to /dev/ttyUSB0 port, and this port will available when you add dtoverlay=dwc2,dr_mode=host to /boot/config.txt file and reboot your DeskPi.","title":"Selection explain"},{"location":"deskpipro/#how-to-boot-from-usb-ssdhdd","text":"After initial Raspberry Pi Configuration and once you have Internet Connectivity established, Install the DeskPi Pro Utilities from https://github.com/DeskPi-Team/deskpi.git Open a Terminal / Console and run the following commands: sudo apt update sudo apt full-upgrade sudo rpi-update When complete, run: sudo reboot Upon reboot, open Terminal again: sudo raspi-config * go to Advanced Options * Select Boot Order, select #1 USB Boot , Return to Advanced Options, * Select Boot Loader Version, choose Latest Version * Save & exit","title":"How to boot from USB SSD/HDD?"},{"location":"deskpipro/#reboot-again-to-restart-with-new-settings","text":"sudo reboot After reboot, re-open Terminal again sudo -E rpi-eeprom-config --edit do not change anything, it is unnecessary press Ctrl-X to save, answer Y to overwrite file. sudo reboot Now you are ready to install Raspberry-OS onto your USB Boot Device. You can use the Raspberry Imager from www.raspberrypi.org website. Depending on device the new SD Card Copier can transfer the SD-Card image to the USB Device (ensure you select generate a new UUID). Once your USB drive is imaged & ready to boot, shutdown your Deskpi-Pro, remove the SD-Card and power-up to boot from the USB Boot drive, once running & configured you can install your additional software and proceed as usual. Tutorial Video On YouTube","title":"Reboot again (to restart with new settings)"},{"location":"deskpipro/#how-to-use-ir-function-onboard","text":"You need to enable gpio-ir function by modify /boot/config.txt file. uncomment this line if not exsit please add it. dtoverlay = gpio-ir,gpio_pin = 17 Install lirc package: sudo apt-get install lirc Modify configuration file on location: /etc/lirc/lirc_options.conf and make sure it has following parameters: driver = default device = /dev/lirc0 Reboot your Raspberry Pi and test it with following command: mode2 -d /dev/lirc1","title":"How to Use IR function onboard."},{"location":"deskpipro/#faqs","text":"","title":"FAQs"},{"location":"deskpipro/#os-issues","text":"","title":"OS Issues"},{"location":"deskpipro/#what-operating-systems-are-currently-tested-on-deskpi-pro-and-works-fine","text":"Raspbian OS - 32bit version: 2020-08-12 Raspberry Pi OS . Ubuntu-mate OS - 32bit version:20.04.1-desktop--armhf+raspi Ubuntu mate 20.04 LTS 32Bit . Manjaro OS - 32bit verison: 20.2 Manjaro XFCE 20.2 Kali-linux-arm OS - 32bit version: 2020.4 Kali Linux RaspberryPi 2, 3, 4 and 400 .","title":"What operating systems are currently tested on DeskPi Pro and works fine?"},{"location":"deskpipro/#dose-it-support-64bit-os-such-as-ubuntu-2010","text":"It depends on Raspberry Pi offical support, we suggest that you can refer to offical source here: Raspberry Pi OS .","title":"Dose it support 64bit OS such as Ubuntu 20.10?"},{"location":"deskpipro/#front-usb-issues","text":"","title":"Front USB Issues"},{"location":"deskpipro/#why-the-usb-on-the-front-panel-of-my-deskpi-cannot-be-used-i-have-burned-the-system-many-times","text":"Please check your /boot/config.txt file and make sure it contains dtoverlay=dwc2,dr_mode=host , and if you add it by yourself, it need to reboot Raspberry Pi to take effect.","title":"Why the USB on the front panel of my DESKPI cannot be used? I have burned the system many times?"},{"location":"deskpipro/#disk-drive-issues","text":"","title":"Disk drive Issues"},{"location":"deskpipro/#why-does-my-ssd-hard-drive-not-work-normally-after-my-logitech-wireless-mouse-and-keyboard-dongle-is-connected-to-deskpi","text":"Because the 2.4G frequency used by Logitech's mouse and keyboard interferes with DeskPi's USB transfer interface, it will cause the disk to work in an unstable state. This problem with Logitech's keyboard and mouse also occurs on desktop computers. The current solution is best to replace the wireless keyboard and mouse or use a wired keyboard and mouse.","title":"Why does my SSD hard drive not work normally after my Logitech wireless mouse and keyboard dongle is connected to DeskPi?"},{"location":"deskpipro/#why-is-it-normal-when-i-start-the-raspberry-pi-with-a-tf-card-but-the-sata-ssd-hard-disk-cannot-appear-on-the-desktop","text":"The disk cannot be displayed on the desktop may be caused by the following reasons: Hardware connection - The hardware is not connected properly, such as forgetting to install the USB adapter. Not Initialized Before - The SATA SSD hard disk is a RAW Disk, the brand new one has not been partitioned, formatted, or mounted. Unavailable file system format - file sytem format not recognized by the Linux system is used, for example: NTFS","title":"Why is it normal when I start the Raspberry Pi with a TF card, but the SATA SSD hard disk cannot appear on the desktop?"},{"location":"deskpipro/#solution-and-diagnostic","text":"Reconnect SATA SSD to DeskPi Disk Adapter board Format partitions and mount disks manually - Following steps: 1. Open a terminal or press \"Ctrl+Alt+T\". 2. Typing: \"sudo fdisk -l\" to check if the disk has been recognized or typing: \"sudo lsusb -t\", typing: \"dmesg |grep -i usb\" to make sure disk has been connected. 3. If the disk can be found by those commands, manually format and mount the partition: for example: 3.1 `sudo fdisk /dev/sda` - sda means my first SCSI type disk which recognized by my system. 3.2 `p` - typing `p` means print current partions that contains on the disk. 3.3 `n` - new partion -> `p` - primary partion -> `1` -> partion number -> `Enter`-> first celinder -> `Enter` last celinder -> make the whole disk as a partion -> `w` - write the partion table to disk and quit. 3.4 `sudo partprobe /dev/sda` - make it recognized by linux kernel. 3.5 `mkdir /home/pi/mydata` - create mounting directory. 3.6 `sudo mkfs.ext4 /dev/sda1` - format partion `/dev/sda1` to `ext4` type which support `journal` on data saving. 3.7 `sudo mount -t ext4 /dev/sda1 /home/pi/mydata` - mount the partion to mount point so that we can access it. 3.8 `sudo chmod -R 777 /home/pi/mydata` - Set premission to the folder so that we can write and read date to disk. 4. How To Automount File Systems on Raspbian(Linux) 4.1 `sudo blkid` - Get the Name, In the output of this command, the first column is the name of your drives. The second column is the label of the drive (if you set a label for it) and the third column is the UUID of your drives. First you need to know the name of the drive that is going to be automatically mounted. 4.2 `sudo nano /etc/fstab` - [Dangerous] If the operation fails, the system will not start, add your partion information and let it auto mount after rebooting, We need to append one line of code at the end of the file. The format of this line of code is as follows: `UUID=<uuid-of-your-drive> <mount-point> <file-system-type> <mount-option> <dump> <pass>` * Note that you need to separate these items with `Tab key`. For example, I added the following line to the end of /etc/fstab. `UUID=eb67c479-962f-4bcc-b3fe-cefaf908f01e /home/pi/mydata ext4 defaults 0 2` Save and close the file. Then run the following command to see if it works. * `sudo mount -a` - Test automount. * `df -Th` - Check if there is a partion has been mounted on /home/pi/mydata.","title":"Solution and diagnostic"},{"location":"deskpipro/#some-explanations","text":"The defaults mount option will give users read and write access to the file system. The value of dump field is usually zero. The pass field is used by the fsck program to determine the order in which filesystem checks are done at reboot time. As you can see in this file, the value of the pass field for the root file system is 1. Swap partitions do not need to be checked and the value for them is zero. All other file systems should have a value of 2. So I set the pass value as 2 for my drive.","title":"Some Explanations"},{"location":"deskpipro/#hdmi-issue","text":"","title":"HDMI issue"},{"location":"deskpipro/#my-screen-goes-to-black-when-i-was-booting-up-my-deskpi","text":"Please try to shift HDMI cable from HDMI0 to HDMI1 which is beside 3.5mm audio jack and try again.","title":"My screen goes to black when I was booting up my deskpi."},{"location":"deskpipro/#usb-booting-issue","text":"","title":"USB booting issue"},{"location":"deskpipro/#why-does-it-take-so-much-time-when-i-boot-it-from-usb-booting","text":"It seems to be some tough question, some issues may caused by the usb controller chip performance issue.","title":"Why does it take so much time when I boot it from USB booting?"},{"location":"deskpipro/#howtos","text":"","title":"HOWTOs"},{"location":"deskpipro/#how-to-check-os-version","text":"Open a terminal and typing: lsb_release -a Check the kernel version: uname -a","title":"How to check OS Version"},{"location":"deskpipro/#how-to-check-wifi-connection-status","text":"Open a terminal and typing: ifconfig -a Wi-Fi adapter is called wlan0","title":"How to check wifi connection status"},{"location":"deskpipro/#how-to-check-wifi-signal-level","text":"sudo apt update sudo apt -y install wavemon sudo wavemon -i wlan0 Check if Raspberry Pi can connect to Internet ping -c 4 wwww.apache.org Check if DNS configuration is correctly. cat /etc/resolv.conf make sure the nameserver is available, if not, please contact to your ISP (Internet Service Provider).","title":"How to check wifi signal level?"},{"location":"deskpipro/#how-to-check-ssdhdd-status","text":"Check if the SSD/HDD has been recognized by OS, just check USB controller's status will be ok due to it is connected via an USB adapter . dmesg | grep -i usb Check if the it supports UASP , USB Attached SCSI (UAS) or USB Attached SCSI Protocol (UASP) is a computer protocol used to move data to and from USB storage devices such as hard drives (HDDs), solid-state drives (SSDs), and thumb drives. UAS depends on the USB protocol, and uses the standard SCSI command set. Use of UAS generally provides faster transfers compared to the older USB Mass Storage Bulk-Only Transport (BOT) drivers. UAS was introduced as part of the USB 3.0 standard, but can also be used with devices complying with the slower USB 2.0 standard, assuming use of compatible hardware, firmware and drivers. * Command: lsusb -t If you can not find uas in the output message, it means it does not support uasp . if not, and the disk still not show up on your Raspberry Pi desktop, please check your hardware and repeat following steps:","title":"How to check SSD/HDD status"},{"location":"deskpipro/#hareware-checking-steps","text":"Please make sure the USB adapter is connect well. Please check the harddisk adapter board's 4Pin pinheader is connect properly. Please tell me what kind of OS did you use? Raspbian OS ? Please use the wall charger that we provide in the package. Please send us the result of those commands in terminal so that we can help you to diagnose the problem. Reboot your Raspberry Pi by typing: sudo sync sudo reboot","title":"Hareware checking steps:"},{"location":"deskpipro/#software-checking-steps","text":"Make sure the drive can be recognized. sudo fdisk -l | grep -i 'dev' or lsusb -t or lsblk Make sure the drive is not raw disk or has NTFS filesystem on it. here /dev/sda is my test result, you shall change this as your result from sudo fdisk -l |grep -i 'dev' command. sudo fdisk -l /dev/sda If it is a raw disk , means it has never been partied before, you need to make partition and format it, and mount it to a directory so that you can access it. Make Partitions sudo fdisk /dev/sda p n p 1 Enter Enter w","title":"Software checking steps:"},{"location":"deskpipro/#explanation","text":"p means: print partition table. n means: new - create new partition. p means: primary partition. 1 means: the first partition number. Enter means: select default cylinder as start cylinder. Enter means: select the whole disk as end cylinder. w means: save the change to partition table and quit. Format partition sudo mkfs.ext4 /dev/sda1 It will format /dev/sda1 partition to an ext4 type filesystem which can be supported by most Linux distributions. Mount partition You need to mount the partition to a folder(directory) before you can use it. cd mkdir mydata sudo mount -t ext4 /dev/sda1 mydata -v sudo chmod 777 /home/pi/mydata","title":"Explanation:"},{"location":"deskpipro/#explanation_1","text":"cd means go back to your home directory. mkdir means create a directory for your partition. sudo mount -t ext4 /dev/sda1 mydata -v means mount /dev/sda1 partition to directory mydata with ext4 type filesystem format and -v will show the details when you mount this partition. sudo chmod 777 /home/pi/mydata means everyone can have full privilledges on this mounting point. you have read , write , execute permission on this directory.","title":"Explanation:"},{"location":"deskpipro/#how-to-check-if-it-has-been-mounted-on","text":"df -Th or sudo mount","title":"How to check if it has been mounted on"},{"location":"deskpipro/#how-to-check-front-usb-port","text":"First, you need to check if /boot/config.txt file contains this parameter: dtoverlay = dwc2,dr_mode = host The front USB function is coming from dwc2 overlay, it selects the dwc2 USB controller driver, and dr_mode can be host , peripheral or otg . here, dwc2 mode must be host . And if you want to add it without editing /boot/config.txt file manually, just typing this command in a terminal: sudo sed -i '$a\\dtoverlay=dwc2,dr_mode=host' /boot/config.txt","title":"How to check front USB port"},{"location":"deskpipro/#how-to-check-hdmi-configuration","text":"Some people give us a feedback said there is a black screen when booting up Raspberry pi in a deskPi case, it may caused by several reasons.","title":"How to check HDMI configuration"},{"location":"deskpipro/#solution-1","text":"You can solve this problem by according steps: Modify /boot/config.txt file and adding this: hdmi_force_hotplug = 1 hdmi_group = 2 config_hdmi_boost = 4 Save it and reboot Raspberry Pi. sudo sync sudo reboot","title":"Solution 1"},{"location":"deskpipro/#solution-2","text":"Unplug HDMI cable and shift it to HDMI1 which is near by 3.5mm audio jack.","title":"Solution 2"},{"location":"deskpipro/#solution-3","text":"Change Resolution on desktop by click raspberry icon and select the app according to following picture. Navigate to Screen Configuration Navigate to configure -> Screens -> HDMI-1 or HDMI-2 -> Resolution -> Select whatever your Screens Resolution is. Apply the change.","title":"Solution 3"},{"location":"deskpipro/#how-to-check-ir-remote","text":"Enable gpio-ir function by editing /boot/config.txt file. dtoverlay = gpio-ir,gpio_pin = 17 Install lirc software. sudo apt-get -y install lirc Modify configuration file /etc/lirc/lirc_options.conf and make sure it contains those two parameters: driver = default device = /dev/lirc0 Save it and reboot Raspberry Pi. sudo sync sudo reboot Test it by: mode2 -d /dev/lirc1 NOTE Please aim your IR remote controller direct to the power button. and different IR remote controller may have different response time.","title":"How to check IR remote"},{"location":"deskpipro/#how-to-check-audio-output","text":"The audio output can be two ways: 3.5mm jack , HDMI cable . If you connect HDMI cable to your DeskPi on HDMI0 port which is beside USB-C Port on the back of the panel, it will be recognized by Raspbian OS as HDMI-1 , and the other one is recognized as HDMI-2","title":"How to check audio output"},{"location":"deskpipro/#how-to-change-audio-output","text":"Right Click the sound icon on the task bar. And select which one you want to output: Analog - It will change audio output to 3.5mm jack. HDMI-1 - It will change audio output to HDMI0 . HDMI-2 - It will change audio output to HDMI1 . And then restart your application you will heard the sound.","title":"How to change audio output."},{"location":"deskpipro/#deskpi-home","text":"More Product and information please visit: DeskPi Home","title":"DeskPi home"},{"location":"expansionkit/","text":"DeskPi Lite Expansion kit Description The M.2 SATA SSD driver expansion board for DeskPi Lite is an add-on component that allows you to expand the storage capacity of your DeskPi Lite enclosure. It is specifically designed to accommodate M.2 SATA solid-state drives (SSDs), which are high-performance storage devices known for their fast data transfer speeds and reliability. This expansion board connects to the DeskPi Lite main board, providing an additional M.2 slot where you can install an M.2 SATA SSD. The M.2 form factor offers a compact and space-saving design, making it ideal for small form factor systems like the DeskPi Lite. When describing the M.2 SATA SSD driver expansion board for DeskPi Lite, you can highlight its key features and functionalities. Overall, the M.2 SATA SSD driver expansion board for DeskPi Lite enhances the storage capabilities of your DeskPi Lite system, enabling you to enjoy faster data access and increased capacity for your files and applications. NOTE: The DeskPi lite NAS expansion kit itself does not contain the DeskPi Lite shell and needs to be purchased additionally. This kit is only for upgrading the NAS function of the DeskPi lite, and is suitable for users who own the DeskPi lite and need to expand the external disk Note: DeskPi Lite case and M.2 SATA SSD does not include in the package, additional purchase required. Purchase DeskPi Lite M.2 SATA SSD Expansion Kit Features Storage Expansion: The expansion board allows you to add extra storage to your DeskPi Lite system, enabling you to store more files, applications, and media. M.2 SATA Compatibility: It is compatible with M.2 SATA SSDs, which are widely available and offer high-speed data transfer rates. Easy Installation: The board is designed for easy installation within the DeskPi Lite enclosure. It connects seamlessly to the main board, ensuring a hassle-free setup process. Performance and Speed: By utilizing the M.2 SATA interface, the expansion board enables fast and reliable data transfer, resulting in improved overall system performance. Compact Design: The expansion board is specifically designed to fit within the DeskPi Lite enclosure, ensuring a neat and tidy integration without occupying additional space. Versatility: With the M.2 SATA SSD driver expansion board, you can choose from a variety of M.2 SATA SSDs available in the market, allowing you to customize your storage capacity according to your needs. Gallery Package Includes Dimension M.2 SATA SSD only Please NOTE following figure, it's very important! Compatibilities Raspberry Pi 4 model B Only DeskPi Lite Case Only Package Includes 1 x DeskPi Lite NAS Case Expansion Kit 1 x M.2 to SATA SSD adapter board 1 x USB3.1 Connector 1 x Instruction Manual 2 x M2x7+6mm Copper pillar (For fixing Heatsink) 6 x M2x7+4mm Copper pillar (For fixing M.2 SATA SSD Adapter board) 6 x M2x10+4mm Copper pillar (For fixing DeskPi Lite daughter board How to Assemble it Open your DeskPi Lite, remove ABS bottom case. Fix M2x7+6mm copper pillar to those two positon to keep heatsink steady Fix another two hole with M2x7+4mm copper pillar. Fix M.2 SATA SSD drive to M.2 SATA SSD adapter board with flat head screw. Fix the M.2 SATA SSD adapter board to Raspberry Pi with M2x7+4mm copper pillar.\uff08Make sure the copper pogo-pin contact well with GPIO soldering point.\uff09 Fix DeskPi Lite daughter board and upper case with M2x10+4 copper pillar Fix bottom case with screws. Connect the USB3.0 connector on the back of DeskPi Lite on USB3.0 Port. Assemble Figure Prepare to boot up Connect HDMI cable to HDMI port, Power supply to USB-C port and then connect the mouse and USB keyboard to DeskPi lite, Press power button and waiting for system booting up, log into system and open a terminal. Check if the M.2 SATA SSD has been recognized. Typing: lsblk You should see there is one disk called \u201csda\u201d, that\u2019s your M.2 SATA SSD drive. Parted and format partition sudo fdisk /dev/sda press n for new partition, and then press p for primary partition, press 1 means first partition, and then press twice enter , make the whole disk as one partition, press w to write the partition table to disk and press q to quit. sudo partprobe /dev/sda sudo mkfs.ext4 /dev/sda1 # format the disk to ext4 filesystem. Mount Disk drive and upload file mkdir /home/pi/mydisk # make a mounting point sudo mount -t ext4 /dev/sda1 /home/pi/mydisk #Mount disk to mounting point sudo chmod 777 /home/pi/mydisk # grant user to access and write permisions. sudo chown -R pi:pi /home/pi/mydisk # grant user pi to take ownership of the folder. That\u2019s it. You can also build your own samba server to hold the disk to share with your family or your friends in your local area network (LAN). Keywords DeskPi Lite M.2 SATA SSD Expansion kit, DeskPi Lite expansion board, M.2 SATA SSD driver board for DeskPi Lite.","title":"DeskPi Lite Expansion Kit"},{"location":"expansionkit/#deskpi-lite-expansion-kit","text":"","title":"DeskPi Lite Expansion kit"},{"location":"expansionkit/#description","text":"The M.2 SATA SSD driver expansion board for DeskPi Lite is an add-on component that allows you to expand the storage capacity of your DeskPi Lite enclosure. It is specifically designed to accommodate M.2 SATA solid-state drives (SSDs), which are high-performance storage devices known for their fast data transfer speeds and reliability. This expansion board connects to the DeskPi Lite main board, providing an additional M.2 slot where you can install an M.2 SATA SSD. The M.2 form factor offers a compact and space-saving design, making it ideal for small form factor systems like the DeskPi Lite. When describing the M.2 SATA SSD driver expansion board for DeskPi Lite, you can highlight its key features and functionalities. Overall, the M.2 SATA SSD driver expansion board for DeskPi Lite enhances the storage capabilities of your DeskPi Lite system, enabling you to enjoy faster data access and increased capacity for your files and applications. NOTE: The DeskPi lite NAS expansion kit itself does not contain the DeskPi Lite shell and needs to be purchased additionally. This kit is only for upgrading the NAS function of the DeskPi lite, and is suitable for users who own the DeskPi lite and need to expand the external disk Note: DeskPi Lite case and M.2 SATA SSD does not include in the package, additional purchase required.","title":"Description"},{"location":"expansionkit/#purchase","text":"DeskPi Lite M.2 SATA SSD Expansion Kit","title":"Purchase"},{"location":"expansionkit/#features","text":"Storage Expansion: The expansion board allows you to add extra storage to your DeskPi Lite system, enabling you to store more files, applications, and media. M.2 SATA Compatibility: It is compatible with M.2 SATA SSDs, which are widely available and offer high-speed data transfer rates. Easy Installation: The board is designed for easy installation within the DeskPi Lite enclosure. It connects seamlessly to the main board, ensuring a hassle-free setup process. Performance and Speed: By utilizing the M.2 SATA interface, the expansion board enables fast and reliable data transfer, resulting in improved overall system performance. Compact Design: The expansion board is specifically designed to fit within the DeskPi Lite enclosure, ensuring a neat and tidy integration without occupying additional space. Versatility: With the M.2 SATA SSD driver expansion board, you can choose from a variety of M.2 SATA SSDs available in the market, allowing you to customize your storage capacity according to your needs.","title":"Features"},{"location":"expansionkit/#gallery","text":"Package Includes Dimension M.2 SATA SSD only Please NOTE following figure, it's very important!","title":"Gallery"},{"location":"expansionkit/#compatibilities","text":"Raspberry Pi 4 model B Only DeskPi Lite Case Only","title":"Compatibilities"},{"location":"expansionkit/#package-includes","text":"1 x DeskPi Lite NAS Case Expansion Kit 1 x M.2 to SATA SSD adapter board 1 x USB3.1 Connector 1 x Instruction Manual 2 x M2x7+6mm Copper pillar (For fixing Heatsink) 6 x M2x7+4mm Copper pillar (For fixing M.2 SATA SSD Adapter board) 6 x M2x10+4mm Copper pillar (For fixing DeskPi Lite daughter board","title":"Package Includes"},{"location":"expansionkit/#how-to-assemble-it","text":"Open your DeskPi Lite, remove ABS bottom case. Fix M2x7+6mm copper pillar to those two positon to keep heatsink steady Fix another two hole with M2x7+4mm copper pillar. Fix M.2 SATA SSD drive to M.2 SATA SSD adapter board with flat head screw. Fix the M.2 SATA SSD adapter board to Raspberry Pi with M2x7+4mm copper pillar.\uff08Make sure the copper pogo-pin contact well with GPIO soldering point.\uff09 Fix DeskPi Lite daughter board and upper case with M2x10+4 copper pillar Fix bottom case with screws. Connect the USB3.0 connector on the back of DeskPi Lite on USB3.0 Port.","title":"How to Assemble it"},{"location":"expansionkit/#assemble-figure","text":"","title":"Assemble Figure"},{"location":"expansionkit/#prepare-to-boot-up","text":"Connect HDMI cable to HDMI port, Power supply to USB-C port and then connect the mouse and USB keyboard to DeskPi lite, Press power button and waiting for system booting up, log into system and open a terminal. Check if the M.2 SATA SSD has been recognized. Typing: lsblk You should see there is one disk called \u201csda\u201d, that\u2019s your M.2 SATA SSD drive. Parted and format partition sudo fdisk /dev/sda press n for new partition, and then press p for primary partition, press 1 means first partition, and then press twice enter , make the whole disk as one partition, press w to write the partition table to disk and press q to quit. sudo partprobe /dev/sda sudo mkfs.ext4 /dev/sda1 # format the disk to ext4 filesystem. Mount Disk drive and upload file mkdir /home/pi/mydisk # make a mounting point sudo mount -t ext4 /dev/sda1 /home/pi/mydisk #Mount disk to mounting point sudo chmod 777 /home/pi/mydisk # grant user to access and write permisions. sudo chown -R pi:pi /home/pi/mydisk # grant user pi to take ownership of the folder. That\u2019s it. You can also build your own samba server to hold the disk to share with your family or your friends in your local area network (LAN).","title":"Prepare to boot up"},{"location":"expansionkit/#keywords","text":"DeskPi Lite M.2 SATA SSD Expansion kit, DeskPi Lite expansion board, M.2 SATA SSD driver board for DeskPi Lite.","title":"Keywords"},{"location":"itxcase/","text":"DeskPi ITX Case Kit for Super6C Purchase DeskPi ITX Case Kit for Super6C Description ITX Case kit for DeskPi Super6C is a Mini ITX series Case for DeskPi Super6C motherboard. 3 high speed fan provides super cooling effect for your Super6C Cluster. It provides you with the protection of the compact house structure, the acrylic shell on the top provides a better effect, allowing you to disassemble the shell in the case of Provide better effect to grasp the status information of each CM4. Specifications: Type: ITX Case Motherboard Support: Super6C motherboard ONLY Length Supported: 196mm x 220mm x 54mm Storage Support: M.2 SATA SSD, M.2 NVME SSD, TF card. Included Fans: 3 x 12V Fan Dimension: 270x235x65 mm SKU: DP-0010 Weight: gross weight/net weight: 1.230kg/1.04kg Fan Specifications\uff1a Power: 12V DC Current: 0.05A Speed: 6000RPM Fan Air Volume 4.96CFM Fan Air Pressure 21.16DBa Product outlook Product Includes 1 x ITX Case 6 x Aluminum heat sink for Raspberry Pi CM4 module. 3 x Fan 1 x Screwdriver Gallery Front face Power button Functionality: Short press \u2013 power on Long press \u2013 force power off Reset button Functionality: * Press once \u2013 Reset the motherboard NOTE: Every CM4 module will be restart at the same time, unsaved data may be lost, please pay attention to use it carefully Inside ITX case NOTE: Raspberry Pi CM4 modules are not included in the package. require additional purchase. The case provides some features on super6C motherboard, such as USB port, you can connect the \u201cUSB cable\u201d to super6C J6 pin header to extended the USB port to front USB port, and There are 3 Fan Cables for three Fans inside the case. you could connect them from FAN , FAN2 , FAN3 on board . It also provides Power switch cable and Power LED cable and Reset cable which can connect to J18 Pin header to enable power button and reset button on front face. Port definitions Aluminum Heat sinks Acrylic panel How to assemble it Insert Raspberry Pi CM4 module onto Super6C motherboard. Paste thermal pad after pilling off the protection film. NOTE: Since there are many versions of CM4, the heat sink is customized with EMMC and WIFI version, which is backward compatible with the CM4 Lite version. When installing the heat sink, you only need to paste the thermal pad on the CPU. Fix aluminum heat sink with M2.5 screws. Repeat Step1 \u2013 Step3 six times. Fix Super6C motherboard to case with flat head screws. Connect USB extension cable to J6 Pin header as following figure. Fix acrylic panel with screws. Related Product Super6C","title":"DeskPi ITX Case Kit for Super6C"},{"location":"itxcase/#deskpi-itx-case-kit-for-super6c","text":"","title":"DeskPi ITX Case Kit for Super6C"},{"location":"itxcase/#purchase","text":"DeskPi ITX Case Kit for Super6C","title":"Purchase"},{"location":"itxcase/#description","text":"ITX Case kit for DeskPi Super6C is a Mini ITX series Case for DeskPi Super6C motherboard. 3 high speed fan provides super cooling effect for your Super6C Cluster. It provides you with the protection of the compact house structure, the acrylic shell on the top provides a better effect, allowing you to disassemble the shell in the case of Provide better effect to grasp the status information of each CM4.","title":"Description"},{"location":"itxcase/#specifications","text":"Type: ITX Case Motherboard Support: Super6C motherboard ONLY Length Supported: 196mm x 220mm x 54mm Storage Support: M.2 SATA SSD, M.2 NVME SSD, TF card. Included Fans: 3 x 12V Fan Dimension: 270x235x65 mm SKU: DP-0010 Weight: gross weight/net weight: 1.230kg/1.04kg","title":"Specifications:"},{"location":"itxcase/#fan-specifications","text":"Power: 12V DC Current: 0.05A Speed: 6000RPM Fan Air Volume 4.96CFM Fan Air Pressure 21.16DBa","title":"Fan Specifications\uff1a"},{"location":"itxcase/#product-outlook","text":"","title":"Product outlook"},{"location":"itxcase/#product-includes","text":"1 x ITX Case 6 x Aluminum heat sink for Raspberry Pi CM4 module. 3 x Fan 1 x Screwdriver","title":"Product Includes"},{"location":"itxcase/#gallery","text":"Front face","title":"Gallery"},{"location":"itxcase/#power-button","text":"Functionality: Short press \u2013 power on Long press \u2013 force power off","title":"Power button"},{"location":"itxcase/#reset-button","text":"Functionality: * Press once \u2013 Reset the motherboard NOTE: Every CM4 module will be restart at the same time, unsaved data may be lost, please pay attention to use it carefully","title":"Reset button"},{"location":"itxcase/#inside-itx-case","text":"NOTE: Raspberry Pi CM4 modules are not included in the package. require additional purchase. The case provides some features on super6C motherboard, such as USB port, you can connect the \u201cUSB cable\u201d to super6C J6 pin header to extended the USB port to front USB port, and There are 3 Fan Cables for three Fans inside the case. you could connect them from FAN , FAN2 , FAN3 on board . It also provides Power switch cable and Power LED cable and Reset cable which can connect to J18 Pin header to enable power button and reset button on front face.","title":"Inside ITX case"},{"location":"itxcase/#port-definitions","text":"","title":"Port definitions"},{"location":"itxcase/#aluminum-heat-sinks","text":"","title":"Aluminum Heat sinks"},{"location":"itxcase/#acrylic-panel","text":"","title":"Acrylic panel"},{"location":"itxcase/#how-to-assemble-it","text":"Insert Raspberry Pi CM4 module onto Super6C motherboard. Paste thermal pad after pilling off the protection film. NOTE: Since there are many versions of CM4, the heat sink is customized with EMMC and WIFI version, which is backward compatible with the CM4 Lite version. When installing the heat sink, you only need to paste the thermal pad on the CPU. Fix aluminum heat sink with M2.5 screws. Repeat Step1 \u2013 Step3 six times. Fix Super6C motherboard to case with flat head screws. Connect USB extension cable to J6 Pin header as following figure. Fix acrylic panel with screws.","title":"How to assemble it"},{"location":"itxcase/#related-product","text":"Super6C","title":"Related Product"},{"location":"microcar/","text":"DeskPi MicroCar Revision History Date Version Description July 4, 2023 V1.0 Initial release Introduction DeskPi MicroCar is a multi-functional and multi-purpose intelligent cart, Based on microbit. it has on-board motors, ultrasonic, and other sensors, programmed and controlled by Makecode, adoption of graphical programming language. This car especially suitable for students with zero or weak programming fundamentals. This car contains the introduction of the use of independent modules on the trolley and the introduction of comprehensive application cases, first learn the basics, and then comprehensive application, step by step, to enhance the students' hands-on and programming capabilities. Key Features Designed for Microbit All modules are pre-wired 9 types easy-to-use modules 4 WS2812 RGB leds 0.96\u2019\u2019 128x64 OLED Display Volume detection 2 Optical sensors 2 Programmable keys 2 Grayscale sensors Ultrasonic IR receiver 2 Motors Powered by 3 x #7 1.5V batteries, separate power control switch 2 servo expansion ports with 4 x M3 structural extension threaded holes What\u2019s Included 1 x Micro:bit 1 x DeskPi MicroCar 1 x OLED Desplay 1 x Utrasonic Sensor 1 x Remote Control 1 x Gimbal 2 x Wheels 2 x Motor Mounting Brackets 10 x M3*5 Bolts 1 x Micro USB Cable Pinout Diagram Assembly Instructions a) Using 4 x M3*5 Bolts to fix the 2 x Motor Mounting Brackets b) Fixing of two wheels on the axle c) Using 2 x M3x5 Bolts to fix the Gimbal Getting Started with Micro:bit and Makecode Micro:bit is a microcontroller designed by the British BBC with ARM architecture. It has many on-board sensors, such as bluetooth, accelerometer, electronic compass, three buttons, 5 \u00d7 5 LED Dot Matrix Screen. It\u2019s mainly used for youth programming education. MakeCode is the official platform for micro:bit, enabling easy coding for beginners and advanced users. Create interactive projects, games, and more with its user-friendly drag-and-drop or Python interface. The possibilities are limitless! Individual Module Examples This section contains of several example codes. These examples illustrate the use of each module on MicroCar. Mastering the use of individual modules, so we can achieve better integrated applications. In this part, we need to make sure that the Micro:bit is always plugged into the female socket. Open this address https://makecode.microbit.org/ , and start to code! Hex File and Diagram Download There are two zipped files which contains all demo codes and diagram pictures. Download by click following items: * Individual Module * Integrated Application or you can visit GitHub repository by clicking Here: MicroCar RGB LEDs DeskPi MicroCar has four WS2812 RGB LEDs pre-wired to Pin6 on the Miro:bit. n Extensions module, enter neopixel and select neopixel module. { width=80% } Following the code below, you can modify the color of the LEDs. Note: In this example, you need to make sure that the led enable is false . Using the USB connection cable, connect Micro:bit to your computer, Refresh the page and it will connect automatically. Click download, and when it's done, you'll see the light-up effect. Note: If it\u2019s not connect automatically, try click and choose the first options to connect. In this example, you need to make sure that the lattice screen is disable(Using RGB requires). OLED Display DeskPi MicroCar has a 128x64 OLED Display. Plug it into the IIC interface. In Extensions module, enter OLED and select OLED12864_I2C module. Following the code below, You can write the characters you want to display. Download the program and your word will be displayed. Note: In this example, you need to make sure that the led enable is false (Using OLED requires). Volume Detection DeskPi MicroCar has one volume detection sensor pre-wired to Pin3 on the Miro:bit. Using OLED display to show it\u2019s readouts. Following the code below. Download the program and speak to the volume sensor and you\u2019ll see the the changing numbers on the display. Optical Sensors DeskPi MicroCar has two opetical sensors pre-wired to Pin0 for the right one and Pin4 for the left one. Using OLED display to show it\u2019s readouts. Following the code below. Download the program and using the light exposure sensors, you\u2019ll see the the changing numbers on the OLED. Note: In this example, you need to make sure that the led enable is false(Using opetical requires). Button DeskPi MicroCar has two push buttons pre-wired to Pin5 for the right one and Pin11 for the left one. Using OLED display to show it\u2019s readouts. Following the code below. Download the program and pushing buttons, you\u2019ll see the the changing numbers on the OLED, finding out what state is \u201c0\u201d or \u201c1\u201d. Grayscale DeskPi MicroCar has two grayscale Sensors pre-wired to Pin2 for the right one and Pin1 for the left one. Using OLED display to show it\u2019s readouts. Following the code below. Download the program, placing the sensor on a black or white plane, you\u2019ll see the the changing numbers on the OLED, finding out what are the readings on the different colors. Ultrasonic DeskPi MicroCar has a ultrasonic sensor pre-wired to Pin9 for Echo pin and Pin12 for the Trig pin . Plug it into the Ultrasonic interface. In Extensions module, enter HC-SR04 and select makerbit-ultrasonic module, OELD module is also needed. Following the code below. Download the program, placing the sensor face objects at different distances. You\u2019ll see the the changing numbers on the OLED, and the numbers means the distance between ultrasonic sensor and the objesct. IR Receiver DeskPi MicroCar has a IR receiver module pre-wired to Pin7 . In Extensions module, enter IR and select makerbit-ir-receiver module , OELD module is also needed. The IR Receiver accepts key commands from the remote control. Following the code below. Download the program, press different buttons against the IR Receiver and watch the code on the OLED, the code\u2019s type is \u201c0x00+6-bit character\u201d\uff0c such as the button\u2019s code is \u201c0x00FFA25D\u201d. Motors DeskPi MicroCar has two motors, There are 2 signal wires for each motor, see the table below for details. The speed and direction of rotation of each motor can be programmed. Following the code below. Download the program, left motor runs, change the difference of Pin13 and Pin14 . The larger the difference, the faster the speed. Simply swap the values of the them to achieve rotation in the opposite direction. The right motor is just like this. Interesting integrated application Obstacle Avoidance Car We can use ultrasonic to make a car that can automatically avoid obstacles, when there is no obstacle in front, the car moves forward, when there is an obstacle at a certain distance in front, the car decelerates, and when the obstacle distance is particularly close, the car settles down and rotates to the left/right for a certain distance and repeats the detection. Light-catching Car There two Optical Sensors on the Deskpi MicroCar, we can use that to control movement of the car. If the left optical readouts is larger than the right\u2019s, the car turn left. If the both are small than a number, the car move forward. If the both are larger than a number, the car move backward. Note: We need to get the different readouts of the two opticals in the normal lights, in this example, the left readout is 50 and the right one is 100. Remote Control Car DeskPi MicroCar has a remote control, and it can be used to control the car\u2019s moving! we choose several buttons to control the car. Button on the remote control code Funtion: Line follower Car DeskPi MicroCar\u2019s two grayscale Sensors makes it can follow a line to run, the readouts on dark areas is smaller than light areas. If the two sensors\u2019s readout are all very large, that means they are on the line, the car move forward, if the left\u2019s readout is smaller, that means the car need to move rigth, otherwise move left. We can use dark-colored tape on the light-colored smooth ground or tabletop to stick out a track and run the car on it, it should be noted that the width of the tape should be between 2.5cm-3cm, and the track's can't have right-angled bends, and the bends should have a certain curvature. Concluding Remarks Congratulations on completing the learning of the DeskPi MicroCar, this manul gives the basic application examples and simple combination of applications, you can again based on the development of more and more interesting gameplay, such as adding sound and light effects, adding speed changes, etc., enjoy the design!","title":"DeskPi MicroCar"},{"location":"microcar/#deskpi-microcar","text":"","title":"DeskPi MicroCar"},{"location":"microcar/#revision-history","text":"Date Version Description July 4, 2023 V1.0 Initial release","title":"Revision History"},{"location":"microcar/#introduction","text":"DeskPi MicroCar is a multi-functional and multi-purpose intelligent cart, Based on microbit. it has on-board motors, ultrasonic, and other sensors, programmed and controlled by Makecode, adoption of graphical programming language. This car especially suitable for students with zero or weak programming fundamentals. This car contains the introduction of the use of independent modules on the trolley and the introduction of comprehensive application cases, first learn the basics, and then comprehensive application, step by step, to enhance the students' hands-on and programming capabilities.","title":"Introduction"},{"location":"microcar/#key-features","text":"Designed for Microbit All modules are pre-wired 9 types easy-to-use modules 4 WS2812 RGB leds 0.96\u2019\u2019 128x64 OLED Display Volume detection 2 Optical sensors 2 Programmable keys 2 Grayscale sensors Ultrasonic IR receiver 2 Motors Powered by 3 x #7 1.5V batteries, separate power control switch 2 servo expansion ports with 4 x M3 structural extension threaded holes","title":"Key Features"},{"location":"microcar/#whats-included","text":"1 x Micro:bit 1 x DeskPi MicroCar 1 x OLED Desplay 1 x Utrasonic Sensor 1 x Remote Control 1 x Gimbal 2 x Wheels 2 x Motor Mounting Brackets 10 x M3*5 Bolts 1 x Micro USB Cable","title":"What\u2019s Included"},{"location":"microcar/#pinout-diagram","text":"","title":"Pinout Diagram"},{"location":"microcar/#assembly-instructions","text":"a) Using 4 x M3*5 Bolts to fix the 2 x Motor Mounting Brackets b) Fixing of two wheels on the axle c) Using 2 x M3x5 Bolts to fix the Gimbal","title":"Assembly Instructions"},{"location":"microcar/#getting-started-with-microbit-and-makecode","text":"Micro:bit is a microcontroller designed by the British BBC with ARM architecture. It has many on-board sensors, such as bluetooth, accelerometer, electronic compass, three buttons, 5 \u00d7 5 LED Dot Matrix Screen. It\u2019s mainly used for youth programming education. MakeCode is the official platform for micro:bit, enabling easy coding for beginners and advanced users. Create interactive projects, games, and more with its user-friendly drag-and-drop or Python interface. The possibilities are limitless!","title":"Getting Started with Micro:bit and Makecode"},{"location":"microcar/#individual-module-examples","text":"This section contains of several example codes. These examples illustrate the use of each module on MicroCar. Mastering the use of individual modules, so we can achieve better integrated applications. In this part, we need to make sure that the Micro:bit is always plugged into the female socket. Open this address https://makecode.microbit.org/ , and start to code!","title":"Individual Module Examples"},{"location":"microcar/#hex-file-and-diagram-download","text":"There are two zipped files which contains all demo codes and diagram pictures. Download by click following items: * Individual Module * Integrated Application or you can visit GitHub repository by clicking Here: MicroCar","title":"Hex File and Diagram Download"},{"location":"microcar/#rgb-leds","text":"DeskPi MicroCar has four WS2812 RGB LEDs pre-wired to Pin6 on the Miro:bit. n Extensions module, enter neopixel and select neopixel module. { width=80% } Following the code below, you can modify the color of the LEDs. Note: In this example, you need to make sure that the led enable is false . Using the USB connection cable, connect Micro:bit to your computer, Refresh the page and it will connect automatically. Click download, and when it's done, you'll see the light-up effect. Note: If it\u2019s not connect automatically, try click and choose the first options to connect. In this example, you need to make sure that the lattice screen is disable(Using RGB requires).","title":"RGB LEDs"},{"location":"microcar/#oled-display","text":"DeskPi MicroCar has a 128x64 OLED Display. Plug it into the IIC interface. In Extensions module, enter OLED and select OLED12864_I2C module. Following the code below, You can write the characters you want to display. Download the program and your word will be displayed. Note: In this example, you need to make sure that the led enable is false (Using OLED requires).","title":"OLED Display"},{"location":"microcar/#volume-detection","text":"DeskPi MicroCar has one volume detection sensor pre-wired to Pin3 on the Miro:bit. Using OLED display to show it\u2019s readouts. Following the code below. Download the program and speak to the volume sensor and you\u2019ll see the the changing numbers on the display.","title":"Volume Detection"},{"location":"microcar/#optical-sensors","text":"DeskPi MicroCar has two opetical sensors pre-wired to Pin0 for the right one and Pin4 for the left one. Using OLED display to show it\u2019s readouts. Following the code below. Download the program and using the light exposure sensors, you\u2019ll see the the changing numbers on the OLED. Note: In this example, you need to make sure that the led enable is false(Using opetical requires).","title":"Optical Sensors"},{"location":"microcar/#button","text":"DeskPi MicroCar has two push buttons pre-wired to Pin5 for the right one and Pin11 for the left one. Using OLED display to show it\u2019s readouts. Following the code below. Download the program and pushing buttons, you\u2019ll see the the changing numbers on the OLED, finding out what state is \u201c0\u201d or \u201c1\u201d.","title":"Button"},{"location":"microcar/#grayscale","text":"DeskPi MicroCar has two grayscale Sensors pre-wired to Pin2 for the right one and Pin1 for the left one. Using OLED display to show it\u2019s readouts. Following the code below. Download the program, placing the sensor on a black or white plane, you\u2019ll see the the changing numbers on the OLED, finding out what are the readings on the different colors.","title":"Grayscale"},{"location":"microcar/#ultrasonic","text":"DeskPi MicroCar has a ultrasonic sensor pre-wired to Pin9 for Echo pin and Pin12 for the Trig pin . Plug it into the Ultrasonic interface. In Extensions module, enter HC-SR04 and select makerbit-ultrasonic module, OELD module is also needed. Following the code below. Download the program, placing the sensor face objects at different distances. You\u2019ll see the the changing numbers on the OLED, and the numbers means the distance between ultrasonic sensor and the objesct.","title":"Ultrasonic"},{"location":"microcar/#ir-receiver","text":"DeskPi MicroCar has a IR receiver module pre-wired to Pin7 . In Extensions module, enter IR and select makerbit-ir-receiver module , OELD module is also needed. The IR Receiver accepts key commands from the remote control. Following the code below. Download the program, press different buttons against the IR Receiver and watch the code on the OLED, the code\u2019s type is \u201c0x00+6-bit character\u201d\uff0c such as the button\u2019s code is \u201c0x00FFA25D\u201d.","title":"IR Receiver"},{"location":"microcar/#motors","text":"DeskPi MicroCar has two motors, There are 2 signal wires for each motor, see the table below for details. The speed and direction of rotation of each motor can be programmed. Following the code below. Download the program, left motor runs, change the difference of Pin13 and Pin14 . The larger the difference, the faster the speed. Simply swap the values of the them to achieve rotation in the opposite direction. The right motor is just like this.","title":"Motors"},{"location":"microcar/#interesting-integrated-application","text":"","title":"Interesting integrated application"},{"location":"microcar/#obstacle-avoidance-car","text":"We can use ultrasonic to make a car that can automatically avoid obstacles, when there is no obstacle in front, the car moves forward, when there is an obstacle at a certain distance in front, the car decelerates, and when the obstacle distance is particularly close, the car settles down and rotates to the left/right for a certain distance and repeats the detection.","title":"Obstacle Avoidance Car"},{"location":"microcar/#light-catching-car","text":"There two Optical Sensors on the Deskpi MicroCar, we can use that to control movement of the car. If the left optical readouts is larger than the right\u2019s, the car turn left. If the both are small than a number, the car move forward. If the both are larger than a number, the car move backward. Note: We need to get the different readouts of the two opticals in the normal lights, in this example, the left readout is 50 and the right one is 100.","title":"Light-catching Car"},{"location":"microcar/#remote-control-car","text":"DeskPi MicroCar has a remote control, and it can be used to control the car\u2019s moving! we choose several buttons to control the car. Button on the remote control code Funtion:","title":"Remote Control Car"},{"location":"microcar/#line-follower-car","text":"DeskPi MicroCar\u2019s two grayscale Sensors makes it can follow a line to run, the readouts on dark areas is smaller than light areas. If the two sensors\u2019s readout are all very large, that means they are on the line, the car move forward, if the left\u2019s readout is smaller, that means the car need to move rigth, otherwise move left. We can use dark-colored tape on the light-colored smooth ground or tabletop to stick out a track and run the car on it, it should be noted that the width of the tape should be between 2.5cm-3cm, and the track's can't have right-angled bends, and the bends should have a certain curvature.","title":"Line follower Car"},{"location":"microcar/#concluding-remarks","text":"Congratulations on completing the learning of the DeskPi MicroCar, this manul gives the basic application examples and simple combination of applications, you can again based on the development of more and more interesting gameplay, such as adding sound and light effects, adding speed changes, etc., enjoy the design!","title":"Concluding Remarks"},{"location":"minipc/","text":"DeskPi Mini Cube New Product: \u2b50\u2b50\u2b50\u2b50\u2b50 Compability: \u2b50\u2b50\u2b50\u2b50 Mobility: \u2b50\u2b50\u2b50\u2b50\u2b50 Assemble Difficulty: \u2b50 Purchase DeskPi Mini Cube Description DeskPi Mini Cube for Raspberry Pi CM4 is a case with a miniature appearance and extremely portable features. Note: Only supports Raspberry Pi CM4 module The device provides a mini aluminum alloy radiator and integrates a silent fan that supports PWM speed regulation. The bottom board provides a wealth of interfaces, supporting dual full-size HDMI interfaces, RJ45 Ethernet interfaces, 2x OTG USB port, and one PCIe interface supports M.2 NVME SSD M-KEY 2242 external storage. The DIP switch on the back provides the special pins needed to configure the Raspberry Pi CM4 module. (On Compute Module 4 EMMC-DISABLE / nRPIBOOT (GPIO 40) must be fitted to switch the ROM to usbboot mode.) Otherwise, the SPI EEPROM bootloader image will be loaded instead. The 40Pin GPIO lead out and reserved RTC clock battery interface. Features Integrated design Aluminum alloy radiator with PWM adjustable speed fan Power button 2 x Full-size HDMI ports 2 x OTG USB2.0 port 1 x PCIe M.2 NVME M-KEY 2242 SSD slot 1 x 40 Pin GPIO lead out 1 x DIP switch for mode change (CM4 function change) 1 x Onboard PCF85063 I2C RTC module 5V USB-C Port Power IN Gallery Product Outlook Backside of Mini Cube Ports Definitions Inside of Mini Cube Dimension IPX antenna specifications Centre Frequency: 2400-2500MHz & 4900-5900MHz Connector: IPEX1 Lead Length: Antenna Element Length: mm (+/- 1mm) Antenna Element Cable: 1.13 Coaxial cable, with plastic coating. Impedance: 5Ohm. Gain: About 3 dBi. Install IPEX Antenna Add the antenna as following figure, and then remove the protection film on back of the antenna, and then paste it inside the case. RTC Battery Information ear RTC Battery dose not include in the package, additional purchase required! * Fit for: laptop CMOS Battery, Recommended CR1220 3V with ZH1.25 Connector. Package Includes 1 x DeskPi Mini Cube for Raspberry Pi computer module 4 How to assemble it Step 1. Unloose four screws on top of mini cube. Step 2. Remove copper pillar and paste thermal pad on top of Raspberry Pi CM4 module. NOTE\uff1aPlease peel off the protection film on both side of the thermal pad. and press the Raspberry Pi CM4 module according to following figure, please be ware of the direction and angle when press the Raspberry Pi CM4 module. Step 3. Fix aluminum heat sink to Raspberry Pi CM4 module with copper pillars. Please refer to following figure to assemble it. [Optional] Install M.2 NVME SSD M-KEY 2242/2240. Remove the screws on bottom of mini cube and remove the PCB which is connected to mainboard on 40Pin GPIO. Insert SSD drive into the slot in 45-degree angle and fix it with screw. Cover it back to 40Pin GPIO and make sure it connect properly. Fix the bottom case with screws. Functionality of power button: Short Press: Power on Long Press: Power off (Cutoff power) Please NOTE that if you have not shutdown the system, do not use long press to halt system, it will damage your system, it may cause kernel panic or lost file which are not saved yet. Correct Operation : Shutdown system in terminal or desktop, and then long press the button to cut off power. DIP Switch Functionality DIP Switch Pinout 1 - USB OTG Pull UP 2 - UNATTENDEND 3 - EEPROM_nWP (EEPROM write protection) 4.- nRPIBOOT (disable or enable eMMC Boot) If you are using Raspberry Pi CM4 with EMMC onboard. please refer to this URL: How to flash the Compute Module in section \u201cFlashing the Compute Module eMMC\u201d Hardware write-protection must be enabled via software and then locked by pulling the EEPROM_nWP pin low. How to enable USB2.0 ports besides the USB-C port? Assume that you are using Raspberry Pi OS (64bit/32bit). The latest official image which you can download from: www.raspberrypi.com/software will automatically adding otg_mode=1 in /boot/firmware/config.txt file, so you don't need to modify any parameter in /boot/firmware/config.txt file. How to update eeprom on CM4 by using mini cube? This is the USB device boot code which supports the Raspberry Pi 1A, 3A+, Computer Module, Computer Module 3,3+,4S and 4, Raspberry Pi Zero and Zero 2W. N.B. In regards to this document CM4 and CM4S have identical software support. The default behaviour when run with no arguments is to boot the Raspberry Pi with special firmware so that it emulates USB Mass Storage Device (MSD). The host OS will treat this as a normal USB mass storage device allowing the file system to be accessed. If the storage has not been formatted yet (default for Compute Module) then the Raspberry Pi Imager App can be used to install a new operating system. Since RPIBOOT is a generic firmware loading interface, it is possible to load other versions of the firmware by passing the -d flag to specify the directory where the firmware should be loaded from. E.g. The firmware in the msd can be replaced with newer/older versions. From Raspberry Pi5 onwards the MSD firmware has been replaced with a Linux initramfs providing a mass-storage-gadget. For more information run rpiboot -h . Building Linux / Cygwin / WSL Clone this repository on your Pi or other Linux machine. Make sure that the system date is set correctly, otherwise Git may produce an error. This git repository uses symlinks. For Windows builds clone the repository under Cygwin sudo apt install git libusb-1.0-0-dev pkg-config build-essential git clone --depth = 1 https://github.com/raspberrypi/usbboot cd usbboot make sudo ./rpiboot sudo isn't required if you have write permissions for the /dev/bus/usb device. macOS From a macOS machine, you can also run usbboot, just follow the same steps: Clone the usbboot repository Install libusb (brew install libusb) Install pkg-config (brew install pkg-config) (Optional) Export the PKG_CONFIG_PATH so that it includes the directory enclosing libusb-1.0.pc Build using make Run the binary git clone --depth = 1 https://github.com/raspberrypi/usbboot cd usbboot brew install libusb brew install pkg-config make sudo ./rpiboot If the build is unable to find the header file libusb.h then most likely the PKG_CONFIG_PATH is not set properly. This should be set via export PKG_CONFIG_PATH=\"$(brew --prefix libusb)/lib/pkgconfig\". If the build fails on an ARM-based Mac with a linker error such as ld: warning: ignoring file /usr/local/Cellar/libusb/1.0.26/lib/libusb-1.0.dylib, building for macOS-arm64 but attempting to link with file built for macOS-x86_64 then you may need to build and install libusb-1.0 yourself: $ wget https://github.com/libusb/libusb/releases/download/v1.0.26/libusb-1.0.26.tar.bz2 $ tar -xf libusb-1.0.26.tar.bz2 $ cd libusb-1.0.26 $ ./configure $ make $ make check $ sudo make install Running make again should now succeed. Running Compute Module 3 Fit the EMMC-DISABLE jumper on the Compute Module IO board before powering on the board or connecting the USB cable. Compute Module 4 On Compute Module 4 EMMC-DISABLE / nRPIBOOT (GPIO 40) must be fitted to switch the ROM to usbboot mode. Otherwise, the SPI EEPROM bootloader image will be loaded instead. Connect the USB-C cable (from the RPIBOOT host to the MiniCube) Compute Module 4 Update the SPI EEPROM bootloader. To update the SPI EEPROM bootloader on a Compute Module 4. Modify the EEPROM configuration as desired Optionally, replace pieeprom.original.bin with a custom version. The default version here is the latest stable release recommended for use on Compute Module 4. N.B The bootcode4.bin file in this directory is actually the recovery.bin file used on Raspberry Pi 4 bootloader update cards. cd recovery ./update-pieeprom.sh ../rpiboot -d . Booting Linux The RPIBOOT protocol provides a virtual file system to the Raspberry Pi bootloader and GPU firmware. It's therefore possible to boot Linux. To do this, you will need to copy all of the files from a Raspberry Pi boot partition plus create your own initramfs. On Raspberry Pi 4 / CM4 the recommended approach is to use a boot.img which is a FAT disk image containing the minimal set of files required from the boot partition. Troubleshooting This section describes how to diagnose common rpiboot failures for Compute Modules. Whilst rpiboot is tested on every Compute Module during manufacture the system relies on multiple hardware and software elements. The aim of this guide is to make it easier to identify which component is failing. Hardware Inspect the Compute Module pins and connector for signs of damage and verify that the socket is free from debris. Check that the Compute Module is fully inserted. Check that nRPIBOOT / EMMC disable is pulled low BEFORE powering on the device. On BCM2711, if the USB cable is disconected and the nRPIBOOT jumper is fitted then the green LED should be OFF. If the LED is on then the ROM is detecting that the GPIO for nRPIBOOT is high. Remove any hubs between the Compute Module and the host. Disconnect all other peripherals from the IO board. Verify that the red power LED switches on when the IO board is powered. Use another computer to verify that the USB cable for rpiboot can reliably transfer data. For example, connect it to a Raspberry Pi keyboard with other devices connected to the keyboard USB hub. Hardware - CM4 The CM4 EEPROM supports MMC, USB-MSD, USB 2.0, Network and NVMe boot by default. Try booting to Linux from an alternate boot mode (e.g. network) to verify the nRPIBOOT GPIO can be pulled low and that the USB 2.0 interface is working. If rpiboot is running but the mass storage device does not appear then try running the rpiboot -d mass-storage-gadget because this uses Linux instead of a custom VPU firmware to implement the mass-storage gadget. This also provides a login console on UART and HDMI. Software The recommended host setup is Raspberry Pi with Raspberry Pi OS. Alternatively, most Linux X86 builds are also suitable. Windows adds some extra complexity for the USB drivers so we recommend debugging on Linux first. Update to the latest software release using apt update rpiboot or download and rebuild this repository from Github. Run rpiboot -v | tee log to capture verbose log output. N.B. This can be very verbose on some systems. bootcode.bin Be careful not to overwrite bootcode.bin or bootcode4.bin with the executable from a different subdirectory. The rpiboot process simply looks for a file called bootcode.bin (or bootcode4.bin on BCM2711). However, the file in recovery / secure-boot-recovery directories is actually the recovery.bin EEPROM flashing tool. How to enable fan automatically? Assume that your operating system is Raspberry Pi OS (32bit/64bit) Official Fan setting Open a terminal and typing following command: sudo raspi-config Navigate to Performance Options -> P4 Fan -> Yes -> 14 -> 60 -> yes -> finish -> reboot Raspberry Pi. The fan is support PWM signal control via GPIO14 which is physical pin 12 (TXD), it will spinning when the CPU temperature is above 60 degree. and also you can write your code to control the fan via GPIO14 , sending PWM signal will trigger the fan spinning. Control Fan manually Demo code Here is a demo code for controlling fan speed by using python script. #!/usr/bin/python3 import RPi.GPIO as GPIO import time import subprocess GPIO . setmode ( GPIO . BCM ) GPIO . setup ( 14 , GPIO . OUT ) pwm = GPIO . PWM ( 14 , 100 ) print ( \" \\n Press Ctrl+C to quit \\n \" ) dc = 0 pwm . start ( dc ) try : while True : temp = subprocess . getoutput ( \"vcgencmd measure_temp|sed 's/[^0-9.]//g'\" ) if round ( float ( temp )) >= 45 : dc = 100 pwm . ChangeDutyCycle ( dc ) print ( \"CPU Temp:\" , float ( temp ), \" Fan duty cycle:\" , dc ) time . sleep ( 180.0 ) if round ( float ( temp )) >= 40 : dc = 85 pwm . ChangeDutyCycle ( dc ) print ( \"CPU Temp:\" , float ( temp ), \" Fan duty cycle:\" , dc ) time . sleep ( 120.0 ) else : dc = 70 pwm . ChangeDutyCycle ( dc ) print ( \"CPU Temp:\" , float ( temp ), \" Fan duty cycle:\" , dc ) time . sleep ( 60.00 ) except KeyboardInterrupt : pwm . stop () GPIO . cleanup () print ( \"Ctrl + C pressed -- Ending program\" ) Then execute it: python3 fan_control.py How to enable onboard RTC module? NOTE : RTC battery sock type: ZH1.25 The battery dose not include in the package, additional purchase required!! * Step 1. Modify /boot/config.txt file and adding following parameter: dtoverlay = i2c-rtc,pcf85063a,i2c_csi_dsi,addr = 0x51 Save it and please reboot your Raspberry Pi. Step 2. Check if RTC module has been recognized by Raspberry Pi. Execute following command in a terminal: dmesg | grep i2c i2cdetect -y 10 NOTE: if command not found, please install i2c-tools : sudo apt update sudo apt upgrade -y sudo apt -y install i2c-tool Step 3. Probe the module rtc-pcf85063 and check the kernel module status. modprobe rtc-pcf85063 lsmod | grep rtc Step 4. Setting system date and sychronized system time to Hardware clock time. ** Check RTC time in command line. cat /proc/driver/rtc Setting system time Syntax** date [ -u | --utc | --universal ] [ MMDDhhmm [[ CC ] YY ][ .ss ]] For example: sudo date -s 'tue oct 18 08:50:23 BST 2022' or sudo date 053118062023 .22 It means setting system time to 2023.05.31 18:06:23. Sychronizing system time to HW clock time. sudo hwclock -w Check RTC time and system time sudo hwclock ; date FAQ Q: Dose it support NVMe SSD booting? A: It has been tested, yes, it supports, but you may need to upgrade eeprom by using rpi-boot from official github repository.","title":"DeskPi Mini PC"},{"location":"minipc/#deskpi-mini-cube","text":"New Product: \u2b50\u2b50\u2b50\u2b50\u2b50 Compability: \u2b50\u2b50\u2b50\u2b50 Mobility: \u2b50\u2b50\u2b50\u2b50\u2b50 Assemble Difficulty: \u2b50","title":"DeskPi Mini Cube"},{"location":"minipc/#purchase","text":"DeskPi Mini Cube","title":"Purchase"},{"location":"minipc/#description","text":"DeskPi Mini Cube for Raspberry Pi CM4 is a case with a miniature appearance and extremely portable features. Note: Only supports Raspberry Pi CM4 module The device provides a mini aluminum alloy radiator and integrates a silent fan that supports PWM speed regulation. The bottom board provides a wealth of interfaces, supporting dual full-size HDMI interfaces, RJ45 Ethernet interfaces, 2x OTG USB port, and one PCIe interface supports M.2 NVME SSD M-KEY 2242 external storage. The DIP switch on the back provides the special pins needed to configure the Raspberry Pi CM4 module. (On Compute Module 4 EMMC-DISABLE / nRPIBOOT (GPIO 40) must be fitted to switch the ROM to usbboot mode.) Otherwise, the SPI EEPROM bootloader image will be loaded instead. The 40Pin GPIO lead out and reserved RTC clock battery interface.","title":"Description"},{"location":"minipc/#features","text":"Integrated design Aluminum alloy radiator with PWM adjustable speed fan Power button 2 x Full-size HDMI ports 2 x OTG USB2.0 port 1 x PCIe M.2 NVME M-KEY 2242 SSD slot 1 x 40 Pin GPIO lead out 1 x DIP switch for mode change (CM4 function change) 1 x Onboard PCF85063 I2C RTC module 5V USB-C Port Power IN","title":"Features"},{"location":"minipc/#gallery","text":"Product Outlook Backside of Mini Cube Ports Definitions Inside of Mini Cube Dimension IPX antenna specifications Centre Frequency: 2400-2500MHz & 4900-5900MHz Connector: IPEX1 Lead Length: Antenna Element Length: mm (+/- 1mm) Antenna Element Cable: 1.13 Coaxial cable, with plastic coating. Impedance: 5Ohm. Gain: About 3 dBi.","title":"Gallery"},{"location":"minipc/#install-ipex-antenna","text":"Add the antenna as following figure, and then remove the protection film on back of the antenna, and then paste it inside the case.","title":"Install IPEX Antenna"},{"location":"minipc/#rtc-battery-information","text":"ear RTC Battery dose not include in the package, additional purchase required! * Fit for: laptop CMOS Battery, Recommended CR1220 3V with ZH1.25 Connector.","title":"RTC Battery Information"},{"location":"minipc/#package-includes","text":"1 x DeskPi Mini Cube for Raspberry Pi computer module 4","title":"Package Includes"},{"location":"minipc/#how-to-assemble-it","text":"Step 1. Unloose four screws on top of mini cube. Step 2. Remove copper pillar and paste thermal pad on top of Raspberry Pi CM4 module. NOTE\uff1aPlease peel off the protection film on both side of the thermal pad. and press the Raspberry Pi CM4 module according to following figure, please be ware of the direction and angle when press the Raspberry Pi CM4 module. Step 3. Fix aluminum heat sink to Raspberry Pi CM4 module with copper pillars. Please refer to following figure to assemble it.","title":"How to assemble it"},{"location":"minipc/#optional-install-m2-nvme-ssd-m-key-22422240","text":"Remove the screws on bottom of mini cube and remove the PCB which is connected to mainboard on 40Pin GPIO. Insert SSD drive into the slot in 45-degree angle and fix it with screw. Cover it back to 40Pin GPIO and make sure it connect properly. Fix the bottom case with screws.","title":"[Optional] Install M.2 NVME SSD M-KEY 2242/2240."},{"location":"minipc/#functionality-of-power-button","text":"Short Press: Power on Long Press: Power off (Cutoff power) Please NOTE that if you have not shutdown the system, do not use long press to halt system, it will damage your system, it may cause kernel panic or lost file which are not saved yet. Correct Operation : Shutdown system in terminal or desktop, and then long press the button to cut off power.","title":"Functionality of power button:"},{"location":"minipc/#dip-switch-functionality","text":"","title":"DIP Switch Functionality"},{"location":"minipc/#dip-switch-pinout","text":"1 - USB OTG Pull UP 2 - UNATTENDEND 3 - EEPROM_nWP (EEPROM write protection) 4.- nRPIBOOT (disable or enable eMMC Boot) If you are using Raspberry Pi CM4 with EMMC onboard. please refer to this URL: How to flash the Compute Module in section \u201cFlashing the Compute Module eMMC\u201d Hardware write-protection must be enabled via software and then locked by pulling the EEPROM_nWP pin low.","title":"DIP Switch Pinout"},{"location":"minipc/#how-to-enable-usb20-ports-besides-the-usb-c-port","text":"Assume that you are using Raspberry Pi OS (64bit/32bit). The latest official image which you can download from: www.raspberrypi.com/software will automatically adding otg_mode=1 in /boot/firmware/config.txt file, so you don't need to modify any parameter in /boot/firmware/config.txt file.","title":"How to enable USB2.0 ports besides the USB-C port?"},{"location":"minipc/#how-to-update-eeprom-on-cm4-by-using-mini-cube","text":"This is the USB device boot code which supports the Raspberry Pi 1A, 3A+, Computer Module, Computer Module 3,3+,4S and 4, Raspberry Pi Zero and Zero 2W. N.B. In regards to this document CM4 and CM4S have identical software support. The default behaviour when run with no arguments is to boot the Raspberry Pi with special firmware so that it emulates USB Mass Storage Device (MSD). The host OS will treat this as a normal USB mass storage device allowing the file system to be accessed. If the storage has not been formatted yet (default for Compute Module) then the Raspberry Pi Imager App can be used to install a new operating system. Since RPIBOOT is a generic firmware loading interface, it is possible to load other versions of the firmware by passing the -d flag to specify the directory where the firmware should be loaded from. E.g. The firmware in the msd can be replaced with newer/older versions. From Raspberry Pi5 onwards the MSD firmware has been replaced with a Linux initramfs providing a mass-storage-gadget. For more information run rpiboot -h .","title":"How to update eeprom on CM4 by using mini cube?"},{"location":"minipc/#building","text":"Linux / Cygwin / WSL Clone this repository on your Pi or other Linux machine. Make sure that the system date is set correctly, otherwise Git may produce an error. This git repository uses symlinks. For Windows builds clone the repository under Cygwin sudo apt install git libusb-1.0-0-dev pkg-config build-essential git clone --depth = 1 https://github.com/raspberrypi/usbboot cd usbboot make sudo ./rpiboot sudo isn't required if you have write permissions for the /dev/bus/usb device.","title":"Building"},{"location":"minipc/#macos","text":"From a macOS machine, you can also run usbboot, just follow the same steps: Clone the usbboot repository Install libusb (brew install libusb) Install pkg-config (brew install pkg-config) (Optional) Export the PKG_CONFIG_PATH so that it includes the directory enclosing libusb-1.0.pc Build using make Run the binary git clone --depth = 1 https://github.com/raspberrypi/usbboot cd usbboot brew install libusb brew install pkg-config make sudo ./rpiboot If the build is unable to find the header file libusb.h then most likely the PKG_CONFIG_PATH is not set properly. This should be set via export PKG_CONFIG_PATH=\"$(brew --prefix libusb)/lib/pkgconfig\". If the build fails on an ARM-based Mac with a linker error such as ld: warning: ignoring file /usr/local/Cellar/libusb/1.0.26/lib/libusb-1.0.dylib, building for macOS-arm64 but attempting to link with file built for macOS-x86_64 then you may need to build and install libusb-1.0 yourself: $ wget https://github.com/libusb/libusb/releases/download/v1.0.26/libusb-1.0.26.tar.bz2 $ tar -xf libusb-1.0.26.tar.bz2 $ cd libusb-1.0.26 $ ./configure $ make $ make check $ sudo make install Running make again should now succeed.","title":"macOS"},{"location":"minipc/#running","text":"Compute Module 3 Fit the EMMC-DISABLE jumper on the Compute Module IO board before powering on the board or connecting the USB cable. Compute Module 4 On Compute Module 4 EMMC-DISABLE / nRPIBOOT (GPIO 40) must be fitted to switch the ROM to usbboot mode. Otherwise, the SPI EEPROM bootloader image will be loaded instead. Connect the USB-C cable (from the RPIBOOT host to the MiniCube)","title":"Running"},{"location":"minipc/#compute-module-4-update-the-spi-eeprom-bootloader","text":"To update the SPI EEPROM bootloader on a Compute Module 4. Modify the EEPROM configuration as desired Optionally, replace pieeprom.original.bin with a custom version. The default version here is the latest stable release recommended for use on Compute Module 4. N.B The bootcode4.bin file in this directory is actually the recovery.bin file used on Raspberry Pi 4 bootloader update cards. cd recovery ./update-pieeprom.sh ../rpiboot -d .","title":"Compute Module 4 Update the SPI EEPROM bootloader."},{"location":"minipc/#booting-linux","text":"The RPIBOOT protocol provides a virtual file system to the Raspberry Pi bootloader and GPU firmware. It's therefore possible to boot Linux. To do this, you will need to copy all of the files from a Raspberry Pi boot partition plus create your own initramfs. On Raspberry Pi 4 / CM4 the recommended approach is to use a boot.img which is a FAT disk image containing the minimal set of files required from the boot partition.","title":"Booting Linux"},{"location":"minipc/#troubleshooting","text":"This section describes how to diagnose common rpiboot failures for Compute Modules. Whilst rpiboot is tested on every Compute Module during manufacture the system relies on multiple hardware and software elements. The aim of this guide is to make it easier to identify which component is failing.","title":"Troubleshooting"},{"location":"minipc/#hardware","text":"Inspect the Compute Module pins and connector for signs of damage and verify that the socket is free from debris. Check that the Compute Module is fully inserted. Check that nRPIBOOT / EMMC disable is pulled low BEFORE powering on the device. On BCM2711, if the USB cable is disconected and the nRPIBOOT jumper is fitted then the green LED should be OFF. If the LED is on then the ROM is detecting that the GPIO for nRPIBOOT is high. Remove any hubs between the Compute Module and the host. Disconnect all other peripherals from the IO board. Verify that the red power LED switches on when the IO board is powered. Use another computer to verify that the USB cable for rpiboot can reliably transfer data. For example, connect it to a Raspberry Pi keyboard with other devices connected to the keyboard USB hub.","title":"Hardware"},{"location":"minipc/#hardware-cm4","text":"The CM4 EEPROM supports MMC, USB-MSD, USB 2.0, Network and NVMe boot by default. Try booting to Linux from an alternate boot mode (e.g. network) to verify the nRPIBOOT GPIO can be pulled low and that the USB 2.0 interface is working. If rpiboot is running but the mass storage device does not appear then try running the rpiboot -d mass-storage-gadget because this uses Linux instead of a custom VPU firmware to implement the mass-storage gadget. This also provides a login console on UART and HDMI.","title":"Hardware - CM4"},{"location":"minipc/#software","text":"The recommended host setup is Raspberry Pi with Raspberry Pi OS. Alternatively, most Linux X86 builds are also suitable. Windows adds some extra complexity for the USB drivers so we recommend debugging on Linux first. Update to the latest software release using apt update rpiboot or download and rebuild this repository from Github. Run rpiboot -v | tee log to capture verbose log output. N.B. This can be very verbose on some systems.","title":"Software"},{"location":"minipc/#bootcodebin","text":"Be careful not to overwrite bootcode.bin or bootcode4.bin with the executable from a different subdirectory. The rpiboot process simply looks for a file called bootcode.bin (or bootcode4.bin on BCM2711). However, the file in recovery / secure-boot-recovery directories is actually the recovery.bin EEPROM flashing tool.","title":"bootcode.bin"},{"location":"minipc/#how-to-enable-fan-automatically","text":"Assume that your operating system is Raspberry Pi OS (32bit/64bit)","title":"How to enable fan automatically?"},{"location":"minipc/#official-fan-setting","text":"Open a terminal and typing following command: sudo raspi-config Navigate to Performance Options -> P4 Fan -> Yes -> 14 -> 60 -> yes -> finish -> reboot Raspberry Pi. The fan is support PWM signal control via GPIO14 which is physical pin 12 (TXD), it will spinning when the CPU temperature is above 60 degree. and also you can write your code to control the fan via GPIO14 , sending PWM signal will trigger the fan spinning.","title":"Official Fan setting"},{"location":"minipc/#control-fan-manually","text":"","title":"Control Fan manually"},{"location":"minipc/#demo-code","text":"Here is a demo code for controlling fan speed by using python script. #!/usr/bin/python3 import RPi.GPIO as GPIO import time import subprocess GPIO . setmode ( GPIO . BCM ) GPIO . setup ( 14 , GPIO . OUT ) pwm = GPIO . PWM ( 14 , 100 ) print ( \" \\n Press Ctrl+C to quit \\n \" ) dc = 0 pwm . start ( dc ) try : while True : temp = subprocess . getoutput ( \"vcgencmd measure_temp|sed 's/[^0-9.]//g'\" ) if round ( float ( temp )) >= 45 : dc = 100 pwm . ChangeDutyCycle ( dc ) print ( \"CPU Temp:\" , float ( temp ), \" Fan duty cycle:\" , dc ) time . sleep ( 180.0 ) if round ( float ( temp )) >= 40 : dc = 85 pwm . ChangeDutyCycle ( dc ) print ( \"CPU Temp:\" , float ( temp ), \" Fan duty cycle:\" , dc ) time . sleep ( 120.0 ) else : dc = 70 pwm . ChangeDutyCycle ( dc ) print ( \"CPU Temp:\" , float ( temp ), \" Fan duty cycle:\" , dc ) time . sleep ( 60.00 ) except KeyboardInterrupt : pwm . stop () GPIO . cleanup () print ( \"Ctrl + C pressed -- Ending program\" ) Then execute it: python3 fan_control.py","title":"Demo code"},{"location":"minipc/#how-to-enable-onboard-rtc-module","text":"NOTE : RTC battery sock type: ZH1.25 The battery dose not include in the package, additional purchase required!! * Step 1. Modify /boot/config.txt file and adding following parameter: dtoverlay = i2c-rtc,pcf85063a,i2c_csi_dsi,addr = 0x51 Save it and please reboot your Raspberry Pi. Step 2. Check if RTC module has been recognized by Raspberry Pi. Execute following command in a terminal: dmesg | grep i2c i2cdetect -y 10 NOTE: if command not found, please install i2c-tools : sudo apt update sudo apt upgrade -y sudo apt -y install i2c-tool Step 3. Probe the module rtc-pcf85063 and check the kernel module status. modprobe rtc-pcf85063 lsmod | grep rtc Step 4. Setting system date and sychronized system time to Hardware clock time. ** Check RTC time in command line. cat /proc/driver/rtc Setting system time Syntax** date [ -u | --utc | --universal ] [ MMDDhhmm [[ CC ] YY ][ .ss ]] For example: sudo date -s 'tue oct 18 08:50:23 BST 2022' or sudo date 053118062023 .22 It means setting system time to 2023.05.31 18:06:23. Sychronizing system time to HW clock time. sudo hwclock -w Check RTC time and system time sudo hwclock ; date","title":"How to enable onboard RTC module?"},{"location":"minipc/#faq","text":"Q: Dose it support NVMe SSD booting? A: It has been tested, yes, it supports, but you may need to upgrade eeprom by using rpi-boot from official github repository.","title":"FAQ"},{"location":"picomate/","text":"DeskPi PicoMate User Manual Description DeskPi PicoMate is an all-in-one and versatile prototyping kit designed for Raspberry Pi Pico and Pico W. It includes one expansion dock for Raspberry Pi Pico and Pico W, 12 detachable modules and all in one- piece of PCB design. All modules are pre-wired to the Pico Dock, no soldering and wiring required and out-of-box. Of course, you can also detach the modules and connect them using the cables included in the box. Buy DeskPi PicoMate Visit DeskPi Official Website Features Designed for Raspberry Pi Pico and Pico W All modules are pre-wired, no soldering and wiring required and out-of-box 12 detachable and easy-to-use modules: Push Button WS2812 RGB LED Rotary Encoder Buzzer Digital Microphone (ZTS6531S) Digital PIR Sensor (AS312) 6-Axis IMU Sensor (LSM6DS3TR-C) Digital Optical Sensor (LTR-381RGB-01) 3-Axis Magnetometer (MMC5603NJ) Temperature & Humidity Sensor (SHT30-DIS) 0.96\u201d 128x64 OLED Display (SSD1315) 204 Pins Breakout Board All Pico GPIOs available via headers and up to 11 Grove connectors available Built-in battery connector for on-the-go projects MicroPython libraries support for all modules 3.3V IO operating voltage Package Includes 1x DeskPi PicoMate 1x Raspberry Pi Pico with pre-soldered pin headers 1x 3*AA Battery Holder with On/Off Switch 6x Grove Cable 1x Micro USB Cable Pinout Diagram Getting Start Getting Started with Python The DeskPi PicoMate can be programmed using the popular Python programming language. Raspberry Pi Pico is supported by CircuitPython, which is based on MicroPython, and features unified Python core APIs and a growing list of device libraries and drivers that work with it. This section describes how to set up CircuitPython on DeskPi PicoMate. Examples are also provided to help you to get started in a very short time Installing CircuitPython Download the official CircuiPython for Raspberry Pi Pico . Choose the latest stable release and then download the .uf2 file. Then go ahead and: Push and hold the BOOTSEL button and plug your Pico into the USB port of your computer. Release the BOOTSEL button after your Pico is connected. It will mount as a Mass Storage Device called RPI-RP2 . Drag and drop the CircuitPython UF2 file onto the RPI-RP2 volume. Your Pico will reboot. A new drive named CIRCUITPY should appear. Installing Mu Editor Mu Editor is a simple Python code editor for beginner programmers. Go to Mu Editor Download page , choose your Operational System and follow the instructions. MU Editor Once the Mu Editor is installed, open it, go to Mode menu, select CircuitPython and press OK . In the text editor, try some Python code: print ( 'Hello, DeskPi PicoMate!' ) Select Save on Top Menu. A window will appear. Give the name code.py for your code and save it on the CIRCUITPY drive. Your code will run as soon as the file is done saving. The Serial button opens a serial data connection to the Pico. This will result in a new panel between the text editor and Mu s footer, which prints the data from the Pico. If you need to drop into the CircuitPython REPL you should make sure the panel has keyboard focus (just click it!) and then type CTRL+ C . Now that you have the Python prerequisites installed, it is time to explore more examples for the DeskPi PicoMate. Python Examples This section consists of several example codes. The examples are organized in different levels of codes to demonstrate the Python API usage. Blink RGB LED DeskPi PicoMate has a WS2812 RGB LED pre-wired to GP22 on the Pico. We can use the NeoPixel library to blink the RGB LED. Breakable Design Download the NeoPixel library and copy neopixel.py into the CIRCUITPY/lib folder.This should give you the following folder structure: Copy and paste the following code to the Mu Editor and press Save : import time import board import neopixel R = ( 50 , 0 , 0 ) G = ( 0 , 50 , 0 ) B = ( 0 , 0 , 50 ) COLORS = ( R , G , B ) pixels = neopixel . NeoPixel ( board . GP22 , 1 ) while True : for color in COLORS : pixels [ 0 ] = color time . sleep ( 1 ) Your code will run as soon as the file is done saving. Observe that the RGB LED starts to blink. For more details about the Neopixel API reference, please check out Read the Docs Button DeskPi PicoMate has a Push Button pre-wired to GP26 on the Pico. The example prints a message to the console each time the state of the button changes. When the button is pressed, the input level of GP26 will be low (False) level. Copy and paste the following code to the Mu Editor and press Save : import board import digitalio # Button button = digitalio . DigitalInOut ( board . GP26 ) button . direction = digitalio . Direction . INPUT button . pull = digitalio . Pull . UP last_value = button . value while True : if last_value != button . value : last_value = button . value print ( 'Button is ' + ( 'released' if button . value else 'pressed' )) Press the button and observe the Serial Console, you will see the message printed each time the state of the button changes: Rotary Encoder DeskPi PicoMate has an incremental rotary encoder pre-wired to the Pico, which converts the motion of the switch (clockwise or counterclockwise) into an output signal that can be used to determine what direction the knob is being rotated. The table below shows the connections of each pin of the rotary encoder: Rotary Encoder Pin On Pico A GP7 B GP6 Swith(Optional, Active High Level) GP26 Copy and paste the following code to the Mu Editor and press Save : import rotaryio import board import digitalio encoder = rotaryio . IncrementalEncoder ( board . GP7 , board . GP6 ) switch = digitalio . DigitalInOut ( board . GP26 ) switch . direction = digitalio . Direction . INPUT switch . pull = digitalio . Pull . DOWN last_position = encoder . position switch_state = switch . value while True : position = encoder . position if last_position is None or position != last_position : print ( f \"Rotary: { position } \" ) last_position = position if switch_state != switch . value : switch_state = switch . value print ( 'Switch is ' + ( 'ON' if switch . value else 'OFF' )) Now, open the Serial Console, then try rotating the knob slowly clockwise or counterclockwise, and try pressing down on the knob. Buzzer DeskPi PicoMate has a buzzer pre-wired to GP27 on the Pico. To control the buzzer from CircuitPython we will use its built in PWM, or pulse-width modulation, signal generation capabilities. Copy and paste the following code to the Mu Editor and press Save: import time import board import pwmio # Define a list of tones/music notes to play. TONE_FREQ = [ 1047 , 1047 , 1568 , 1568 , 1760 , 1760 , 1568 , 0 , 1397 , 1397 , 1319 , 1319 , 1175 , 1175 , 1047 , 0 , 1568 , 1568 , 1397 , 1397 , 1319 , 1319 , 1175 , 0 , 1568 , 1568 , 1397 , 1397 , 1319 , 1319 , 1175 , 0 , 1047 , 1047 , 1568 , 1568 , 1760 , 1760 , 1568 , 0 , 1397 , 1397 , 1319 , 1319 , 1175 , 1175 , 1047 , 0 , ] # Buzzer buzzer = pwmio . PWMOut ( board . GP27 , variable_frequency = True ) buzzer . frequency = TONE_FREQ [ 0 ] buzzer . duty_cycle = 32768 while True : for note in TONE_FREQ : if note : buzzer . frequency = note time . sleep ( 0.1 ) The music playback will immediately start as soon as the code is done saving. 0.96\u201d 128x64 OLED Display DeskPi PicoMate has a 0.96\" 128x64 OLED Display module, which is pre-wired to the Pico using I2C0 with the device address 0x3C . The table below shows the connections of each pin of the OLED: 0.96\" 128x64 OLED Pin On Pico SCL GP17/I2C0_SCL SDA GP16/I2C0_SDA Before we can use the display module, we need the following modules installed: adafruit_register adafruit_framebuf adafruit_ssd1306 Copy the libraries into the CIRCUITPY/lib folder. This should give you the following folder structure: Then, copy and paste the following code to the Mu Editor and press Save : import time import board import busio from adafruit_ssd1306 import SSD1306_I2C i2c0 = busio . I2C ( scl = board . GP17 , sda = board . GP16 ) # 0.96\" 128x64 OLED Display display = SSD1306_I2C ( 128 , 64 , i2c0 ) def display_text ( str , line ): display . text ( str , 0 , ( line % 8 ) * 8 , 1 , font_name = \"/lib/font5x8.bin\" ) while True : display . fill ( 0 ) display_text ( \"Hello, World!\" , 0 ) display_text ( \"It's DeskPi PicoMate!\" , 2 ) display . show () time . sleep ( 0.5 ) Try to change the display text and observe what is printed on the OLED. PDM Microphone DeskPi PicoMate has a high quality, low power PDM digital output top-ported omni-directional MEMS microphone. The PDM microphone is pre-wired to the Pico. The table below shows the connections of each pin of the PDM microphone: PDM Microphone Pin On Pico CLK GP9 DATA GP8 As PDMIn is built into CircuitPython, no separate libraries are necessary for this example! Copy and paste the following code to the Mu Editor and press Save : import time import array import math import board import audiobusio # Remove DC bias before computing RMS. def mean ( values ): return sum ( values ) / len ( values ) # Calculate the Normalized RMS value of samples def normalized_rms ( values ): minbuf = int ( mean ( values )) samples_sum = sum ( float ( sample - minbuf ) * ( sample - minbuf ) for sample in values ) return math . sqrt ( samples_sum / len ( values )) # PDM Microphone mic = audiobusio . PDMIn ( board . GP9 , board . GP8 , sample_rate = 16000 , bit_depth = 16 ) samples = array . array ( 'H' , [ 0 ] * 160 ) while True : mic . record ( samples , len ( samples )) magnitude = normalized_rms ( samples ) print (( magnitude ,)) time . sleep ( 0.1 ) On Serial Console, you will see the Normalized RMS value of the audio captured by the Microphone. Try to make some sound. You will see the magnitude changes. You can also use the plotter for data inspection. Press the Plotter button on the top menu. Digital PIR Sensor DeskPi PicoMate has a Digital PIR sensor pre-wired to GP28 on the Pico. The Digital PIR sensor allows you to sense motion, almost used to detect whether a human has moved in or out of the sensors range. The Digital PIR sensor acts as a digital output. When the sensor is triggered, the input level of GP28 will be High (True) Level. Copy and paste the following code to the Mu Editor and press Save : import board import digitalio # PIR sensor pir_sensor = digitalio . DigitalInOut ( board . GP28 ) pir_sensor . direction = digitalio . Direction . INPUT pir_sensor . pull = digitalio . Pull . DOWN last_value = pir_sensor . value while True : if last_value != pir_sensor . value : last_value = pir_sensor . value print ( 'Motion ' + ( 'detected!' if pir_sensor . value else 'removed!' )) Try moving your body and see messages printed on the Serial Console. 6-Axis IMU Sensor DeskPi PicoMate has a 6-Axis IMU sensor (LSM6DS3TR-C) featuring a 3D digital accelerometer and a 3D digital gyroscope. The sensor is pre-wired to the Pico using I2C1 with the device address 0x6A . The table below shows the connections of each pin of the sensor: 6-Axis IMU sensor Pin On Pico SCL GP15/I2C1_SCL SDA GP14/I2C1_SDA Before we can use the sensor, we need the following modules installed: adafruit_register adafruit_lsm6ds Copy the libraries into the CIRCUITPY/lib folder. This should give you the following folder structure: CIRCUITPY/ \u251c\u2500\u2500 boot_out.txt \u251c\u2500\u2500 code.py \u2514\u2500\u2500 lib \u251c\u2500\u2500 adafruit_lsm6ds \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 ism330dhcx.py \u2502 \u251c\u2500\u2500 lsm6ds3.py \u2502 \u251c\u2500\u2500 lsm6ds33.py \u2502 \u251c\u2500\u2500 lsm6ds3trc.py \u2502 \u251c\u2500\u2500 lsm6dso32.py \u2502 \u2514\u2500\u2500 lsm6dsox.py \u2514\u2500\u2500 adafruit_register \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 i2c_bcd_alarm.py \u251c\u2500\u2500 i2c_bcd_datetime.py \u251c\u2500\u2500 i2c_bit.py \u251c\u2500\u2500 i2c_bits.py \u251c\u2500\u2500 i2c_struct.py \u2514\u2500\u2500 i2c_struct_array.py Then, copy and paste the following code to the Mu Editor and press Save : import time import board import busio from adafruit_lsm6ds.lsm6ds3trc import LSM6DS3TRC i2c1 = busio . I2C ( scl = board . GP15 , sda = board . GP14 ) # 6-Axis IMU Sensor imu_sensor = LSM6DS3TRC ( i2c1 ) # Acceleration plotter while True : print ( imu_sensor . acceleration ) time . sleep ( 0.1 ) # Gyro plotter # while True: # print(imu_sensor.gyro) # time.sleep(0.1) Press the Plotter button on the top menu, and try moving your board and see the changes in plotter. 3-Axis Magnetometer DeskPi PicoMate has a 3-Axis Magnetometer (MMC5603NJ) that can measure magnetic fields surrounding the device. The sensor is pre-wired to the Pico using I2C1 with the device address 0x30 . The table below shows the connections of each pin of the sensor: 3-Axis Magnetometer Pin On Pico SCL GP15/I2C1_SCL SDA GP14/I2C1_SDA Before we can use the sensor, we need the following modules installed: adafruit_register adafruit_mmc56x3 Copy the libraries into the CIRCUITPY/lib folder. This should give you the following folder structure: CIRCUITPY/ \u251c\u2500\u2500 boot_out.txt \u251c\u2500\u2500 code.py \u2514\u2500\u2500 lib \u251c\u2500\u2500 adafruit_mmc56x3.py \u2514\u2500\u2500 adafruit_register \u251c\u2500\u2500 init .py \u251c\u2500\u2500 i2c_bcd_alarm.py \u251c\u2500\u2500 i2c_bcd_datetime.py \u251c\u2500\u2500 i2c_bit.py \u251c\u2500\u2500 i2c_bits.py \u251c\u2500\u2500 i2c_struct.py \u2514\u2500\u2500 i2c_struct_array.py Then, copy and paste the following code to the Mu Editor and press Save : import time import board import busio from adafruit_mmc56x3 import MMC5603 i2c1 = busio . I2C ( scl = board . GP15 , sda = board . GP14 ) # MMC5603 magnetometer magnetometer = MMC5603 ( i2c1 ) magnetometer . data_rate = 1000 # in Hz, from 1-255 or 1000 magnetometer . continuous_mode = True # Magnetic plotter while True : print ( magnetometer . magnetic ) time . sleep ( 0.1 ) Press the Plotter button on the top menu, and try moving your board and see the changes in plotter. Digital Optical Sensor DeskPi PicoMate has a Digital Optical Sensor (LTR-381RGB-01) that integrates an ambient light sensor (ALS) and a color sensor (CS). With the advanced RGB color sensor, this sensor converts light (Red, Green, Blue, and IR) intensity to a digital output signal capable of direct I2C interface. The ALS provides a linear response over a wide dynamic range, which is well suited to applications under very low or bright ambient brightness. The sensor is pre-wired to the Pico using I2C1 with the device address 0x53 . The table below shows the connections of each pin of the sensor: Digital Optical Sensor Pin On Pico SCL GP15/I2C1_SCL SDA GP14/I2C1_SDA Before we can use the sensor, we need the following modules installed: adafruit_register ltr381rgb Copy the libraries into the CIRCUITPY/lib folder. This should give you the following folder structure: CIRCUITPY/ \u251c\u2500\u2500 boot_out.txt \u251c\u2500\u2500 code.py \u2514\u2500\u2500 lib \u251c\u2500\u2500 adafruit_register \u2502 \u251c\u2500\u2500 init .py \u2502 \u251c\u2500\u2500 i2c_bcd_alarm.py \u2502 \u251c\u2500\u2500 i2c_bcd_datetime.py \u2502 \u251c\u2500\u2500 i2c_bit.py \u2502 \u251c\u2500\u2500 i2c_bits.py \u2502 \u251c\u2500\u2500 i2c_struct.py \u2502 \u2514\u2500\u2500 i2c_struct_array.py \u2514\u2500\u2500 ltr381rgb.py Then, copy and paste the following code to the Mu Editor and press Save : import time import board import busio from ltr381rgb import LTR381RGB i2c1 = busio . I2C ( scl = board . GP15 , sda = board . GP14 ) # Optical Sensor optical = LTR381RGB ( i2c1 ) optical . mode = \"CS\" optical . enable () # ALS and raw data plotter while True : print ( f \"ALS: { optical . lux } lx\" ) print ( optical . raw_data ) time . sleep ( 0.5 ) On Serial Console, you will see the calculated lux of ambient light. Try to lit up or dim the sensor. You will see the value changes. You can also use the plotter for raw data inspection. Press the Plotter button on the top menu. Temperature & Humidity Sensor DeskPi PicoMate has a temperature and humidity sensor (SHT30-DIS), which is pre-wired to the Pico using I2C1 with the device address 0x44 . The table below shows the connections of each pin of the sensor: Temperature & Humidity Sensor Pin On Pico SCL GP15/I2C1_SCL SDA GP14/I2C1_SDA Before we can use the sensor, we need the following modules installed: - adafruit_register - adafruit_sht31d Copy the libraries into the CIRCUITPY/lib folder. This should give you the following folder structure: CIRCUITPY/ \u251c\u2500\u2500 boot_out.txt \u251c\u2500\u2500 code.py \u2514\u2500\u2500 lib \u251c\u2500\u2500 adafruit_register \u2502 \u251c\u2500\u2500 init .py \u2502 \u251c\u2500\u2500 i2c_bcd_alarm.py \u2502 \u251c\u2500\u2500 i2c_bcd_datetime.py \u2502 \u251c\u2500\u2500 i2c_bit.py \u2502 \u251c\u2500\u2500 i2c_bits.py \u2502 \u251c\u2500\u2500 i2c_struct.py \u2502 \u2514\u2500\u2500 i2c_struct_array.py \u2514\u2500\u2500 adafruit_sht31d.py Then, copy and paste the following code to the Mu Editor and press Save : import time import board import busio from adafruit_sht31d import SHT31D i2c1 = busio . I2C ( scl = board . GP15 , sda = board . GP14 ) # Temperature & Humidity Sensor sht_sensor = SHT31D ( i2c1 ) loopcount = 0 while True : print ( \" \\n Temperature: %0.1f C\" % sht_sensor . temperature ) print ( \"Humidity: %0.1f %% \" % sht_sensor . relative_humidity ) loopcount += 1 time . sleep ( 2 ) # every 10 passes turn on the heater for 1 second if loopcount == 10 : loopcount = 0 sht_sensor . heater = True print ( \"Sensor Heater status =\" , sht_sensor . heater ) time . sleep ( 1 ) sht_sensor . heater = False print ( \"Sensor Heater status =\" , sht_sensor . heater ) On Serial Console, you will see the temperature and humidity printed every 2s . Libraries download Firmware Download: firmware libraries Download: libraries FAQ Q: Should I download the libraries from internet? A: Yes, if you want to use the latest version of the libraries. Appendix A: DeskPi PicoMate Pinout Diagram","title":"DeskPi PicoMate"},{"location":"picomate/#deskpi-picomate-user-manual","text":"","title":"DeskPi PicoMate User Manual"},{"location":"picomate/#description","text":"DeskPi PicoMate is an all-in-one and versatile prototyping kit designed for Raspberry Pi Pico and Pico W. It includes one expansion dock for Raspberry Pi Pico and Pico W, 12 detachable modules and all in one- piece of PCB design. All modules are pre-wired to the Pico Dock, no soldering and wiring required and out-of-box. Of course, you can also detach the modules and connect them using the cables included in the box. Buy DeskPi PicoMate Visit DeskPi Official Website","title":"Description"},{"location":"picomate/#features","text":"Designed for Raspberry Pi Pico and Pico W All modules are pre-wired, no soldering and wiring required and out-of-box 12 detachable and easy-to-use modules: Push Button WS2812 RGB LED Rotary Encoder Buzzer Digital Microphone (ZTS6531S) Digital PIR Sensor (AS312) 6-Axis IMU Sensor (LSM6DS3TR-C) Digital Optical Sensor (LTR-381RGB-01) 3-Axis Magnetometer (MMC5603NJ) Temperature & Humidity Sensor (SHT30-DIS) 0.96\u201d 128x64 OLED Display (SSD1315) 204 Pins Breakout Board All Pico GPIOs available via headers and up to 11 Grove connectors available Built-in battery connector for on-the-go projects MicroPython libraries support for all modules 3.3V IO operating voltage","title":"Features"},{"location":"picomate/#package-includes","text":"1x DeskPi PicoMate 1x Raspberry Pi Pico with pre-soldered pin headers 1x 3*AA Battery Holder with On/Off Switch 6x Grove Cable 1x Micro USB Cable","title":"Package Includes"},{"location":"picomate/#pinout-diagram","text":"","title":"Pinout Diagram"},{"location":"picomate/#getting-start","text":"","title":"Getting Start"},{"location":"picomate/#getting-started-with-python","text":"The DeskPi PicoMate can be programmed using the popular Python programming language. Raspberry Pi Pico is supported by CircuitPython, which is based on MicroPython, and features unified Python core APIs and a growing list of device libraries and drivers that work with it. This section describes how to set up CircuitPython on DeskPi PicoMate. Examples are also provided to help you to get started in a very short time","title":"Getting Started with Python"},{"location":"picomate/#installing-circuitpython","text":"Download the official CircuiPython for Raspberry Pi Pico . Choose the latest stable release and then download the .uf2 file. Then go ahead and: Push and hold the BOOTSEL button and plug your Pico into the USB port of your computer. Release the BOOTSEL button after your Pico is connected. It will mount as a Mass Storage Device called RPI-RP2 . Drag and drop the CircuitPython UF2 file onto the RPI-RP2 volume. Your Pico will reboot. A new drive named CIRCUITPY should appear.","title":"Installing CircuitPython"},{"location":"picomate/#installing-mu-editor","text":"Mu Editor is a simple Python code editor for beginner programmers. Go to Mu Editor Download page , choose your Operational System and follow the instructions. MU Editor Once the Mu Editor is installed, open it, go to Mode menu, select CircuitPython and press OK . In the text editor, try some Python code: print ( 'Hello, DeskPi PicoMate!' ) Select Save on Top Menu. A window will appear. Give the name code.py for your code and save it on the CIRCUITPY drive. Your code will run as soon as the file is done saving. The Serial button opens a serial data connection to the Pico. This will result in a new panel between the text editor and Mu s footer, which prints the data from the Pico. If you need to drop into the CircuitPython REPL you should make sure the panel has keyboard focus (just click it!) and then type CTRL+ C . Now that you have the Python prerequisites installed, it is time to explore more examples for the DeskPi PicoMate.","title":"Installing Mu Editor"},{"location":"picomate/#python-examples","text":"This section consists of several example codes. The examples are organized in different levels of codes to demonstrate the Python API usage.","title":"Python Examples"},{"location":"picomate/#blink-rgb-led","text":"DeskPi PicoMate has a WS2812 RGB LED pre-wired to GP22 on the Pico. We can use the NeoPixel library to blink the RGB LED.","title":"Blink RGB LED"},{"location":"picomate/#breakable-design","text":"Download the NeoPixel library and copy neopixel.py into the CIRCUITPY/lib folder.This should give you the following folder structure: Copy and paste the following code to the Mu Editor and press Save : import time import board import neopixel R = ( 50 , 0 , 0 ) G = ( 0 , 50 , 0 ) B = ( 0 , 0 , 50 ) COLORS = ( R , G , B ) pixels = neopixel . NeoPixel ( board . GP22 , 1 ) while True : for color in COLORS : pixels [ 0 ] = color time . sleep ( 1 ) Your code will run as soon as the file is done saving. Observe that the RGB LED starts to blink. For more details about the Neopixel API reference, please check out Read the Docs","title":"Breakable Design"},{"location":"picomate/#button","text":"DeskPi PicoMate has a Push Button pre-wired to GP26 on the Pico. The example prints a message to the console each time the state of the button changes. When the button is pressed, the input level of GP26 will be low (False) level. Copy and paste the following code to the Mu Editor and press Save : import board import digitalio # Button button = digitalio . DigitalInOut ( board . GP26 ) button . direction = digitalio . Direction . INPUT button . pull = digitalio . Pull . UP last_value = button . value while True : if last_value != button . value : last_value = button . value print ( 'Button is ' + ( 'released' if button . value else 'pressed' )) Press the button and observe the Serial Console, you will see the message printed each time the state of the button changes:","title":"Button"},{"location":"picomate/#rotary-encoder","text":"DeskPi PicoMate has an incremental rotary encoder pre-wired to the Pico, which converts the motion of the switch (clockwise or counterclockwise) into an output signal that can be used to determine what direction the knob is being rotated. The table below shows the connections of each pin of the rotary encoder: Rotary Encoder Pin On Pico A GP7 B GP6 Swith(Optional, Active High Level) GP26 Copy and paste the following code to the Mu Editor and press Save : import rotaryio import board import digitalio encoder = rotaryio . IncrementalEncoder ( board . GP7 , board . GP6 ) switch = digitalio . DigitalInOut ( board . GP26 ) switch . direction = digitalio . Direction . INPUT switch . pull = digitalio . Pull . DOWN last_position = encoder . position switch_state = switch . value while True : position = encoder . position if last_position is None or position != last_position : print ( f \"Rotary: { position } \" ) last_position = position if switch_state != switch . value : switch_state = switch . value print ( 'Switch is ' + ( 'ON' if switch . value else 'OFF' )) Now, open the Serial Console, then try rotating the knob slowly clockwise or counterclockwise, and try pressing down on the knob.","title":"Rotary Encoder"},{"location":"picomate/#buzzer","text":"DeskPi PicoMate has a buzzer pre-wired to GP27 on the Pico. To control the buzzer from CircuitPython we will use its built in PWM, or pulse-width modulation, signal generation capabilities. Copy and paste the following code to the Mu Editor and press Save: import time import board import pwmio # Define a list of tones/music notes to play. TONE_FREQ = [ 1047 , 1047 , 1568 , 1568 , 1760 , 1760 , 1568 , 0 , 1397 , 1397 , 1319 , 1319 , 1175 , 1175 , 1047 , 0 , 1568 , 1568 , 1397 , 1397 , 1319 , 1319 , 1175 , 0 , 1568 , 1568 , 1397 , 1397 , 1319 , 1319 , 1175 , 0 , 1047 , 1047 , 1568 , 1568 , 1760 , 1760 , 1568 , 0 , 1397 , 1397 , 1319 , 1319 , 1175 , 1175 , 1047 , 0 , ] # Buzzer buzzer = pwmio . PWMOut ( board . GP27 , variable_frequency = True ) buzzer . frequency = TONE_FREQ [ 0 ] buzzer . duty_cycle = 32768 while True : for note in TONE_FREQ : if note : buzzer . frequency = note time . sleep ( 0.1 ) The music playback will immediately start as soon as the code is done saving.","title":"Buzzer"},{"location":"picomate/#096-128x64-oled-display","text":"DeskPi PicoMate has a 0.96\" 128x64 OLED Display module, which is pre-wired to the Pico using I2C0 with the device address 0x3C . The table below shows the connections of each pin of the OLED: 0.96\" 128x64 OLED Pin On Pico SCL GP17/I2C0_SCL SDA GP16/I2C0_SDA Before we can use the display module, we need the following modules installed: adafruit_register adafruit_framebuf adafruit_ssd1306 Copy the libraries into the CIRCUITPY/lib folder. This should give you the following folder structure: Then, copy and paste the following code to the Mu Editor and press Save : import time import board import busio from adafruit_ssd1306 import SSD1306_I2C i2c0 = busio . I2C ( scl = board . GP17 , sda = board . GP16 ) # 0.96\" 128x64 OLED Display display = SSD1306_I2C ( 128 , 64 , i2c0 ) def display_text ( str , line ): display . text ( str , 0 , ( line % 8 ) * 8 , 1 , font_name = \"/lib/font5x8.bin\" ) while True : display . fill ( 0 ) display_text ( \"Hello, World!\" , 0 ) display_text ( \"It's DeskPi PicoMate!\" , 2 ) display . show () time . sleep ( 0.5 ) Try to change the display text and observe what is printed on the OLED.","title":"0.96\u201d 128x64 OLED Display"},{"location":"picomate/#pdm-microphone","text":"DeskPi PicoMate has a high quality, low power PDM digital output top-ported omni-directional MEMS microphone. The PDM microphone is pre-wired to the Pico. The table below shows the connections of each pin of the PDM microphone: PDM Microphone Pin On Pico CLK GP9 DATA GP8 As PDMIn is built into CircuitPython, no separate libraries are necessary for this example! Copy and paste the following code to the Mu Editor and press Save : import time import array import math import board import audiobusio # Remove DC bias before computing RMS. def mean ( values ): return sum ( values ) / len ( values ) # Calculate the Normalized RMS value of samples def normalized_rms ( values ): minbuf = int ( mean ( values )) samples_sum = sum ( float ( sample - minbuf ) * ( sample - minbuf ) for sample in values ) return math . sqrt ( samples_sum / len ( values )) # PDM Microphone mic = audiobusio . PDMIn ( board . GP9 , board . GP8 , sample_rate = 16000 , bit_depth = 16 ) samples = array . array ( 'H' , [ 0 ] * 160 ) while True : mic . record ( samples , len ( samples )) magnitude = normalized_rms ( samples ) print (( magnitude ,)) time . sleep ( 0.1 ) On Serial Console, you will see the Normalized RMS value of the audio captured by the Microphone. Try to make some sound. You will see the magnitude changes. You can also use the plotter for data inspection. Press the Plotter button on the top menu.","title":"PDM Microphone"},{"location":"picomate/#digital-pir-sensor","text":"DeskPi PicoMate has a Digital PIR sensor pre-wired to GP28 on the Pico. The Digital PIR sensor allows you to sense motion, almost used to detect whether a human has moved in or out of the sensors range. The Digital PIR sensor acts as a digital output. When the sensor is triggered, the input level of GP28 will be High (True) Level. Copy and paste the following code to the Mu Editor and press Save : import board import digitalio # PIR sensor pir_sensor = digitalio . DigitalInOut ( board . GP28 ) pir_sensor . direction = digitalio . Direction . INPUT pir_sensor . pull = digitalio . Pull . DOWN last_value = pir_sensor . value while True : if last_value != pir_sensor . value : last_value = pir_sensor . value print ( 'Motion ' + ( 'detected!' if pir_sensor . value else 'removed!' )) Try moving your body and see messages printed on the Serial Console.","title":"Digital PIR Sensor"},{"location":"picomate/#6-axis-imu-sensor","text":"DeskPi PicoMate has a 6-Axis IMU sensor (LSM6DS3TR-C) featuring a 3D digital accelerometer and a 3D digital gyroscope. The sensor is pre-wired to the Pico using I2C1 with the device address 0x6A . The table below shows the connections of each pin of the sensor: 6-Axis IMU sensor Pin On Pico SCL GP15/I2C1_SCL SDA GP14/I2C1_SDA Before we can use the sensor, we need the following modules installed: adafruit_register adafruit_lsm6ds Copy the libraries into the CIRCUITPY/lib folder. This should give you the following folder structure: CIRCUITPY/ \u251c\u2500\u2500 boot_out.txt \u251c\u2500\u2500 code.py \u2514\u2500\u2500 lib \u251c\u2500\u2500 adafruit_lsm6ds \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 ism330dhcx.py \u2502 \u251c\u2500\u2500 lsm6ds3.py \u2502 \u251c\u2500\u2500 lsm6ds33.py \u2502 \u251c\u2500\u2500 lsm6ds3trc.py \u2502 \u251c\u2500\u2500 lsm6dso32.py \u2502 \u2514\u2500\u2500 lsm6dsox.py \u2514\u2500\u2500 adafruit_register \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 i2c_bcd_alarm.py \u251c\u2500\u2500 i2c_bcd_datetime.py \u251c\u2500\u2500 i2c_bit.py \u251c\u2500\u2500 i2c_bits.py \u251c\u2500\u2500 i2c_struct.py \u2514\u2500\u2500 i2c_struct_array.py Then, copy and paste the following code to the Mu Editor and press Save : import time import board import busio from adafruit_lsm6ds.lsm6ds3trc import LSM6DS3TRC i2c1 = busio . I2C ( scl = board . GP15 , sda = board . GP14 ) # 6-Axis IMU Sensor imu_sensor = LSM6DS3TRC ( i2c1 ) # Acceleration plotter while True : print ( imu_sensor . acceleration ) time . sleep ( 0.1 ) # Gyro plotter # while True: # print(imu_sensor.gyro) # time.sleep(0.1) Press the Plotter button on the top menu, and try moving your board and see the changes in plotter.","title":"6-Axis IMU Sensor"},{"location":"picomate/#3-axis-magnetometer","text":"DeskPi PicoMate has a 3-Axis Magnetometer (MMC5603NJ) that can measure magnetic fields surrounding the device. The sensor is pre-wired to the Pico using I2C1 with the device address 0x30 . The table below shows the connections of each pin of the sensor: 3-Axis Magnetometer Pin On Pico SCL GP15/I2C1_SCL SDA GP14/I2C1_SDA Before we can use the sensor, we need the following modules installed: adafruit_register adafruit_mmc56x3 Copy the libraries into the CIRCUITPY/lib folder. This should give you the following folder structure: CIRCUITPY/ \u251c\u2500\u2500 boot_out.txt \u251c\u2500\u2500 code.py \u2514\u2500\u2500 lib \u251c\u2500\u2500 adafruit_mmc56x3.py \u2514\u2500\u2500 adafruit_register \u251c\u2500\u2500 init .py \u251c\u2500\u2500 i2c_bcd_alarm.py \u251c\u2500\u2500 i2c_bcd_datetime.py \u251c\u2500\u2500 i2c_bit.py \u251c\u2500\u2500 i2c_bits.py \u251c\u2500\u2500 i2c_struct.py \u2514\u2500\u2500 i2c_struct_array.py Then, copy and paste the following code to the Mu Editor and press Save : import time import board import busio from adafruit_mmc56x3 import MMC5603 i2c1 = busio . I2C ( scl = board . GP15 , sda = board . GP14 ) # MMC5603 magnetometer magnetometer = MMC5603 ( i2c1 ) magnetometer . data_rate = 1000 # in Hz, from 1-255 or 1000 magnetometer . continuous_mode = True # Magnetic plotter while True : print ( magnetometer . magnetic ) time . sleep ( 0.1 ) Press the Plotter button on the top menu, and try moving your board and see the changes in plotter.","title":"3-Axis Magnetometer"},{"location":"picomate/#digital-optical-sensor","text":"DeskPi PicoMate has a Digital Optical Sensor (LTR-381RGB-01) that integrates an ambient light sensor (ALS) and a color sensor (CS). With the advanced RGB color sensor, this sensor converts light (Red, Green, Blue, and IR) intensity to a digital output signal capable of direct I2C interface. The ALS provides a linear response over a wide dynamic range, which is well suited to applications under very low or bright ambient brightness. The sensor is pre-wired to the Pico using I2C1 with the device address 0x53 . The table below shows the connections of each pin of the sensor: Digital Optical Sensor Pin On Pico SCL GP15/I2C1_SCL SDA GP14/I2C1_SDA Before we can use the sensor, we need the following modules installed: adafruit_register ltr381rgb Copy the libraries into the CIRCUITPY/lib folder. This should give you the following folder structure: CIRCUITPY/ \u251c\u2500\u2500 boot_out.txt \u251c\u2500\u2500 code.py \u2514\u2500\u2500 lib \u251c\u2500\u2500 adafruit_register \u2502 \u251c\u2500\u2500 init .py \u2502 \u251c\u2500\u2500 i2c_bcd_alarm.py \u2502 \u251c\u2500\u2500 i2c_bcd_datetime.py \u2502 \u251c\u2500\u2500 i2c_bit.py \u2502 \u251c\u2500\u2500 i2c_bits.py \u2502 \u251c\u2500\u2500 i2c_struct.py \u2502 \u2514\u2500\u2500 i2c_struct_array.py \u2514\u2500\u2500 ltr381rgb.py Then, copy and paste the following code to the Mu Editor and press Save : import time import board import busio from ltr381rgb import LTR381RGB i2c1 = busio . I2C ( scl = board . GP15 , sda = board . GP14 ) # Optical Sensor optical = LTR381RGB ( i2c1 ) optical . mode = \"CS\" optical . enable () # ALS and raw data plotter while True : print ( f \"ALS: { optical . lux } lx\" ) print ( optical . raw_data ) time . sleep ( 0.5 ) On Serial Console, you will see the calculated lux of ambient light. Try to lit up or dim the sensor. You will see the value changes. You can also use the plotter for raw data inspection. Press the Plotter button on the top menu.","title":"Digital Optical Sensor"},{"location":"picomate/#temperature-humidity-sensor","text":"DeskPi PicoMate has a temperature and humidity sensor (SHT30-DIS), which is pre-wired to the Pico using I2C1 with the device address 0x44 . The table below shows the connections of each pin of the sensor: Temperature & Humidity Sensor Pin On Pico SCL GP15/I2C1_SCL SDA GP14/I2C1_SDA Before we can use the sensor, we need the following modules installed: - adafruit_register - adafruit_sht31d Copy the libraries into the CIRCUITPY/lib folder. This should give you the following folder structure: CIRCUITPY/ \u251c\u2500\u2500 boot_out.txt \u251c\u2500\u2500 code.py \u2514\u2500\u2500 lib \u251c\u2500\u2500 adafruit_register \u2502 \u251c\u2500\u2500 init .py \u2502 \u251c\u2500\u2500 i2c_bcd_alarm.py \u2502 \u251c\u2500\u2500 i2c_bcd_datetime.py \u2502 \u251c\u2500\u2500 i2c_bit.py \u2502 \u251c\u2500\u2500 i2c_bits.py \u2502 \u251c\u2500\u2500 i2c_struct.py \u2502 \u2514\u2500\u2500 i2c_struct_array.py \u2514\u2500\u2500 adafruit_sht31d.py Then, copy and paste the following code to the Mu Editor and press Save : import time import board import busio from adafruit_sht31d import SHT31D i2c1 = busio . I2C ( scl = board . GP15 , sda = board . GP14 ) # Temperature & Humidity Sensor sht_sensor = SHT31D ( i2c1 ) loopcount = 0 while True : print ( \" \\n Temperature: %0.1f C\" % sht_sensor . temperature ) print ( \"Humidity: %0.1f %% \" % sht_sensor . relative_humidity ) loopcount += 1 time . sleep ( 2 ) # every 10 passes turn on the heater for 1 second if loopcount == 10 : loopcount = 0 sht_sensor . heater = True print ( \"Sensor Heater status =\" , sht_sensor . heater ) time . sleep ( 1 ) sht_sensor . heater = False print ( \"Sensor Heater status =\" , sht_sensor . heater ) On Serial Console, you will see the temperature and humidity printed every 2s .","title":"Temperature &amp; Humidity Sensor"},{"location":"picomate/#libraries-download","text":"Firmware Download: firmware libraries Download: libraries","title":"Libraries download"},{"location":"picomate/#faq","text":"Q: Should I download the libraries from internet? A: Yes, if you want to use the latest version of the libraries.","title":"FAQ"},{"location":"picomate/#appendix-a-deskpi-picomate-pinout-diagram","text":"","title":"Appendix A: DeskPi PicoMate Pinout Diagram"},{"location":"rackmate/","text":"DeskPi RackMate T1 Description DeskPi Rack Mate T1 is Aluminum Alloy and Acrylic Frame Mini Chassis which you can setup your own cluster or home assistant server farm into the Mini Chassis. Thank you for choosing our aluminum alloy and acrylic frame mini chassis. This user manual will provide you with a detailed description and usage guide for the chassis, ensuring that you can correctly install, use, and maintain this product. Buy DeskPi RackMate T1 Visit DeskPi Official Website Features 10-inch width The cabinet has a width of 10 inches, which is a relatively small size that saves space while accommodating sufficient equipment. With dimensions of 11x7.8x16 inches, it is suitable for small offices, home environments, and large enterprises looking to save space. Open Design The cabinet adopts an open design, allowing easy access to all devices inside. This design facilitates equipment installation and maintenance, aids in device cooling, and maintains optimal working conditions. Mounting Hole Description 8U Standard Size The cabinet has a height of 8U, which is a standard unit size. With 1U equaling 1.75 inches, 8U implies a height of 14 inches. 10mm Thick Aluminum Structure The main structure of the cabinet is manufactured using die-cast aluminum with a thickness of up to 10mm. It can withstand heavy IT equipment such as UPS and NAS. Translucent Design Both sides are made of translucent acrylic, providing dust resistance and reduced weight. This design allows direct observation of the cabinet's interior, and users can add ambient lights for decoration. Expandability Both sides are made of translucent acrylic, providing dust resistance and reduced weight. This design allows direct observation of the cabinet's interior, and users can add ambient lights for decoration. Package Includes Optional accessories Following accessories are not included in the package, additional purchase required. Please search the accessories in https://deskpi.com/ or click the links below. Accessories Purchase URL Rack Shell: DP-0031 Blank Pannel; DP-0032 SBC Shell: DP-0033 10-Inch Network Switch: DP-0034 Mini ITX Shell: DP-0035 CAT6A Ethernet Cable(0.2M): L-0094 CAT6A Ethernet Cable(0.5M): L-0095 DC PDU Lite 7-CH 0.5U Switch: DP-0042 10-inch Server Rack 0.5U Rack cable management panel-with 3 D-Rings DP-0044 DC PDU Lite 7-CH 0.5U Switch DP-0042 has been launched!!! Multiple Usages accroding to your requrement Primary User Scenarios Assembling Steps YouTube Videos DeskPi","title":"DeskPi RackMate T1"},{"location":"rackmate/#deskpi-rackmate-t1","text":"","title":"DeskPi RackMate T1"},{"location":"rackmate/#description","text":"DeskPi Rack Mate T1 is Aluminum Alloy and Acrylic Frame Mini Chassis which you can setup your own cluster or home assistant server farm into the Mini Chassis. Thank you for choosing our aluminum alloy and acrylic frame mini chassis. This user manual will provide you with a detailed description and usage guide for the chassis, ensuring that you can correctly install, use, and maintain this product. Buy DeskPi RackMate T1 Visit DeskPi Official Website","title":"Description"},{"location":"rackmate/#features","text":"10-inch width The cabinet has a width of 10 inches, which is a relatively small size that saves space while accommodating sufficient equipment. With dimensions of 11x7.8x16 inches, it is suitable for small offices, home environments, and large enterprises looking to save space. Open Design The cabinet adopts an open design, allowing easy access to all devices inside. This design facilitates equipment installation and maintenance, aids in device cooling, and maintains optimal working conditions. Mounting Hole Description 8U Standard Size The cabinet has a height of 8U, which is a standard unit size. With 1U equaling 1.75 inches, 8U implies a height of 14 inches. 10mm Thick Aluminum Structure The main structure of the cabinet is manufactured using die-cast aluminum with a thickness of up to 10mm. It can withstand heavy IT equipment such as UPS and NAS. Translucent Design Both sides are made of translucent acrylic, providing dust resistance and reduced weight. This design allows direct observation of the cabinet's interior, and users can add ambient lights for decoration. Expandability Both sides are made of translucent acrylic, providing dust resistance and reduced weight. This design allows direct observation of the cabinet's interior, and users can add ambient lights for decoration.","title":"Features"},{"location":"rackmate/#package-includes","text":"","title":"Package Includes"},{"location":"rackmate/#optional-accessories","text":"Following accessories are not included in the package, additional purchase required. Please search the accessories in https://deskpi.com/ or click the links below.","title":"Optional accessories"},{"location":"rackmate/#accessories-purchase-url","text":"Rack Shell: DP-0031 Blank Pannel; DP-0032 SBC Shell: DP-0033 10-Inch Network Switch: DP-0034 Mini ITX Shell: DP-0035 CAT6A Ethernet Cable(0.2M): L-0094 CAT6A Ethernet Cable(0.5M): L-0095 DC PDU Lite 7-CH 0.5U Switch: DP-0042 10-inch Server Rack 0.5U Rack cable management panel-with 3 D-Rings DP-0044 DC PDU Lite 7-CH 0.5U Switch DP-0042 has been launched!!!","title":"Accessories Purchase URL"},{"location":"rackmate/#multiple-usages-accroding-to-your-requrement","text":"","title":"Multiple Usages accroding to your requrement"},{"location":"rackmate/#primary-user-scenarios","text":"","title":"Primary User Scenarios"},{"location":"rackmate/#assembling-steps","text":"","title":"Assembling Steps"},{"location":"rackmate/#youtube-videos","text":"","title":"YouTube Videos"},{"location":"rackmate/#deskpi","text":"","title":"DeskPi"},{"location":"rackmate_accessories/","text":"DC PDU Lite 7-CH 0.5U for DeskPi Rackmate T1 SKU: DP-0042 Name: DC PDU Lite 7-CH 0.5U for DeskPi Rackmate T1 Description The DP-0042 is a DC Power Distribution Unit (PDU) specifically designed for the DeskPi Rackmate T1, featuring 7 channels suitable for both desktop and rack-mount installations. It supports a broad range of input voltages with no minimum voltage requirement, up to a maximum of 24V, and a maximum current of 8A. This PDU is engineered to meet the power needs of various electronic devices and accessories, making it ideal for scenarios requiring flexible power management. Features Flexible Voltage Support : Capable of supporting input voltages from no minimum limit up to a maximum of 24V. High Current Carrying Capacity : With a maximum current of 8A, it is suitable for high-power devices. Dual Input Interfaces : Equipped with two input ports, front and rear, for user convenience based on connection needs. Automatic Fuse Recovery : Triggers a fuse break if the current in a single channel exceeds 5A, with automatic recovery after 4 seconds to ensure device safety. Specifications Input Voltage Range : No minimum limit to 24V Maximum Input Current : 8A Output Voltage : Equal to the input voltage Maximum Current per Channel : 3A Fuse Trigger Current : Over 5A Automatic Recovery Time : 4 seconds Outlet Configuration : Each channel has two outlets, front and rear, sharing a total current of 3A Size : 0.5U (specific dimensions to be provided based on the actual product) Installation Method : Compatible with DeskPi Rackmate T1, supports desktop or rack-mount installation Applications The DP-0042 DC PDU is suitable for a variety of applications, including but not limited to: - Laboratory and test equipment power management - Industrial automation equipment power distribution - Power supply for desktop computers and server accessories - Any environment requiring flexible power solutions Safety Measures Ensure not to exceed the maximum current limit to avoid triggering the fuse. Installation and maintenance should be performed under the guidance of a professional. Package Includes Accessories Purchase URL Rack Shell DP-0031 Blank Pannel DP-0032 SBC Shell DP-0033 10-Inch Network Switch DP-0034 Mini ITX Shell DP-0035 CAT6A Ethernet Cable(0.2M) L-0094 CAT6A Ethernet Cable(0.5M) L-0095 DeskPi","title":"DC PDU Lite 7-CH 0.5U for DeskPi Rackmate T1"},{"location":"rackmate_accessories/#dc-pdu-lite-7-ch-05u-for-deskpi-rackmate-t1","text":"SKU: DP-0042 Name: DC PDU Lite 7-CH 0.5U for DeskPi Rackmate T1","title":"DC PDU Lite 7-CH 0.5U for DeskPi Rackmate T1"},{"location":"rackmate_accessories/#description","text":"The DP-0042 is a DC Power Distribution Unit (PDU) specifically designed for the DeskPi Rackmate T1, featuring 7 channels suitable for both desktop and rack-mount installations. It supports a broad range of input voltages with no minimum voltage requirement, up to a maximum of 24V, and a maximum current of 8A. This PDU is engineered to meet the power needs of various electronic devices and accessories, making it ideal for scenarios requiring flexible power management.","title":"Description"},{"location":"rackmate_accessories/#features","text":"Flexible Voltage Support : Capable of supporting input voltages from no minimum limit up to a maximum of 24V. High Current Carrying Capacity : With a maximum current of 8A, it is suitable for high-power devices. Dual Input Interfaces : Equipped with two input ports, front and rear, for user convenience based on connection needs. Automatic Fuse Recovery : Triggers a fuse break if the current in a single channel exceeds 5A, with automatic recovery after 4 seconds to ensure device safety.","title":"Features"},{"location":"rackmate_accessories/#specifications","text":"Input Voltage Range : No minimum limit to 24V Maximum Input Current : 8A Output Voltage : Equal to the input voltage Maximum Current per Channel : 3A Fuse Trigger Current : Over 5A Automatic Recovery Time : 4 seconds Outlet Configuration : Each channel has two outlets, front and rear, sharing a total current of 3A Size : 0.5U (specific dimensions to be provided based on the actual product) Installation Method : Compatible with DeskPi Rackmate T1, supports desktop or rack-mount installation","title":"Specifications"},{"location":"rackmate_accessories/#applications","text":"The DP-0042 DC PDU is suitable for a variety of applications, including but not limited to: - Laboratory and test equipment power management - Industrial automation equipment power distribution - Power supply for desktop computers and server accessories - Any environment requiring flexible power solutions","title":"Applications"},{"location":"rackmate_accessories/#safety-measures","text":"Ensure not to exceed the maximum current limit to avoid triggering the fuse. Installation and maintenance should be performed under the guidance of a professional.","title":"Safety Measures"},{"location":"rackmate_accessories/#package-includes","text":"","title":"Package Includes"},{"location":"rackmate_accessories/#accessories-purchase-url","text":"Rack Shell DP-0031 Blank Pannel DP-0032 SBC Shell DP-0033 10-Inch Network Switch DP-0034 Mini ITX Shell DP-0035 CAT6A Ethernet Cable(0.2M) L-0094 CAT6A Ethernet Cable(0.5M) L-0095","title":"Accessories Purchase URL"},{"location":"rackmate_accessories/#deskpi","text":"","title":"DeskPi"},{"location":"rackmate_accessories_2/","text":"10-inch Server Rack 0.5U Rack Cable Management Panel-with 3 D-Rings SKU: DP-0044 Name: 10-inch Server Rack 0.5U Rack Cable Management Panel-with 3 D-Rings for DeskPi Rackmate T1 Description The 10-inch Server Rack 0.5U Rack Cable Management Panel with 3 D-Rings is a cable management panel designed for server racks. This panel is typically mounted at the front or back of the rack to organize and secure cables, keeping the interior of the rack neat and orderly. It usually has the following features: Features Size and Design Height : 0.5U (1U equals 1.75 inches) Width : 10 inches Compact design to save rack space and fit standard 19-inch racks D-Ring Hooks Equipped with D-Ring hooks for securing and guiding cables Cable Capacity Accommodates a specific number of cables, depending on the panel's design and size Material and Construction Made of sturdy materials like steel or aluminum Powder-coated finish for durability and corrosion resistance Installation Mounts on standard EIA 19-inch rack rails for easy installation Additional Features May include brush strips or other features to enhance air flow and reduce dust accumulation Maintenance and Compatibility Reduces strain on equipment ports to protect rack-mounted devices Improves airflow within the rack for optimal equipment operation and reduced risk of overheating Package Includes Accessories Purchase URL Rack Shell DP-0031 Blank Pannel DP-0032 SBC Shell DP-0033 10-Inch Network Switch DP-0034 Mini ITX Shell DP-0035 CAT6A Ethernet Cable(0.2M) L-0094 CAT6A Ethernet Cable(0.5M) L-0095 DC PDU Lite 7-CH 0.5U for DeskPi Rackmate T1: DP-0042 10-inch Server Rack 0.5U Rack Cable Management Panel-with 3 D-Rings: DP-0044 Amazon Links: DeskPi RackMate T1: US Store UK Store Network Patch Panel 12 Port CAT6 10inch 0.5U US Store UK Store SBC Shell 10 inch 1U Rack US Store UK Store Mini ITX Shell 10 inch 1U Rack US Store UK Store Blank Pannel 10 inch 1U Rack US Store UK Store ) * SBC Shell 10 inch 1U Rack, with 2PCS Micro HDMI to HDMI Adapter Board for Raspberry Pi 5 / Pi 4B ) US Store UK Store ) * Micro HDMI to HDMI Adapter Board for Raspberry Pi 5 / Pi 4B ) US Store UK Store GeeekPi 4PCS Cat6A Ethernet Cable, Snagless Short Shielded Network Cable, White (20 cm/0.65 ft) US Store (0.2m) UK Store (0.2m) [UK Store (0.5m)] (https(//www.amazon.co.uk/dp/B0DDXQH81J) Rack Shell 10 Inch 0.5U Rack Shelf US Store UK Store DeskPi 10inch Server Rack 0.5U Rack Cable Management Panel-with 3 D-Rings US Store UK Store DeskPi DC PDU Lite 7-CH 0.5U for DeskPi Rackmate T1 US Store UK Store","title":"10-inch Server Rack 0.5U Rack Cable Management Panel-with 3 D-Rings"},{"location":"rackmate_accessories_2/#10-inch-server-rack-05u-rack-cable-management-panel-with-3-d-rings","text":"SKU: DP-0044 Name: 10-inch Server Rack 0.5U Rack Cable Management Panel-with 3 D-Rings for DeskPi Rackmate T1","title":"10-inch Server Rack 0.5U Rack Cable Management Panel-with 3 D-Rings"},{"location":"rackmate_accessories_2/#description","text":"The 10-inch Server Rack 0.5U Rack Cable Management Panel with 3 D-Rings is a cable management panel designed for server racks. This panel is typically mounted at the front or back of the rack to organize and secure cables, keeping the interior of the rack neat and orderly. It usually has the following features:","title":"Description"},{"location":"rackmate_accessories_2/#features","text":"","title":"Features"},{"location":"rackmate_accessories_2/#size-and-design","text":"Height : 0.5U (1U equals 1.75 inches) Width : 10 inches Compact design to save rack space and fit standard 19-inch racks","title":"Size and Design"},{"location":"rackmate_accessories_2/#d-ring-hooks","text":"Equipped with D-Ring hooks for securing and guiding cables","title":"D-Ring Hooks"},{"location":"rackmate_accessories_2/#cable-capacity","text":"Accommodates a specific number of cables, depending on the panel's design and size","title":"Cable Capacity"},{"location":"rackmate_accessories_2/#material-and-construction","text":"Made of sturdy materials like steel or aluminum Powder-coated finish for durability and corrosion resistance","title":"Material and Construction"},{"location":"rackmate_accessories_2/#installation","text":"Mounts on standard EIA 19-inch rack rails for easy installation","title":"Installation"},{"location":"rackmate_accessories_2/#additional-features","text":"May include brush strips or other features to enhance air flow and reduce dust accumulation","title":"Additional Features"},{"location":"rackmate_accessories_2/#maintenance-and-compatibility","text":"Reduces strain on equipment ports to protect rack-mounted devices Improves airflow within the rack for optimal equipment operation and reduced risk of overheating","title":"Maintenance and Compatibility"},{"location":"rackmate_accessories_2/#package-includes","text":"","title":"Package Includes"},{"location":"rackmate_accessories_2/#accessories-purchase-url","text":"Rack Shell DP-0031 Blank Pannel DP-0032 SBC Shell DP-0033 10-Inch Network Switch DP-0034 Mini ITX Shell DP-0035 CAT6A Ethernet Cable(0.2M) L-0094 CAT6A Ethernet Cable(0.5M) L-0095 DC PDU Lite 7-CH 0.5U for DeskPi Rackmate T1: DP-0042 10-inch Server Rack 0.5U Rack Cable Management Panel-with 3 D-Rings: DP-0044","title":"Accessories Purchase URL"},{"location":"rackmate_accessories_2/#amazon-links","text":"DeskPi RackMate T1: US Store UK Store Network Patch Panel 12 Port CAT6 10inch 0.5U US Store UK Store SBC Shell 10 inch 1U Rack US Store UK Store Mini ITX Shell 10 inch 1U Rack US Store UK Store Blank Pannel 10 inch 1U Rack US Store UK Store ) * SBC Shell 10 inch 1U Rack, with 2PCS Micro HDMI to HDMI Adapter Board for Raspberry Pi 5 / Pi 4B ) US Store UK Store ) * Micro HDMI to HDMI Adapter Board for Raspberry Pi 5 / Pi 4B ) US Store UK Store GeeekPi 4PCS Cat6A Ethernet Cable, Snagless Short Shielded Network Cable, White (20 cm/0.65 ft) US Store (0.2m) UK Store (0.2m) [UK Store (0.5m)] (https(//www.amazon.co.uk/dp/B0DDXQH81J) Rack Shell 10 Inch 0.5U Rack Shelf US Store UK Store DeskPi 10inch Server Rack 0.5U Rack Cable Management Panel-with 3 D-Rings US Store UK Store DeskPi DC PDU Lite 7-CH 0.5U for DeskPi Rackmate T1 US Store UK Store","title":"Amazon Links:"},{"location":"super6c/","text":"DeskPi Super6C Purchase DeskPi Super6C Description DeskPi Super6C is the Raspberry Pi cluster board a standard size mini-ITX board to be put in a case with up to 6 RPI CM4 Compute Modules. - For every CM4: * M.2 2280 slot (PCIe Gen 2 x1) * TF Card slot * 5V FAN Header * Micro USB 2.0 Only for 1st CM4: USB Host A 2.0 x2 USB Host 2.54 4-pins x2 HDMI 2.0 x1 HDMI 1.4a x1 Compatibility Currently, after testing, Super6C is not only able to support the Raspberry Pi CM4 module but can also boot some CM4 modules from other brands. However, it is limited to just booting, and many core functions of Super6C are still unusable. This is likely due to the pin distribution and functionality of the board-to-board connector being different from that of the Raspberry Pi. It is recommended to continue using the Raspberry Pi CM4 module in conjunction with Super6C. Testing Result on BPi-CM4 V1.0 BananaPi CM4 (BPi-CM4 V1.0) Super6C functons Compatibility - USB Port 1 YES - USB Port 2 YES - HDMI1 YES - HDMI2 NO - ETH1 NO - ETH2 NO - Front USB Ports NO - M.2 NVMe SSD NO Testing Result on Orange Pi OPi-CM4 V1.4 OrangePi CM4 (OPi-CM4 V1.4) Super6C functons Compatibility - USB Port 1 NO - USB Port 2 NO - HDMI1 YES - HDMI2 NO - ETH1 NO - ETH2 NO - Front USB Ports NO - M.2 NVMe SSD NO Testing Result on Orange Pi OPi-CM5 V1.1 Can not booting from Orange Pi OPi-CM5 V1.1 computer module. OrangePi CM5 (OPi-CM5 V1.1) Super6C functons Compatibility - USB Port 1 NO - USB Port 2 NO - HDMI1 NO - HDMI2 NO - ETH1 NO - ETH2 NO - Front USB Ports NO - M.2 NVMe SSD NO Featrues Package Includes: 1pcs Raspberry Pi CM4 Cluster Mini-ITX board. 1pcs 100W Power supply. Note: Raspberry Pi CM4 board are not included Dimension 170mm x 170mm x 21mm (Mini-ITX) Applications Self-hosted: Host cloud applications locally or at the edge Learning Learning: Kubernetes, Docker, Serverless Development: Build cloud-native and CI/CD for ARM edge infrastructure Network-Attached Storage or Distributed Storage System :6 x ARM NAS node or CEPH node Software Port definitions 1 x DC IN +12~24V 2 x RJ45 Gigabit Ethernet Port 1Gbps 2 x Full-Sized HDMI Ports 1 x Micro USB Port from CM4 1# (Flashing EEPROM) 2 x CM4 1# USB Host 2.0 6 x CM4 Activity LED 3 x Fan Pin Header 1 x Always ON switch Power Supply Specifications Recommended: SWITCHING ADAPTER Model: FJ-SW2025G1904730 INPUT: 100-240V~50/60Hz 2.0A Max OUTPUT\uff1a19.0V \u2248 4.73A\uff0c 89.87W NOTE: Please pay attention to the order of starting up, if the order is wrong, you may see sparks at the DC port, so pay special attention here! ! ! Insert the DC head of the power adapter into the DC interface of the Super6C motherboard. Then insert the plug of the power supply into the wall socket or Power cord Mechanical Drawing Block Scheme Pin Headers definitions CM4 Jumpers Functions LED definitions 4-Pin ATX Power Pins definitions 12V Pin and GND: Power button and Reset Button Distribution of Pins Note\uff1a J6: If you are using 9pin USB pins, it is more common for motherboards that support Pentium4 or athlon XP chipsets (such as i845D, i845E, SiS 650, etc.) to need to drop the pins. If a 10-pin type USB pin is used, such as i815, i815E, i815EP, KT133 and other chipset motherboards, this pin can be reserved, please refer to the motherboard manual for wiring. J27 : J27 Pin is the control programming interface for power management, which is directly used for internal production, DO NOT CONNECT!!! J11/J13 : PoE1/PoE2 Not available, DO NOT CONNECT!!! How to install CM4 module Please press the CM4 module onto Super6c mainboard as following picture. Attach the CM4 to the board by simply aligning it with the two connectors on the IO board, then give it a good squeeze. It\u2019ll crunch into place and you should be set. and if you have SSD drive, install it as following picture. How to Flash image to eMMC on CM4 module. Flashing the Compute Module eMMC The Compute Module has an on-board eMMC device connected to the primary SD card interface. This guide explains how to write data to the eMMC storage using a Compute Module IO board. Please also read the section in the Compute Module Datasheets Compute Module 4 Ensure the Compute Module is fitted correctly installed on the IO board. It should lie flat on the IO board. Make sure that nRPBOOT which is on J2 (disable eMMC Boot) on the board jumper is fitted Use a micro USB cable to connect the micro USB slave port MCRO_USB on board to the host device. Do not power up yet. For Windows Users Under Windows, an installer is available to install the required drivers and boot tool automatically. Alternatively, a user can compile and run it using Cygwin and/or install the drivers manually. Windows Installer For those who just want to enable the Compute Module eMMC as a mass storage device under Windows, the stand-alone installer is the recommended option. This installer has been tested on Windows 10 32-bit and 64-bit, and Windows XP 32-bit. Please ensure you are not writing to any USB devices whilst the installer is running. Download and run the Windows installer to install the drivers and boot tool. windows installer download URL Plug your host PC USB into the USB SLAVE port, making sure you have setup the board as described above. Apply power to the board; Windows should now find the hardware and install the driver. Once the driver installation is complete, run the RPiBoot.exe tool that was previously installed. After a few seconds, the Compute Module eMMC will pop up under Windows as a disk (USB mass storage device). Building rpiboot on your host system (Cygwin/Linux) We will be using Git to get the rpiboot source code, so ensure Git is installed. In Cygwin, use the Cygwin installer. On a Raspberry Pi or other Debian-based Linux machine, use the following command: sudo apt install git Git may produce an error if the date is not set correctly. On a Raspberry Pi, enter the following to correct this: sudo data MMDDhhmm where MM is the month, DD is the date, and hh and mm are hours and minutes respectively. Clone the usbboot tool repository: git clone --depth = 1 https://github.com/raspberrypi/usbboot cd usbboot libusb must be installed. If you are using Cygwin, please make sure libusb is installed as previously described. On Raspberry Pi OS or other Debian-based Linux, enter the following command: sudo apt install libusb-1.0-0-dev Now build and install the usbboot tool: make Run the usbboot tool and it will wait for a connection: sudo ./rpiboot Now plug the host machine into the Super6C USB slave port and power on. The rpiboot tool will discover the Compute Module and send boot code to allow access to the eMMC. For more information run Writing to the eMMC (Windows) After rpiboot completes, a new USB mass storage drive will appear in Windows. We recommend using Raspberry Pi Imager to write images to the drive. Make sure J2 (nRPBOOT) is set to the disabled position and/or nothing is plugged into the USB slave port. Power cycling the IO board should now result in the Compute Module booting from eMMC. Writing to the eMMC (Linux) After rpiboot completes, you will see a new device appear; this is commonly /dev/sda on a Raspberry Pi but it could be another location such as /dev/sdb, so check in /dev/ or run lsblk before running rpiboot so you can see what changes. You now need to write a raw OS image (such as Raspberry Pi OS) to the device. Note the following command may take some time to complete, depending on the size of the image: (Change /dev/sdX to the appropriate device.) sudo dd if = raw_os_image_of_your_choice.img of = /dev/sdX bs = 4MiB Once the image has been written, unplug and re-plug the USB; you should see two partitions appear (for Raspberry Pi OS) in /dev. In total, you should see something similar to this: /dev/sdX <- device /dev/sdX1 <- First partition ( FAT ) /dev/sdX2 <- Second partition ( Linux Filesystem ) The /dev/sdX1 and /dev/sdX2 partitions can now be mounted normally. Make sure J2 (nRPBOOT) is set to the disabled position and/or nothing is plugged into the USB slave port. Power cycling the board should now result in the Compute Module booting from eMMC. Compute Module 4 Bootloader The default bootloader configuration on CM4 is designed to support bring up and development on a Compute Module 4 IO board and the software version flashed at manufacture may be older than the latest release. For final products please consider: Selecting and verifying a specific bootloader release. The version in the usbboot repo is always a recent stable release. Configuring the boot device (e.g. network boot). See BOOT_ORDER section in the bootloader configuration guide. Enabling hardware write protection on the bootloader EEPROM to ensure that the bootloader can\u2019t be modified on remote/inaccessible products. N.B. The Compute Module 4 ROM never runs recovery.bin from SD/EMMC and the rpi-eeprom-update service is not enabled by default. This is necessary because the EMMC is not removable and an invalid recovery.bin file would prevent the system from booting. This can be overridden and used with self-update mode where the bootloader can be updated from USB MSD or Network boot. However, self-update mode is not an atomic update and therefore not safe in the event of a power failure whilst the EEPROM was being updated. Modifying the bootloader configuration To modify the CM4 bootloader configuration: cd usbboot/recovery Replace pieeprom.original.bin if a specific bootloader release is required. Edit the default boot.conf bootloader configuration file. Typically, at least the BOOT_ORDER must be updated: For network boot BOOT_ORDER=0xf2 For SD/EMMC boot BOOT_ORDER=0xf1 For USB boot failing over to EMMC BOOT_ORDER=0xf15 Run ./update-pieeprom.sh to update the EEPROM image pieeprom.bin image file. If EEPROM write protection is required then edit config.txt and add eeprom_write_protect=1 . Hardware write-protection must be enabled via software and then locked by pulling the EEPROM_nWP pin low. Run ../rpiboot -d . to update the bootloader using the updated EEPROM image pieeprom.bin The pieeprom.bin file is now ready to be flashed to the Compute Module 4. Flashing the bootloader EEPROM - Compute Module 4 To flash the bootloader EEPROM follow the same hardware setup as for flashing the EMMC but also ensure EEPROM_nWP is NOT pulled low. Once complete EEPROM_nWP may be pulled low again. # Writes recovery/pieeprom bin to the bootloader EEPROM. ./rpiboot -d recovery Troubleshooting For a small percentage of Raspberry Pi Compute Module 3s, booting problems have been reported. We have traced these back to the method used to create the FAT32 partition; we believe the problem is due to a difference in timing between the BCM2835/6/7 and the newer eMMC devices. The following method of creating the partition is a reliable solution in our hands. sudo parted /dev/<device> ( parted ) mkpart primary fat32 4MiB 64MiB ( parted ) q sudo mkfs.vfat -F32 /dev/<device> sudo cp -r <files>/* <mountpoint> After Flash Raspberry Pi OS to eMMC on CM4 module, just power off the system, and one complete, 5 to go, just repeat those step five times. If your CM4 Module does not have eMMC on board, that will be easy, just flash Raspberry Pi OS to TF card or SSD drive, and insert them to card slot, fix it with screws. and connect the power supply, and press PWR_BTN button to power them on. If your CM4 module has eMMC on board, the SSD drive and TF card can be external mass storage. How to build your own cluster and manage the cluster via Ansible Fit for CM4 Lite version Note: The latest Raspberry Pi OS does not contain pi user and it may not need to add dtoverlay=dwc2,dr_mode=host to config.txt file on location /boot . Assume you are using the old version (Raspberry Pi OS 2021-11-08) CM4 Lite means Raspberry Pi Computer module come without a EMMC storage onboard.\u3000That means additional MicroSD card(TF card) is required. Steps: Download the latest Raspberry Pi OS 64bit image from: Download Image Unzip it and flash the .img file to TF card by using Etcher tool, which can be downloaded via Download flash tool Modify config.txt file in TF card and adding dtoverlay=dwc2,dr_mode=host to it and save it. (Do not need to execute this step if your using the latest version image) Before we unplug, now that your CM4 is fully flashed and ready to go, you\u2019ll be surprised to learn that the USB Ports are disabled by default. Yes, really. Remember, this is a board designed to be embedded elsewhere and not for consumer-level off-the-shelf use. In the \u201cboot\u201d folder, find the config.txt and add the following: dtoverlay = dwc2,dr_mode = host This will turn on the USB ports when you boot up, but if you accidentally keep the micro USB in, you will run into issues. Before you begin your first boot, make sure everything is unplugged. Boot and then plug in your mouse or keyboard. If you\u2019re like me and couldn\u2019t get a wi-fi version, this is where you\u2019ll plug in your dongle or ethernet cable. Create a new file named ssh on TF card /boot folder Insert TF card into card slot on Super6C board. Connect the power supply to DC Socket or Using ATX Power supply. (Max. 24V/6.15A) Connect Full-sized HDMI cable to super6C, Other head connect to your TV or Monitor. Connect Keyboard and mouse to USB2.0 port on board. Connect Ethernet cable to ETH1 to your Router. Press PWR_BTN button to booting up all of CM4 modules. Press Reset button will reset all of CM4 modules, unsaved file will be lost!!! Login to Raspberry pi username: pi default password: raspberry * Make sure your OS can access internet. Deploy ansible environments as following steps If you want to use Ansible to manage Raspberry Pi cluster, you need to upgrade python version from 3.7 to 3.8 as following steps: Remove old version python sudo apt remove ansible sudo apt purge \u2013y python2.7-minimal Update and upgrade system. sudo apt update sudo apt upgrade \u2013y Install dependencies. sudo apt-get install -y build-essential tk-dev libncurses5-dev \\ libncursesw5-dev libreadline6-dev libdb5.3-dev libgdbm-dev libsqlite3-dev \\ libssl-dev libbz2-dev libexpat1-dev liblzma-dev zlib1g-dev libffi-dev Download source code and compile it. version = 3 .8.5 wget https://www.python.org/ftp/python/ $version /Python- $version .tgz tar zxf Python- $version .tgz cd Python- $version ./configure --enable-optimizations make -j4 sudo make altinstall Do remember:\u3000Installs Python into /usr/local/bin Install ansible We can use apt or your particular distro package manager, but doing that, we risk no getting the latest version available. In some cases, I have to agree that is good idea, we make sure system is kept stable and the packages has been tested enough, but in technologies like Ansible, which is still changing so rapidly, I recommend you to go ahead in your tests and get the latest version, that way you will also learn to use those latest versions, which have some modules usage differences. Lets see the version installed using apt in Raspbian. sudo apt list ansible pip3 install ansible --user Installing Ansible using the --user option, will make that the binary will be available directly under your user home, and not in your root bin directory (/bin,/usr/bin..) For that, I recommend you to add your $user_home/.local/bin to your PATH environment: Ansible Project Configuration Now that we have Ansible installed, let\u2019s set some basic configuration. Create a directory for our first project where we are going to set the different configuration files and Ansible playbooks mkdir Ansible First file we are going to create, is an Ansible configuration file. This will make sure we are using correct inventory file and some specific options for this project. In this case, we will use the inventory file in the local directory and will be connecting to the remote server as root. Additionally, will disable ssh-key check so we can connect to the servers without doing first ssh-key handshake (is a security risk, but will help us to destroy and deploy containers and VMs more rapidly in the future) Using --version attribute, will allow us to make sure we are suing correct configuration file: Create the inventory file with the list of hosts We can list all the hosts from our inventory\uff1a If we try the command ansible ping we will have errors, since we can not actually connect to our servers using SSH public keys. ansible all \u2013m ping and before that, we need to create a file called ping.yml. FAQ Q: What can I do with Super6C ? A: Home server (homelab) and cloud apps hosting. Learn Kubernetes, Docker Swarm, Serverless, Microservices on bare metal Cloud-native apps testing environment Learn concepts of distributed Machine Learning apps Prototype and learn cluster applications, parallel computing, and distributed computing concepts Host K8S, K3S, Minecraft, Plex, Owncloud, Nextcloud, Seafile, Minio, Tensorflow Q: Which Raspberry Pi models are compatible ? A: Super6C supports all Raspberry Pi CM4 with and without eMMC. Q: Does Raspberry Pi include compute modules ? A: No, the product only have cluster motherboard and power adapter. Q: From where Super6C boots OS ? A: You can boot the OS either from eMMC, SD Card or netboot. Q: Does each node get its own IP address? A: Yes Q: How the compute modelues communicate with each other ? A: The nodes interconnected with the onboard 1 Gbps switch. And, each node has 1Gbps speed. Q: Do all the slots need to be filled in ? A: The cluster works with any amount of nodes. You can start with a couple of nodes and scale when needed. Q: Can I flash compute modules through the board ? A:Yes, you can flash a compute module using a Micro USB cable. Q: How do the NIC, Ethernet, USB, HDMI, and audio ports work ? A: There are 2 USB-A an 2 USB 2.54 Pins on the board.They only connect to CM4 1$. The two HDMI ports are also the same. NIC \u2013 There is an 8-port gigabit switch on the board. Each port goes to each node plus one uplink. Two RJ45 out are from the switch. You can use them connect to other network device without extern switch. Q: Can Super6C function from either an ATX power supply 12V ? A: Yes. Q: Can I use this cluster io expansion board to just running my MySQL server? A: Yes, you can running not only MySQL server but also PostgreSQL, SQLite, Mongo DB and so on.","title":"DeskPi Super6C"},{"location":"super6c/#deskpi-super6c","text":"","title":"DeskPi Super6C"},{"location":"super6c/#purchase","text":"DeskPi Super6C","title":"Purchase"},{"location":"super6c/#description","text":"DeskPi Super6C is the Raspberry Pi cluster board a standard size mini-ITX board to be put in a case with up to 6 RPI CM4 Compute Modules. - For every CM4: * M.2 2280 slot (PCIe Gen 2 x1) * TF Card slot * 5V FAN Header * Micro USB 2.0 Only for 1st CM4: USB Host A 2.0 x2 USB Host 2.54 4-pins x2 HDMI 2.0 x1 HDMI 1.4a x1","title":"Description"},{"location":"super6c/#compatibility","text":"Currently, after testing, Super6C is not only able to support the Raspberry Pi CM4 module but can also boot some CM4 modules from other brands. However, it is limited to just booting, and many core functions of Super6C are still unusable. This is likely due to the pin distribution and functionality of the board-to-board connector being different from that of the Raspberry Pi. It is recommended to continue using the Raspberry Pi CM4 module in conjunction with Super6C. Testing Result on BPi-CM4 V1.0 BananaPi CM4 (BPi-CM4 V1.0) Super6C functons Compatibility - USB Port 1 YES - USB Port 2 YES - HDMI1 YES - HDMI2 NO - ETH1 NO - ETH2 NO - Front USB Ports NO - M.2 NVMe SSD NO Testing Result on Orange Pi OPi-CM4 V1.4 OrangePi CM4 (OPi-CM4 V1.4) Super6C functons Compatibility - USB Port 1 NO - USB Port 2 NO - HDMI1 YES - HDMI2 NO - ETH1 NO - ETH2 NO - Front USB Ports NO - M.2 NVMe SSD NO Testing Result on Orange Pi OPi-CM5 V1.1 Can not booting from Orange Pi OPi-CM5 V1.1 computer module. OrangePi CM5 (OPi-CM5 V1.1) Super6C functons Compatibility - USB Port 1 NO - USB Port 2 NO - HDMI1 NO - HDMI2 NO - ETH1 NO - ETH2 NO - Front USB Ports NO - M.2 NVMe SSD NO","title":"Compatibility"},{"location":"super6c/#featrues","text":"","title":"Featrues"},{"location":"super6c/#package-includes","text":"1pcs Raspberry Pi CM4 Cluster Mini-ITX board. 1pcs 100W Power supply. Note: Raspberry Pi CM4 board are not included","title":"Package Includes:"},{"location":"super6c/#dimension","text":"170mm x 170mm x 21mm (Mini-ITX)","title":"Dimension"},{"location":"super6c/#applications","text":"Self-hosted: Host cloud applications locally or at the edge Learning Learning: Kubernetes, Docker, Serverless Development: Build cloud-native and CI/CD for ARM edge infrastructure Network-Attached Storage or Distributed Storage System :6 x ARM NAS node or CEPH node","title":"Applications"},{"location":"super6c/#software","text":"","title":"Software"},{"location":"super6c/#port-definitions","text":"1 x DC IN +12~24V 2 x RJ45 Gigabit Ethernet Port 1Gbps 2 x Full-Sized HDMI Ports 1 x Micro USB Port from CM4 1# (Flashing EEPROM) 2 x CM4 1# USB Host 2.0 6 x CM4 Activity LED 3 x Fan Pin Header 1 x Always ON switch","title":"Port definitions"},{"location":"super6c/#power-supply-specifications","text":"Recommended: SWITCHING ADAPTER Model: FJ-SW2025G1904730 INPUT: 100-240V~50/60Hz 2.0A Max OUTPUT\uff1a19.0V \u2248 4.73A\uff0c 89.87W NOTE: Please pay attention to the order of starting up, if the order is wrong, you may see sparks at the DC port, so pay special attention here! ! ! Insert the DC head of the power adapter into the DC interface of the Super6C motherboard. Then insert the plug of the power supply into the wall socket or Power cord","title":"Power Supply Specifications"},{"location":"super6c/#mechanical-drawing","text":"","title":"Mechanical Drawing"},{"location":"super6c/#block-scheme","text":"","title":"Block Scheme"},{"location":"super6c/#pin-headers-definitions","text":"CM4 Jumpers Functions LED definitions 4-Pin ATX Power Pins definitions 12V Pin and GND: Power button and Reset Button Distribution of Pins Note\uff1a J6: If you are using 9pin USB pins, it is more common for motherboards that support Pentium4 or athlon XP chipsets (such as i845D, i845E, SiS 650, etc.) to need to drop the pins. If a 10-pin type USB pin is used, such as i815, i815E, i815EP, KT133 and other chipset motherboards, this pin can be reserved, please refer to the motherboard manual for wiring. J27 : J27 Pin is the control programming interface for power management, which is directly used for internal production, DO NOT CONNECT!!! J11/J13 : PoE1/PoE2 Not available, DO NOT CONNECT!!!","title":"Pin Headers definitions"},{"location":"super6c/#how-to-install-cm4-module","text":"Please press the CM4 module onto Super6c mainboard as following picture. Attach the CM4 to the board by simply aligning it with the two connectors on the IO board, then give it a good squeeze. It\u2019ll crunch into place and you should be set. and if you have SSD drive, install it as following picture.","title":"How to install CM4 module"},{"location":"super6c/#how-to-flash-image-to-emmc-on-cm4-module","text":"Flashing the Compute Module eMMC The Compute Module has an on-board eMMC device connected to the primary SD card interface. This guide explains how to write data to the eMMC storage using a Compute Module IO board. Please also read the section in the Compute Module Datasheets Compute Module 4 Ensure the Compute Module is fitted correctly installed on the IO board. It should lie flat on the IO board. Make sure that nRPBOOT which is on J2 (disable eMMC Boot) on the board jumper is fitted Use a micro USB cable to connect the micro USB slave port MCRO_USB on board to the host device. Do not power up yet. For Windows Users Under Windows, an installer is available to install the required drivers and boot tool automatically. Alternatively, a user can compile and run it using Cygwin and/or install the drivers manually. Windows Installer For those who just want to enable the Compute Module eMMC as a mass storage device under Windows, the stand-alone installer is the recommended option. This installer has been tested on Windows 10 32-bit and 64-bit, and Windows XP 32-bit. Please ensure you are not writing to any USB devices whilst the installer is running. Download and run the Windows installer to install the drivers and boot tool. windows installer download URL Plug your host PC USB into the USB SLAVE port, making sure you have setup the board as described above. Apply power to the board; Windows should now find the hardware and install the driver. Once the driver installation is complete, run the RPiBoot.exe tool that was previously installed. After a few seconds, the Compute Module eMMC will pop up under Windows as a disk (USB mass storage device). Building rpiboot on your host system (Cygwin/Linux) We will be using Git to get the rpiboot source code, so ensure Git is installed. In Cygwin, use the Cygwin installer. On a Raspberry Pi or other Debian-based Linux machine, use the following command: sudo apt install git Git may produce an error if the date is not set correctly. On a Raspberry Pi, enter the following to correct this: sudo data MMDDhhmm where MM is the month, DD is the date, and hh and mm are hours and minutes respectively. Clone the usbboot tool repository: git clone --depth = 1 https://github.com/raspberrypi/usbboot cd usbboot libusb must be installed. If you are using Cygwin, please make sure libusb is installed as previously described. On Raspberry Pi OS or other Debian-based Linux, enter the following command: sudo apt install libusb-1.0-0-dev Now build and install the usbboot tool: make Run the usbboot tool and it will wait for a connection: sudo ./rpiboot Now plug the host machine into the Super6C USB slave port and power on. The rpiboot tool will discover the Compute Module and send boot code to allow access to the eMMC.","title":"How to Flash image to eMMC on CM4 module."},{"location":"super6c/#for-more-information-run","text":"Writing to the eMMC (Windows) After rpiboot completes, a new USB mass storage drive will appear in Windows. We recommend using Raspberry Pi Imager to write images to the drive. Make sure J2 (nRPBOOT) is set to the disabled position and/or nothing is plugged into the USB slave port. Power cycling the IO board should now result in the Compute Module booting from eMMC. Writing to the eMMC (Linux) After rpiboot completes, you will see a new device appear; this is commonly /dev/sda on a Raspberry Pi but it could be another location such as /dev/sdb, so check in /dev/ or run lsblk before running rpiboot so you can see what changes. You now need to write a raw OS image (such as Raspberry Pi OS) to the device. Note the following command may take some time to complete, depending on the size of the image: (Change /dev/sdX to the appropriate device.) sudo dd if = raw_os_image_of_your_choice.img of = /dev/sdX bs = 4MiB Once the image has been written, unplug and re-plug the USB; you should see two partitions appear (for Raspberry Pi OS) in /dev. In total, you should see something similar to this: /dev/sdX <- device /dev/sdX1 <- First partition ( FAT ) /dev/sdX2 <- Second partition ( Linux Filesystem ) The /dev/sdX1 and /dev/sdX2 partitions can now be mounted normally. Make sure J2 (nRPBOOT) is set to the disabled position and/or nothing is plugged into the USB slave port. Power cycling the board should now result in the Compute Module booting from eMMC.","title":"For more information run"},{"location":"super6c/#compute-module-4-bootloader","text":"The default bootloader configuration on CM4 is designed to support bring up and development on a Compute Module 4 IO board and the software version flashed at manufacture may be older than the latest release. For final products please consider: Selecting and verifying a specific bootloader release. The version in the usbboot repo is always a recent stable release. Configuring the boot device (e.g. network boot). See BOOT_ORDER section in the bootloader configuration guide. Enabling hardware write protection on the bootloader EEPROM to ensure that the bootloader can\u2019t be modified on remote/inaccessible products. N.B. The Compute Module 4 ROM never runs recovery.bin from SD/EMMC and the rpi-eeprom-update service is not enabled by default. This is necessary because the EMMC is not removable and an invalid recovery.bin file would prevent the system from booting. This can be overridden and used with self-update mode where the bootloader can be updated from USB MSD or Network boot. However, self-update mode is not an atomic update and therefore not safe in the event of a power failure whilst the EEPROM was being updated.","title":"Compute Module 4 Bootloader"},{"location":"super6c/#modifying-the-bootloader-configuration","text":"To modify the CM4 bootloader configuration: cd usbboot/recovery Replace pieeprom.original.bin if a specific bootloader release is required. Edit the default boot.conf bootloader configuration file. Typically, at least the BOOT_ORDER must be updated: For network boot BOOT_ORDER=0xf2 For SD/EMMC boot BOOT_ORDER=0xf1 For USB boot failing over to EMMC BOOT_ORDER=0xf15 Run ./update-pieeprom.sh to update the EEPROM image pieeprom.bin image file. If EEPROM write protection is required then edit config.txt and add eeprom_write_protect=1 . Hardware write-protection must be enabled via software and then locked by pulling the EEPROM_nWP pin low. Run ../rpiboot -d . to update the bootloader using the updated EEPROM image pieeprom.bin The pieeprom.bin file is now ready to be flashed to the Compute Module 4.","title":"Modifying the bootloader configuration"},{"location":"super6c/#flashing-the-bootloader-eeprom-compute-module-4","text":"To flash the bootloader EEPROM follow the same hardware setup as for flashing the EMMC but also ensure EEPROM_nWP is NOT pulled low. Once complete EEPROM_nWP may be pulled low again. # Writes recovery/pieeprom bin to the bootloader EEPROM. ./rpiboot -d recovery","title":"Flashing the bootloader EEPROM - Compute Module 4"},{"location":"super6c/#troubleshooting","text":"For a small percentage of Raspberry Pi Compute Module 3s, booting problems have been reported. We have traced these back to the method used to create the FAT32 partition; we believe the problem is due to a difference in timing between the BCM2835/6/7 and the newer eMMC devices. The following method of creating the partition is a reliable solution in our hands. sudo parted /dev/<device> ( parted ) mkpart primary fat32 4MiB 64MiB ( parted ) q sudo mkfs.vfat -F32 /dev/<device> sudo cp -r <files>/* <mountpoint> After Flash Raspberry Pi OS to eMMC on CM4 module, just power off the system, and one complete, 5 to go, just repeat those step five times. If your CM4 Module does not have eMMC on board, that will be easy, just flash Raspberry Pi OS to TF card or SSD drive, and insert them to card slot, fix it with screws. and connect the power supply, and press PWR_BTN button to power them on. If your CM4 module has eMMC on board, the SSD drive and TF card can be external mass storage.","title":"Troubleshooting"},{"location":"super6c/#how-to-build-your-own-cluster-and-manage-the-cluster-via-ansible","text":"","title":"How to build your own cluster and manage the cluster via Ansible"},{"location":"super6c/#fit-for-cm4-lite-version","text":"Note: The latest Raspberry Pi OS does not contain pi user and it may not need to add dtoverlay=dwc2,dr_mode=host to config.txt file on location /boot . Assume you are using the old version (Raspberry Pi OS 2021-11-08) CM4 Lite means Raspberry Pi Computer module come without a EMMC storage onboard.\u3000That means additional MicroSD card(TF card) is required.","title":"Fit for CM4 Lite version"},{"location":"super6c/#steps","text":"Download the latest Raspberry Pi OS 64bit image from: Download Image Unzip it and flash the .img file to TF card by using Etcher tool, which can be downloaded via Download flash tool Modify config.txt file in TF card and adding dtoverlay=dwc2,dr_mode=host to it and save it. (Do not need to execute this step if your using the latest version image) Before we unplug, now that your CM4 is fully flashed and ready to go, you\u2019ll be surprised to learn that the USB Ports are disabled by default. Yes, really. Remember, this is a board designed to be embedded elsewhere and not for consumer-level off-the-shelf use. In the \u201cboot\u201d folder, find the config.txt and add the following: dtoverlay = dwc2,dr_mode = host This will turn on the USB ports when you boot up, but if you accidentally keep the micro USB in, you will run into issues. Before you begin your first boot, make sure everything is unplugged. Boot and then plug in your mouse or keyboard. If you\u2019re like me and couldn\u2019t get a wi-fi version, this is where you\u2019ll plug in your dongle or ethernet cable. Create a new file named ssh on TF card /boot folder Insert TF card into card slot on Super6C board. Connect the power supply to DC Socket or Using ATX Power supply. (Max. 24V/6.15A) Connect Full-sized HDMI cable to super6C, Other head connect to your TV or Monitor. Connect Keyboard and mouse to USB2.0 port on board. Connect Ethernet cable to ETH1 to your Router. Press PWR_BTN button to booting up all of CM4 modules. Press Reset button will reset all of CM4 modules, unsaved file will be lost!!! Login to Raspberry pi username: pi default password: raspberry * Make sure your OS can access internet. Deploy ansible environments as following steps If you want to use Ansible to manage Raspberry Pi cluster, you need to upgrade python version from 3.7 to 3.8 as following steps: Remove old version python sudo apt remove ansible sudo apt purge \u2013y python2.7-minimal Update and upgrade system. sudo apt update sudo apt upgrade \u2013y Install dependencies. sudo apt-get install -y build-essential tk-dev libncurses5-dev \\ libncursesw5-dev libreadline6-dev libdb5.3-dev libgdbm-dev libsqlite3-dev \\ libssl-dev libbz2-dev libexpat1-dev liblzma-dev zlib1g-dev libffi-dev Download source code and compile it. version = 3 .8.5 wget https://www.python.org/ftp/python/ $version /Python- $version .tgz tar zxf Python- $version .tgz cd Python- $version ./configure --enable-optimizations make -j4 sudo make altinstall Do remember:\u3000Installs Python into /usr/local/bin Install ansible We can use apt or your particular distro package manager, but doing that, we risk no getting the latest version available. In some cases, I have to agree that is good idea, we make sure system is kept stable and the packages has been tested enough, but in technologies like Ansible, which is still changing so rapidly, I recommend you to go ahead in your tests and get the latest version, that way you will also learn to use those latest versions, which have some modules usage differences. Lets see the version installed using apt in Raspbian. sudo apt list ansible pip3 install ansible --user Installing Ansible using the --user option, will make that the binary will be available directly under your user home, and not in your root bin directory (/bin,/usr/bin..) For that, I recommend you to add your $user_home/.local/bin to your PATH environment:","title":"Steps:"},{"location":"super6c/#ansible-project-configuration","text":"Now that we have Ansible installed, let\u2019s set some basic configuration. Create a directory for our first project where we are going to set the different configuration files and Ansible playbooks mkdir Ansible First file we are going to create, is an Ansible configuration file. This will make sure we are using correct inventory file and some specific options for this project. In this case, we will use the inventory file in the local directory and will be connecting to the remote server as root. Additionally, will disable ssh-key check so we can connect to the servers without doing first ssh-key handshake (is a security risk, but will help us to destroy and deploy containers and VMs more rapidly in the future) Using --version attribute, will allow us to make sure we are suing correct configuration file: Create the inventory file with the list of hosts We can list all the hosts from our inventory\uff1a If we try the command ansible ping we will have errors, since we can not actually connect to our servers using SSH public keys. ansible all \u2013m ping and before that, we need to create a file called ping.yml.","title":"Ansible Project Configuration"},{"location":"super6c/#faq","text":"Q: What can I do with Super6C ? A: Home server (homelab) and cloud apps hosting. Learn Kubernetes, Docker Swarm, Serverless, Microservices on bare metal Cloud-native apps testing environment Learn concepts of distributed Machine Learning apps Prototype and learn cluster applications, parallel computing, and distributed computing concepts Host K8S, K3S, Minecraft, Plex, Owncloud, Nextcloud, Seafile, Minio, Tensorflow Q: Which Raspberry Pi models are compatible ? A: Super6C supports all Raspberry Pi CM4 with and without eMMC. Q: Does Raspberry Pi include compute modules ? A: No, the product only have cluster motherboard and power adapter. Q: From where Super6C boots OS ? A: You can boot the OS either from eMMC, SD Card or netboot. Q: Does each node get its own IP address? A: Yes Q: How the compute modelues communicate with each other ? A: The nodes interconnected with the onboard 1 Gbps switch. And, each node has 1Gbps speed. Q: Do all the slots need to be filled in ? A: The cluster works with any amount of nodes. You can start with a couple of nodes and scale when needed. Q: Can I flash compute modules through the board ? A:Yes, you can flash a compute module using a Micro USB cable. Q: How do the NIC, Ethernet, USB, HDMI, and audio ports work ? A: There are 2 USB-A an 2 USB 2.54 Pins on the board.They only connect to CM4 1$. The two HDMI ports are also the same. NIC \u2013 There is an 8-port gigabit switch on the board. Each port goes to each node plus one uplink. Two RJ45 out are from the switch. You can use them connect to other network device without extern switch. Q: Can Super6C function from either an ATX power supply 12V ? A: Yes. Q: Can I use this cluster io expansion board to just running my MySQL server? A: Yes, you can running not only MySQL server but also PostgreSQL, SQLite, Mongo DB and so on.","title":"FAQ"}]}